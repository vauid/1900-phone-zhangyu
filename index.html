<!DOCTYPE html>

<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, user-scalable=no" name="viewport"/>
<title>章鱼喷墨机</title>
<meta content="yes" name="apple-mobile-web-app-capable"/>
<link href="https://i.postimg.cc/nzP9sgxr/chan-125.png" rel="apple-touch-icon"/>
<meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/>
<script src="https://unpkg.com/dexie/dist/dexie.js"></script>
<style>
        /* --- 全局与主题样式 --- */
        :root {
            --bg-color: #fce4ec;
            --primary-color: #ff80ab;
            --secondary-color: #f48fb1;
            --accent-color: #90caf9;
            --text-color: #444;
            --white-color: #fff;
            --border-radius: 18px;
            --phone-corner-radius: 0px;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            --top-pinned-bg: #fff0f5;
            --online-status-color: #4CAF50;
        }

        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #fce4ec, #f8bbd0);
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        .phone-screen {
            width: 100%;
            max-width: 420px;
            height: 100vh;
            max-height: 850px;
            background-color: var(--white-color);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border-radius: var(--phone-corner-radius);
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .screen {
            display: none;
            position: relative;
            flex-direction: column;
            width: 100%;
            height: 100%;
            animation: fadeIn 0.5s ease;
        }

        .screen.active {
            display: flex;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid #eee;
            flex-shrink: 0;
            position: relative;
            z-index: 10;
        }

        .app-header .back-btn,
        .app-header .action-btn {
            background: none;
            border: none;
            font-size: 24px;
            font-weight: bold;
            color: var(--primary-color);
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #cancel-multi-select-btn {
            font-size: 14px !important;
            font-weight: 500 !important;
            color: var(--white-color) !important;
            background-color: var(--primary-color) !important;
            border-radius: 10px !important;
            padding: 5px 10px !important;
            width: auto !important;
            height: auto !important;
        }

        .app-header .action-btn-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .app-header .action-btn-group .action-btn {
            font-size: 16px;
            font-weight: 600;
            width: auto;
            padding: 6px 12px;
            border-radius: 10px;
        }

        .app-header .action-btn-group #create-group-btn {
            background-color: var(--primary-color);
            color: var(--white-color);
        }

        .app-header .action-btn-group #add-chat-btn {
            font-size: 28px;
            padding: 0;
            width: 40px;
            height: 40px;
            background-color: transparent;
            color: var(--primary-color);
            border-radius: 50%;
        }

        .app-header .action-btn img {
            width: 28px;
            height: 28px;
        }

        .app-header .title-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .app-header .title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-color);
            margin: 0;
        }

        .app-header .subtitle {
            font-size: 12px;
            color: #888;
            display: flex;
            align-items: center;
            margin-top: 2px;
        }

        .online-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--online-status-color);
            margin-right: 5px;
        }

        .app-header .placeholder {
            width: 40px;
        }

        #home-screen {
            justify-content: space-between;
            background-size: cover;
            background-position: center;
            transition: background-image 0.5s ease-in-out;
            padding: 50px 0;
        }

        .time-widget {
            text-align: center;
            padding: 0 20px;
            color: var(--text-color);
        }

        .time-widget .time {
            font-size: 72px;
            font-weight: 600;
        }

        .time-widget .date {
            font-size: 18px;
            color: #666;
        }

        #home-screen.day-mode .time-widget,
        #home-screen.day-mode .time-widget .date,
        #home-screen.day-mode .app-icon .app-name {
            color: var(--white-color);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        }

        .app-grid {
            width: 100%;
            padding: 20px 40px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            justify-content: center;
            align-content: center;
            margin-top: 40px;
        }

        #home-screen.day-mode .time-widget,
        #home-screen.day-mode .time-widget .date,
        #home-screen.day-mode .app-icon .app-name {
            color: var(--white-color);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        }

        .dock {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border-radius: var(--border-radius);
            margin: 0 20px;
            min-height: 80px;
            gap: 15px;
        }

        .app-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            text-decoration: none;
        }

        .icon-img {
            width: 60px;
            height: 60px;
            border-radius: 15px;
            margin-bottom: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
            object-fit: cover;
        }

        .app-icon:hover .icon-img {
            transform: translateY(-5px);
        }

        .app-icon .app-name {
            font-size: 12px;
            color: var(--text-color);
            font-weight: 500;
        }

        .content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            position: relative;
        }

        .placeholder-text {
            text-align: center;
            color: #aaa;
            margin-top: 50px;
        }

        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: 100;
            display: none;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal-window {
            background: var(--white-color);
            padding: 25px;
            border-radius: var(--border-radius);
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.15);
            width: 85%;
            max-width: 340px;
            animation: slideUp 0.4s ease-out;
        }

        .modal-window h3 {
            margin-top: 0;
            text-align: center;
            color: var(--primary-color);
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        #edit-group-member-modal,
        #create-member-for-group-modal {
            z-index: 102;
        }

        #edit-group-member-modal .avatar-preview,
        #create-member-for-group-modal .avatar-preview {
            width: 80px;
            height: 80px;
        }

        .context-menu {
            position: fixed;
            z-index: 1000;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            padding: 5px 0;
            animation: fadeIn 0.1s ease;
        }

        .context-menu-item {
            padding: 10px 20px;
            cursor: pointer;
        }

        .context-menu-item:hover {
            background-color: #f5f5f5;
        }

        .context-menu-item.danger {
            color: #e53935;
        }

        .action-sheet-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: 200;
            display: none;
            align-items: flex-end;
            animation: fadeIn 0.3s ease;
        }

        .action-sheet-overlay.visible {
            display: flex;
        }

        .action-sheet {
            background: #f7f7f7;
            width: 100%;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            padding: 10px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            animation: slideUp 0.3s ease-out;
        }

        .action-sheet-button {
            width: 100%;
            background: white;
            border: none;
            padding: 15px;
            font-size: 16px;
            color: var(--primary-color);
            font-weight: 500;
            cursor: pointer;
            border-radius: 10px;
            margin-bottom: 8px;
        }

        .action-sheet-button.danger {
            color: #e53935;
        }

        .action-sheet-button:last-child {
            margin-bottom: 0;
        }

        #chat-list-screen .content,
        #world-book-screen .content {
            padding: 10px 0 0 0;
        }

        .list-container {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .list-item {
            display: flex;
            align-items: center;
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s ease;
            position: relative;
        }

        .list-item:hover {
            background-color: #fdf6f8;
        }

        .chat-item.pinned {
            background-color: var(--top-pinned-bg);
        }

        .chat-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin-right: 15px;
            object-fit: cover;
            flex-shrink: 0;
            background-color: #eee;
        }

        .group-avatar {
            border-radius: 10px;
        }

        .item-details {
            flex-grow: 1;
            overflow: hidden;
        }

        .item-details-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .item-name {
            font-weight: 600;
            color: var(--text-color);
            font-size: 16px;
        }

        .item-preview-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 4px;
        }

        .item-preview {
            font-size: 14px;
            color: #888;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-grow: 1;
        }

        .pin-badge {
            background-color: var(--primary-color);
            color: white;
            font-size: 10px;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 5px;
            white-space: nowrap;
            flex-shrink: 0;
        }

        #chat-room-screen {
            background-size: cover;
            background-position: center;
        }

        #chat-room-screen .content {
            display: flex;
            flex-direction: column;
            padding: 10px;
            padding-bottom: 10px;
            transition: padding-bottom 0.3s ease;
        }

        #chat-room-screen.multi-select-active .content {
            padding-bottom: 70px;
        }

        .message-area {
            flex-grow: 1;
            overflow-y: auto;
            padding: 0 10px;
            scroll-behavior: smooth;
        }

        .message-wrapper {
            display: flex;
            margin-bottom: 12px;
            align-items: flex-start;
            transition: background-color 0.2s;
            flex-direction: column;
        }

        .message-wrapper.group-message {
            margin-bottom: 18px;
        }

        .message-wrapper.sent {
            align-items: flex-end;
        }

        .message-wrapper.received {
            align-items: flex-start;
        }

        .message-wrapper.system-notification {
            align-items: center;
        }

        .message-bubble-row {
            display: flex;
            width: 100%;
            align-items: flex-start;
        }

        .message-wrapper.sent .message-bubble-row {
            flex-direction: row-reverse;
        }

        .message-wrapper.multi-select-selected {
            background-color: rgba(144, 202, 249, 0.2);
            border-radius: var(--border-radius);
        }

        .message-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .group-nickname {
            position: absolute;
            top: -15px;
            font-size: 11px;
            color: #888;
            white-space: nowrap;
            width: 70px;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .message-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            object-fit: cover;
        }

        .message-time {
            font-size: 9px;
            color: #aaa;
            margin-top: 3px;
        }

        .message-bubble {
            max-width: 260px;
            padding: 8px 12px;
            border-radius: var(--border-radius);
            word-wrap: break-word;
            line-height: 1.4;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            margin: 0 8px;
            cursor: pointer;
            font-size: 15px;
        }

        .message-bubble.sent {
            border-bottom-right-radius: 5px;
        }

        .message-bubble.received {
            border-bottom-left-radius: 5px;
        }

        .system-notification-bubble {
            background-color: rgba(200, 200, 200, 0.5);
            color: #666;
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 10px;
            text-align: center;
        }

        .image-bubble {
            max-width: 120px;
            border-radius: var(--border-radius);
            margin: 0 8px;
            padding: 4px;
            background-color: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }

        .image-bubble img {
            width: 100%;
            height: auto;
            display: block;
            border-radius: calc(var(--border-radius) - 4px);
        }

        .message-wrapper.sent .image-bubble {
            border-bottom-right-radius: 5px;
        }

        .message-wrapper.received .image-bubble {
            border-bottom-left-radius: 5px;
        }

        .voice-bubble {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            border-radius: var(--border-radius);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            margin: 0 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 90px;
            max-width: 200px;
        }

        .message-wrapper.sent .voice-bubble {
            border-bottom-right-radius: 5px;
            flex-direction: row-reverse;
        }

        .message-wrapper.received .voice-bubble {
            border-bottom-left-radius: 5px;
        }

        .voice-bubble .play-icon {
            width: 18px;
            height: 18px;
            flex-shrink: 0;
        }

        .voice-bubble .duration {
            font-size: 13px;
            margin: 0 8px;
            white-space: nowrap;
        }

        .message-wrapper.sent .play-icon {
            transform: scaleX(-1);
        }

        .voice-transcript {
            font-size: 14px;
            color: #555;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 8px 12px;
            margin-top: 5px;
            margin-left: 54px;
            margin-right: 54px;
            border-radius: 10px;
            line-height: 1.6;
            max-width: calc(100% - 108px);
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .voice-transcript.active {
            display: block;
        }

        .message-wrapper.sent .voice-transcript {
            align-self: flex-end;
            margin-right: 54px;
            margin-left: auto;
        }

        .message-wrapper.received .voice-transcript {
            align-self: flex-start;
            margin-left: 54px;
            margin-right: auto;
        }

        .pv-card {
            width: 230px;
            aspect-ratio: 1 / 1;
            background-color: #f0f0f0;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            position: relative;
            cursor: pointer;
            margin: 0 8px;
        }

        .message-wrapper.sent .pv-card {
            border-bottom-right-radius: 5px;
        }

        .message-wrapper.received .pv-card {
            border-bottom-left-radius: 5px;
        }

        .pv-card-image-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            transition: opacity 0.5s ease-in-out;
            z-index: 2;
        }

        .pv-card-image-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .pv-card-content {
            padding: 15px;
            height: 100%;
            overflow-y: auto;
            color: var(--text-color);
            line-height: 1.6;
            font-size: 15px;
            background-color: white;
            position: relative;
            z-index: 1;
        }

        .pv-card-footer {
            background: linear-gradient(to top, rgba(0, 0, 0, 0.6), transparent);
            color: white;
            padding: 20px 10px 8px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 3;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out;
        }

        .pv-card-footer.hidden {
            opacity: 0;
        }

        .pv-card-footer svg {
            width: 14px;
            height: 14px;
            fill: white;
            flex-shrink: 0;
        }

        .transfer-card {
            width: 240px;
            height: auto;
            border-radius: var(--border-radius);
            margin: 0 8px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            color: white;
        }

        .message-wrapper.sent .transfer-card {
            border-bottom-right-radius: 5px;
        }

        .message-wrapper.received .transfer-card {
            border-bottom-left-radius: 5px;
            cursor: pointer;
        }

        .transfer-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-size: cover;
            background-position: center;
            filter: blur(4px);
            transform: scale(1.1);
            z-index: 1;
        }

        .transfer-card.sent-transfer::before {
            background-image: url('https://i.postimg.cc/sxN893WF/IMG-20250712.png');
        }

        .transfer-card.received-transfer::before {
            background-image: url('https://i.postimg.cc/FzR8LY7g/IMG-20250712-170703.png');
        }

        .transfer-card .overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.3);
            z-index: 2;
            transition: background-color 0.5s ease;
        }

        .transfer-card.received .overlay {
            background-color: rgba(255, 182, 193, 0.4);
        }

        .transfer-card.returned .overlay {
            background-color: rgba(100, 100, 100, 0.5);
        }

        .transfer-content {
            position: relative;
            z-index: 3;
            padding: 20px;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        .transfer-title {
            font-size: 14px;
            margin: 0 0 5px 0;
            opacity: 0.9;
        }

        .transfer-amount {
            font-size: 28px;
            font-weight: bold;
            margin: 0;
        }

        .transfer-remark {
            font-size: 14px;
            margin-top: 10px;
            opacity: 0.9;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .transfer-status {
            font-size: 12px;
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            opacity: 0.8;
        }

        .gift-card {
            width: 230px;
            background-color: #fff;
            border: 2px solid #333;
            border-radius: var(--border-radius);
            box-shadow: 4px 4px 0px #ddd;
            padding: 10px;
            display: flex;
            align-items: center;
            cursor: pointer;
            margin: 0 8px;
            position: relative;
            overflow: hidden;
        }

        .message-wrapper.sent .gift-card {
            border-bottom-right-radius: 5px;
        }

        .message-wrapper.received .gift-card {
            border-bottom-left-radius: 5px;
        }

        .gift-card-icon {
            width: 50px;
            height: 50px;
            margin-right: 15px;
            flex-shrink: 0;
        }

        .gift-card-text {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            font-family: 'Comic Sans MS', 'Chalkduster', 'Handwriting', cursive;
        }

        .gift-card-description {
            font-size: 14px;
            color: #555;
            background-color: rgba(240, 240, 240, 0.9);
            padding: 8px 12px;
            margin-top: 5px;
            margin-left: 54px;
            margin-right: 54px;
            border-radius: 10px;
            line-height: 1.6;
            max-width: calc(100% - 108px);
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .gift-card-description.active {
            display: block;
        }

        .message-wrapper.sent .gift-card-description {
            align-self: flex-end;
            margin-right: 54px;
            margin-left: auto;
        }

        .message-wrapper.received .gift-card-description {
            align-self: flex-start;
            margin-left: 54px;
            margin-right: auto;
        }

        .gift-card-received-stamp {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 14px;
            font-weight: bold;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            padding: 2px 6px;
            transform: rotate(15deg);
            opacity: 0;
            transition: opacity 0.3s ease;
            font-family: 'Comic Sans MS', 'Chalkduster', 'Handwriting', cursive;
        }

        .gift-card.received .gift-card-received-stamp {
            opacity: 1;
        }

        .load-more-btn {
            background-color: #e0e0e0;
            color: #757575;
            border: none;
            padding: 8px 16px;
            margin: 10px auto;
            border-radius: 15px;
            cursor: pointer;
            display: block;
            font-size: 13px;
            font-weight: 500;
        }

        .load-more-btn:hover {
            background-color: #d1d1d1;
        }

        .typing-indicator {
            text-align: center;
            color: #aaa;
            font-style: italic;
            font-size: 14px;
            padding: 10px 0;
            display: none;
        }

        #sticker-bar {
            flex-shrink: 0;
            padding: 0 10px 5px;
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
        }

        .sticker-bar-btn {
            background: none;
            border: none;
            padding: 5px;
            cursor: pointer;
        }

        .sticker-bar-btn svg {
            width: 28px;
            height: 28px;
            fill: #888;
        }

        #sticker-modal {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 35%;
            max-height: 250px;
            background: #f7f7f7;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.1);
            z-index: 25;
            display: none;
            flex-direction: column;
        }

        #sticker-modal.visible {
            display: flex;
            animation: slideUp 0.3s ease-out;
        }

        #sticker-modal .header {
            padding: 10px 15px;
            font-weight: bold;
            color: var(--text-color);
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sticker-grid {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 15px;
        }

        .sticker-item {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }

        .sticker-item img {
            width: 60px;
            height: 60px;
            object-fit: contain;
        }

        .sticker-item span {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
            text-align: center;
        }

        #add-sticker-modal .modal-window {
            max-width: 360px;
        }

        #sticker-preview {
            width: 100px;
            height: 100px;
            border: 2px dashed #ddd;
            border-radius: 10px;
            margin: 0 auto 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #aaa;
            background-color: #f9f9f9;
        }

        #sticker-preview img {
            max-width: 100%;
            max-height: 100%;
        }

        .chat-input-wrapper {
            flex-shrink: 0;
        }

        .message-input-area {
            display: flex;
            align-items: center;
            padding: 10px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            border-top: 1px solid #eee;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            flex-shrink: 0;
            gap: 10px;
            border-bottom-left-radius: var(--phone-corner-radius);
            border-bottom-right-radius: var(--phone-corner-radius);
            overflow: hidden;
        }

        .message-input-area input {
            flex-grow: 1;
            border: none;
            padding: 12px;
            border-radius: 18px;
            background-color: #f0f0f0;
        }

        .message-input-area input:focus {
            outline: none;
        }

        .message-input-area .icon-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .message-input-area .icon-btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .message-input-area .icon-btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .message-input-area .icon-btn.send-btn {
            font-size: 18px;
        }

        #multi-select-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            border-top: 1px solid #eee;
            z-index: 20;
            border-bottom-left-radius: var(--phone-corner-radius);
            border-bottom-right-radius: var(--phone-corner-radius);
            animation: slideUp 0.3s ease-out;
        }

        #multi-select-bar.visible {
            display: flex;
        }

        .settings-sidebar {
            position: absolute;
            top: 0;
            right: -100%;
            width: 80%;
            height: 100%;
            background: #fff;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.1);
            transition: right 0.4s ease-in-out;
            z-index: 101;
            display: flex;
            flex-direction: column;
        }

        .settings-sidebar.open {
            right: 0;
        }

        .settings-sidebar .header {
            padding: 15px;
            border-bottom: 1px solid #eee;
            font-weight: bold;
            text-align: center;
            color: var(--primary-color);
        }

        .settings-sidebar .content {
            padding: 20px;
            overflow-y: auto;
            flex-grow: 1;
        }

        .settings-sidebar .form-group textarea {
            height: 100px;
            resize: vertical;
        }

        .settings-sidebar .avatar-setting {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .settings-sidebar .avatar-preview {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--primary-color);
            cursor: pointer;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: var(--secondary-color);
            font-weight: 600;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #fce4ec;
            border-radius: 10px;
            background-color: #fff;
            transition: border-color 0.3s;
            font-family: var(--font-family);
            font-size: 14px;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .form-group.radio-group {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .form-group.radio-group label {
            margin-bottom: 0;
        }

        .btn {
            width: 100%;
            padding: 15px;
            border-radius: 10px;
            border: none;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-align: center;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: var(--white-color);
        }

        .btn-primary:hover {
            background-color: var(--secondary-color);
            box-shadow: 0 4px 15px rgba(255, 128, 171, 0.5);
        }

        label.btn-primary {
            color: var(--white-color) !important;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 14px;
            width: auto;
        }

        .btn-secondary {
            background-color: var(--accent-color);
            color: var(--white-color);
            margin-bottom: 15px;
        }

        .btn-secondary:hover {
            background-color: #64b5f6;
            box-shadow: 0 4px 15px rgba(144, 202, 249, 0.5);
        }

        .btn-neutral {
            background-color: #bdbdbd;
            color: var(--white-color);
        }

        .btn-neutral:hover {
            background-color: #9e9e9e;
        }

        .btn-danger {
            background-color: #ef5350;
            color: white;
        }

        .btn .spinner {
            display: none;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-top-color: var(--white-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .btn.loading .spinner {
            display: block;
        }

        .btn.loading .btn-text {
            display: none;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .wallpaper-preview {
            width: 100%;
            aspect-ratio: 9 / 16;
            max-height: 400px;
            border-radius: var(--border-radius);
            margin-bottom: 25px;
            background-size: cover;
            background-position: center;
            border: 3px dashed var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--secondary-color);
            font-style: italic;
            background-color: #fff8fa;
        }

        .toast {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 15px;
            font-size: 14px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s, visibility 0.5s;
            z-index: 1000;
        }

        .toast.show {
            opacity: 1;
            visibility: visible;
        }

        #world-book-selection-modal,
        #invite-member-modal,
        #group-recipient-selection-modal {
            z-index: 102;
        }

        #world-book-selection-modal .modal-window,
        #invite-member-modal .modal-window,
        #group-recipient-selection-modal .modal-window {
            width: 90%;
            max-width: 380px;
        }

        #world-book-selection-list,
        #invite-member-selection-list,
        #group-recipient-selection-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 40vh;
            overflow-y: auto;
        }

        .world-book-select-item,
        .invite-member-select-item,
        .group-recipient-select-item {
            display: flex;
            align-items: center;
            padding: 12px 5px;
            border-bottom: 1px solid #f0f0f0;
        }

        .world-book-select-item:last-child,
        .invite-member-select-item:last-child,
        .group-recipient-select-item:last-child {
            border-bottom: none;
        }

        .world-book-select-item input[type="checkbox"],
        .invite-member-select-item input[type="checkbox"],
        .group-recipient-select-item input[type="checkbox"] {
            margin-right: 15px;
            width: 20px;
            height: 20px;
        }

        .world-book-select-item label,
        .invite-member-select-item label,
        .group-recipient-select-item label {
            font-weight: 500;
            color: var(--text-color);
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        .invite-member-select-item img,
        .group-recipient-select-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
        }

        /* --- Group Chat Specific Styles --- */
        .member-selection-list {
            list-style: none;
            padding: 0;
            margin: 15px 0;
            max-height: 40vh;
            overflow-y: auto;
        }

        .member-selection-item {
            display: flex;
            align-items: center;
            padding: 10px 5px;
            border-bottom: 1px solid #f0f0f0;
        }

        .member-selection-item:last-child {
            border-bottom: none;
        }

        .member-selection-item input[type="checkbox"] {
            margin-right: 15px;
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }

        .member-selection-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 10px;
        }

        .member-selection-item label {
            font-weight: 500;
            color: var(--text-color);
        }

        #group-settings-sidebar .group-avatar-setting {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        #group-settings-sidebar .group-avatar-preview {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            object-fit: cover;
            border: 2px solid var(--primary-color);
            cursor: pointer;
        }

        #group-settings-sidebar .group-members-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }

        #group-settings-sidebar .group-member,
        #group-settings-sidebar .add-member-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }

        #group-settings-sidebar .group-member img {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 5px;
            border: 2px solid #eee;
        }

        #group-settings-sidebar .add-member-btn .add-icon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px dashed #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #ccc;
            margin-bottom: 5px;
            transition: all 0.2s ease;
        }

        #group-settings-sidebar .add-member-btn:hover .add-icon {
            color: var(--primary-color);
            border-color: var(--primary-color);
        }

        #group-settings-sidebar .group-member span,
        #group-settings-sidebar .add-member-btn span {
            font-size: 12px;
            text-align: center;
            color: var(--text-color);
        }

        #customize-screen .icon-custom-item {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #f0f0f0;
        }

        #customize-screen .icon-custom-item:last-child {
            border-bottom: none;
        }

        #customize-screen .icon-preview {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            object-fit: cover;
            flex-shrink: 0;
        }

        #customize-screen .icon-details {
            flex-grow: 1;
        }

        #customize-screen .icon-details p {
            margin: 0 0 8px 0;
            font-weight: 600;
        }

        #customize-screen .icon-details input {
            width: calc(100% - 70px);
        }

        #customize-screen .reset-icon-btn {
            background: #e0e0e0;
            color: #555;
            border: none;
            border-radius: 8px;
            padding: 8px 10px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 10px;
        }

        /* --- Tutorial Screen Styles --- */
        .tutorial-item {
            margin-bottom: 15px;
            border: 1px solid #fce4ec;
            border-radius: 12px;
            overflow: hidden;
            background-color: #fff8fa;
        }

        .tutorial-header {
            padding: 12px 18px;
            font-weight: 600;
            color: var(--secondary-color);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tutorial-header::after {
            content: '▼';
            font-size: 12px;
            transition: transform 0.3s ease;
        }

        .tutorial-item.open .tutorial-header::after {
            transform: rotate(180deg);
        }

        .tutorial-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out, padding 0.5s ease;
            padding: 0 10px;
        }

        .tutorial-item.open .tutorial-content {
            padding: 10px 10px;
            /* A large value to ensure it expands to fit the content */
            max-height: 5000px;
        }

        .tutorial-content img {
            width: 100%;
            height: auto;
            border-radius: 8px;
            display: block;
        }
    

/* === 可缩放变量（作用域：仅聊天室屏幕） === */
#chat-room-screen {
  --bubble-scale: 1;
  --bubble-font-base: 15px;
}
#chat-room-screen .message-area {
  font-size: calc(var(--bubble-font-base) * var(--bubble-scale));
}
#chat-room-screen .message-bubble {
  font-size: 1em !important;
  padding: 0.533em 0.8em !important;
  max-width: calc(260px * var(--bubble-scale)) !important;
}
#chat-room-screen .system-notification-bubble {
  font-size: 0.8em !important;
  padding: 0.4em 0.67em !important;
}
#chat-room-screen .voice-bubble {
  font-size: 1em !important;
  padding: 0.533em 0.8em !important;
  min-width: calc(90px * var(--bubble-scale)) !important;
  max-width: calc(200px * var(--bubble-scale)) !important;
}
#chat-room-screen .voice-bubble .duration { font-size: 0.87em !important; }
#chat-room-screen .image-bubble { max-width: calc(120px * var(--bubble-scale)) !important; }
#chat-room-screen .pv-card { width: calc(230px * var(--bubble-scale)) !important; font-size: 1em !important; }
#chat-room-screen .transfer-card { width: calc(240px * var(--bubble-scale)) !important; font-size: 1em !important; }
#chat-room-screen .gift-card { width: calc(230px * var(--bubble-scale)) !important; font-size: 1em !important; }
#chat-room-screen .gift-card-description,
#chat-room-screen .voice-transcript {
  font-size: 0.93em !important;
  line-height: 1.6;
}
#chat-room-screen .message-bubble,
#chat-room-screen .voice-bubble,
#chat-room-screen .pv-card,
#chat-room-screen .transfer-card,
#chat-room-screen .gift-card {
  border-radius: calc(var(--border-radius) * var(--bubble-scale)) !important;
}

/* DEBUG FIXES: ensure active screen uses flex and phone-screen is positioned */
.phone-screen { position: relative !important; }
.screen { display: none !important; }
.screen.active { display: flex !important; }
.modal-overlay { position: absolute !important; }


/* --- moment image description card (injected) --- */
.moment-image-desc-card {
  background: linear-gradient(135deg, rgba(238, 156, 167, 0.3), rgba(255, 221, 225, 0.3)); /* 半透明粉色渐变背景 */
  border-radius: 10px;
  padding: 12px 14px;
  margin-top: 6px;
  color: #fff;
  position: relative;
  overflow: hidden;
  box-shadow: 0 6px 18px rgba(0,0,0,0.06);
  /* min-height: 86px; */
  display: flex;
  align-items: center;
  cursor: pointer;
  backdrop-filter: blur(10px); /* 关键：毛玻璃模糊效果 */
  -webkit-backdrop-filter: blur(10px); /* 兼容 Safari */
  border: 1px solid rgba(255, 255, 255, 0.3); /* 增加玻璃质感边框 */
}


/* === 覆盖：仅改变卡片外框与配色（保留原文件卡片形状/布局/标题） === */
.moment-image-desc-card {
  /* 不改 width/height/border-radius/padding 等布局属性，保障原样式形状不变 */
  border: 6px solid #ffffff;
  box-shadow: 0 6px 20px rgba(10, 10, 20, 0.06);
  background: transparent !important;
}

/* 内层浅灰面板（只在存在内层类时覆盖背景色） */
.moment-image-desc-card .inner {
  background: #eef0f3 !important;
}

/* 将参考图中“标题色”应用到图片描述文字上：#66676b */
.moment-image-desc-card .desc-content,
  .moment-image-desc-card .description,
  .moment-image-desc-card .image-desc {
  color: #66676b !important;
}

/* 小屏微调（不改变布局） */
@media (max-width: 420px) {
  .moment-image-desc-card { box-shadow: 0 4px 14px rgba(10,10,20,0.05); }
}

/*
.moment-image-desc-card::before {
  content: '';
  position: absolute;
  inset: -12px;
  background: inherit;
  filter: blur(10px);
  transform: scale(1.08);
  z-index: 1;
  opacity: 0.95;
}
*/
.moment-image-desc-card .desc-content {
  position: relative;
  z-index: 2;
  font-style: italic;
  text-shadow: 0 1px 3px rgba(0,0,0,0.45);
  line-height: 1.4;
  font-size: 13px;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  /* -webkit-line-clamp: 4; */
  overflow: hidden;
  word-break: break-word;
  /* max-height: calc(1.4em * 4); */
}
@media (max-width: 420px) {
  .moment-image-desc-card { padding: 9px; /* min-height: 72px; */ }
  .moment-image-desc-card .desc-content { /* -webkit-line-clamp: 3; */ }
}

</style>

<!-- === moments 固定在 phone-screen 内的修复样式 (自动插入补丁) === -->
<style>
/* 确保 phone-screen 做为裁切容器 */
.phone-screen {
  position: relative !important;
  overflow: hidden !important; /* 防止子元素跑出可视区 */
}

/* 把所有 screen 统一做绝对铺满，这样切换只影响可见性，不会改变布局流 */
.screen {
  position: absolute !important;
  inset: 0; /* top:0; right:0; bottom:0; left:0; */
  display: none !important;
  flex-direction: column;
  -webkit-overflow-scrolling: touch;
}

/* 激活的 screen 可见 */
.screen.active {
  display: flex !important;
}

/* 确保 screen 中的主内容区单独可滚动（不会把整个 screen 推出） */
.screen .content {
  overflow-y: auto !important;
  height: 100%;
  box-sizing: border-box;
}

/* 为动态页面的底部导航栏预留空间 */
#moments-screen .content {
    padding-bottom: 88px !important;
}

/* 防止 moments 页面被某些 transform/translate 推出视窗（保底） */
#moments-screen {
  transform: none !important;
  will-change: auto !important;
}
</style>
<!-- === /patch === -->

<style>
/* z-index and stacking safety to ensure bottom nav and modals stay on top */
.screen { z-index: 0 !important; }
.screen.active { z-index: 1 !important; }
.bottom-nav { z-index: 200 !important; } /* ensure bottom nav overlays feed */
.modal-overlay, .action-sheet-overlay, .context-menu { z-index: 300 !important; }
#moments-screen { z-index: 0 !important; } /* keep moments below nav/modals by default */
</style>
<!-- === /zindex-patch === -->

</head>
<body>
<div class="phone-screen">
<div class="screen active" id="home-screen"></div>
<div class="screen" id="chat-list-screen">
<header class="app-header">
<button class="back-btn" data-target="home-screen">‹</button>
<div class="title-container">
<h1 class="title">聊天</h1>
</div>
<div class="action-btn-group">
<button class="action-btn" id="create-group-btn">群聊</button>
<button class="action-btn" id="add-chat-btn">+</button>
</div>
</header>
<main class="content">
<ul class="list-container" id="chat-list-container"></ul>
<div class="placeholder-text" id="no-chats-placeholder" style="display: none;">
<p>还没有聊天对象哦~</p>
<p>点击右上角的“+”创建一个吧！</p>
</div>
</main>
</div>
<div class="screen" id="chat-room-screen">
<header class="app-header" id="chat-room-header-default">
<button class="back-btn" data-target="chat-list-screen">‹</button>
<div class="title-container">
<h1 class="title" id="chat-room-title">...</h1>
<div class="subtitle" id="chat-room-subtitle">
<div class="online-indicator"></div>
<span id="chat-room-status-text">在线</span>
</div>
</div>
<button class="action-btn" id="chat-settings-btn"><img alt="设置" src="https://i.postimg.cc/nhwP4pQy/chan-73.png"/></button>
</header>
<header class="app-header" id="chat-room-header-select" style="display: none;">
<button class="action-btn" id="cancel-multi-select-btn">取消</button>
<div class="title-container">
<h1 class="title" id="multi-select-title">选择消息</h1>
</div>
<div class="placeholder"></div>
</header>
<main class="content">
<div class="message-area" id="message-area"></div>
<div class="typing-indicator" id="typing-indicator"></div>
</main>
<div class="chat-input-wrapper">
<div id="sticker-bar">
<button class="sticker-bar-btn" id="sticker-toggle-btn">
<svg viewbox="0 0 24 24">
<path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z"></path>
</svg>
</button>
<button class="sticker-bar-btn" id="photo-video-btn">
<svg viewbox="0 0 24 24">
<path d="M4,4H7L9,2H15L17,4H20A2,2 0 0,1 22,6V18A2,2 0 0,1 20,20H4A2,2 0 0,1 2,18V6A2,2 0 0,1 4,4M12,7A5,5 0 0,0 7,12A5,5 0 0,0 12,17A5,5 0 0,0 17,12A5,5 0 0,0 12,7M12,9A3,3 0 0,1 15,12A3,3 0 0,1 12,15A3,3 0 0,1 9,12A3,3 0 0,1 12,9Z"></path>
</svg>
</button>
<button class="sticker-bar-btn" id="image-recognition-btn">
<svg viewbox="0 0 24 24">
<path d="M21.58,16.09L19.66,18L18.24,16.58L21,13.83C21.39,13.44 22,13.44 22.39,13.83L23.17,14.61C23.56,15 23.56,15.64 23.17,16.03L21.58,17.62M20.13,12.25L18.71,13.66L20.41,15.36L21.83,13.94L20.13,12.25M5.93,19H5C3.9,19 3,18.1 3,17V5C3,3.9 3.9,3 5,3H19C20.1,3 21,3.9 21,5V11.08L19,13.08V5H5V17H5.93L13.5,9.43L16.29,12.21L12.08,16.42L5.93,19Z"></path>
</svg>
</button>
<button class="sticker-bar-btn" id="voice-message-btn">
<svg viewbox="0 0 24 24">
<path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"></path>
</svg>
</button>
<button class="sticker-bar-btn" id="wallet-btn">
<svg viewbox="0 0 24 24">
<path d="M20 4H4C2.9 4 2 4.9 2 6V18C2 19.1 2.9 20 4 20H20C21.1 20 22 19.1 22 18V6C22 4.9 21.1 4 20 4ZM20 18H4V8H20V18ZM4 6H20V6H4Z"></path>
</svg>
</button>
<button class="sticker-bar-btn" id="gift-btn">
<svg viewbox="0 0 24 24">
<path d="M20,8L12,13L4,8V6H20M20,4H4A2,2 0 0,0 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6A2,2 0 0,0 20,4M12.5,18C12.5,17.29 12.17,16.65 11.64,16.27C12.17,15.89 12.5,15.26 12.5,14.55C12.5,13.6 11.83,12.79 11,12.58V12H13V10H11V8H13V6H11V5C11,4.45 10.55,4 10,4H8C7.45,4 7,4.45 7,5V6H9V8H7V10H9V12H7V12.58C6.17,12.79 5.5,13.6 5.5,14.55C5.5,15.26 5.83,15.89 6.36,16.27C5.83,16.65 5.5,17.29 5.5,18H12.5Z"></path>
</svg>
</button>
<!-- NEW: Time Skip Button -->
<button class="sticker-bar-btn" id="time-skip-btn">
<svg viewbox="0 0 24 24">
<path d="M4 5v14l7-7-7-7zm9 0v14l7-7-7-7z"></path>
</svg>
</button>
</div>
<div class="message-input-area" id="message-input-default">
<input id="message-input" placeholder="输入消息..." type="text"/>
<button class="icon-btn send-btn" id="send-message-btn">➤</button>
<button class="icon-btn" id="get-reply-btn">
<svg viewbox="0 0 24 24">
<path d="M12,2A10,10 0 1,0 22,12A10,10 0 0,0 12,2M12,20A8,8 0 1,1 20,12A8,8 0 0,1 12,20M16.24,7.76C15.07,6.58 13.53,6 12,6V12L7.76,16.24C10.1,18.58 13.9,18.58 16.24,16.24C18.58,13.9 18.58,10.1 16.24,7.76Z"></path>
</svg>
</button>
</div>
<div class="message-input-area" id="message-edit-bar" style="display: none;">
<input id="message-edit-input" type="text"/>
<button class="icon-btn send-btn" id="save-edit-btn">✓</button>
<button class="icon-btn" id="cancel-edit-btn" style="background-color: #aaa;">✗</button>
</div>
</div>
<div id="multi-select-bar"><span id="select-count">已选择 0 项</span>
<button class="btn btn-danger" id="delete-selected-btn" style="width: auto; padding: 8px 16px;">删除已选
            </button>
</div>
<div id="sticker-modal">
<div class="header"><span>我的表情</span>
<button class="btn btn-primary btn-small" id="add-new-sticker-btn">添加新表情</button>
</div>
<div class="sticker-grid" id="sticker-grid-container"></div>
</div>
</div>
<div class="screen" id="world-book-screen">
<header class="app-header">
<button class="back-btn" data-target="home-screen">‹</button>
<div class="title-container">
<h1 class="title">世界书</h1>
</div>
<button class="action-btn" id="add-world-book-btn">+</button>
</header>
<main class="content">
<ul class="list-container" id="world-book-list-container"></ul>
<div class="placeholder-text" id="no-world-books-placeholder" style="display: none;">
<p>你的世界一片混沌...</p>
<p>点击右上角的“+”创造第一个设定吧！</p>
</div>
</main>
</div>
<div class="screen" id="edit-world-book-screen">
<header class="app-header">
<button class="back-btn" data-target="world-book-screen">‹</button>
<div class="title-container">
<h1 class="title" id="edit-world-book-title">创建/编辑条目</h1>
</div>
<div class="placeholder"></div>
</header>
<main class="content">
<form id="edit-world-book-form">
<input id="world-book-id" type="hidden"/>
<div class="form-group">
<label for="world-book-name">条目名称</label>
<input id="world-book-name" placeholder="例如：世界观背景、魔法体系" required="" type="text"/>
</div>
<div class="form-group">
<label for="world-book-content">条目内容</label>
<textarea id="world-book-content" placeholder="详细描述此项设定..." required="" rows="8"></textarea>
</div>
<div class="form-group">
<label>注入位置</label>
<div class="form-group radio-group">
<label><input checked="" name="world-book-position" type="radio" value="before"/> 前</label>
<label><input name="world-book-position" type="radio" value="after"/> 后</label>
</div>
</div>
<button class="btn btn-primary" type="submit">保存条目</button>
</form>
</main>
</div>
<div class="screen" id="api-settings-screen"></div>
<div class="screen" id="wallpaper-screen"></div>
<div class="screen" id="font-settings-screen"></div>
<div class="screen" id="customize-screen"></div>
<div class="screen" id="tutorial-screen"></div>
<div class="toast" id="toast-notification"></div>
<input accept="image/*" id="image-upload-input" style="display:none;" type="file"/>
<div class="modal-overlay" id="add-char-modal">
<div class="modal-window">
<h3>创建新角色</h3>
<form id="add-char-form">
<div class="form-group">
<label for="char-real-name">角色姓名</label><input id="char-real-name" placeholder="角色的真实姓名" required="" type="text"/>
</div>
<div class="form-group">
<label for="char-remark-name">角色备注 (昵称)</label><input id="char-remark-name" placeholder="你对Ta的称呼" required="" type="text"/>
</div>
<div class="form-group">
<label for="my-name-for-char">我的姓名</label><input id="my-name-for-char" placeholder="你希望Ta如何称呼你" required="" type="text"/>
</div>
<button class="btn btn-primary" type="submit">创建</button>
</form>
</div>
</div>
<div class="modal-overlay" id="add-sticker-modal">
<div class="modal-window">
<h3 id="add-sticker-modal-title">添加新表情</h3>
<form id="add-sticker-form"><input id="sticker-edit-id" type="hidden"/>
<div id="sticker-preview"><span>预览</span></div>
<div class="form-group"><label for="sticker-name">表情名称</label><input id="sticker-name" placeholder="如：开心" required="" type="text"/>
</div>
<div class="form-group"><label for="sticker-url-input">表情URL</label><input id="sticker-url-input" placeholder="粘贴图片URL" type="url"/>
</div>
<p style="text-align:center; color:#888; margin: -10px 0 15px;">或</p><input accept="image/*" id="sticker-file-upload" style="display:none;" type="file"/><label class="btn btn-secondary" for="sticker-file-upload" style="width:100%; margin-bottom: 20px;">从本地上传</label>
<button class="btn btn-primary" type="submit">保存</button>
</form>
</div>
</div>
<div class="action-sheet-overlay" id="sticker-actionsheet">
<div class="action-sheet">
<button class="action-sheet-button" id="edit-sticker-btn">编辑</button>
<button class="action-sheet-button danger" id="delete-sticker-btn">删除</button>
</div>
</div>
<div class="modal-overlay" id="send-voice-modal">
<div class="modal-window">
<h3>发送语音消息</h3>
<form id="send-voice-form">
<div class="form-group">
<label for="voice-text-input">输入语音文字</label>
<textarea id="voice-text-input" placeholder="在这里输入你想说的话..." required="" rows="4"></textarea>
</div>
<div class="form-group" style="text-align:center; color:#888; font-size: 14px;">
                    预计时长: <span id="voice-duration-preview">0"</span>
</div>
<button class="btn btn-primary" type="submit">发送</button>
</form>
</div>
</div>
<div class="modal-overlay" id="send-pv-modal">
<div class="modal-window">
<h3>分享照片/视频</h3>
<form id="send-pv-form">
<div class="form-group">
<label for="pv-text-input">输入描述</label>
<textarea id="pv-text-input" placeholder="在这里描述你的照片或视频内容..." required="" rows="4"></textarea>
</div>
<button class="btn btn-primary" type="submit">发送</button>
</form>
</div>
</div>
<div class="modal-overlay" id="send-transfer-modal">
<div class="modal-window">
<h3>转账</h3>
<form id="send-transfer-form">
<div class="form-group">
<label for="transfer-amount-input">金额 (元)</label>
<input id="transfer-amount-input" min="0.01" placeholder="0.00" required="" step="0.01" type="number"/>
</div>
<div class="form-group">
<label for="transfer-remark-input">备注</label>
<input id="transfer-remark-input" placeholder="（选填）" type="text"/>
</div>
<button class="btn btn-primary" type="submit">发送</button>
</form>
</div>
</div>
<div class="modal-overlay" id="send-gift-modal">
<div class="modal-window">
<h3>送出礼物</h3>
<form id="send-gift-form">
<div class="form-group">
<label for="gift-description-input">礼物描述</label>
<textarea id="gift-description-input" placeholder="告诉Ta你送了什么特别的东西..." required="" rows="4"></textarea>
</div>
<button class="btn btn-primary" type="submit">发送</button>
</form>
</div>
</div>
<!-- NEW: Time Skip Modal -->
<div class="modal-overlay" id="time-skip-modal">
<div class="modal-window">
<h3>记录今天发生的事</h3>
<form id="time-skip-form">
<div class="form-group">
<label for="time-skip-input">事件描述 (该消息AI可见，会作为上下文)</label>
<textarea id="time-skip-input" placeholder="例如：我们一起去山顶看了日落，然后吃了烧烤。" required="" rows="4"></textarea>
</div>
<button class="btn btn-primary" type="submit">发送</button>
</form>
</div>
</div>
<!-- NEW: Group Recipient Selection Modal -->
<div class="modal-overlay" id="group-recipient-selection-modal">
<div class="modal-window">
<h3 id="group-recipient-selection-title">选择收件人</h3>
<ul id="group-recipient-selection-list"></ul>
<button class="btn btn-primary" id="confirm-group-recipient-btn" style="margin-top: 20px;">确认</button>
</div>
</div>
<div class="action-sheet-overlay" id="receive-transfer-actionsheet">
<div class="action-sheet">
<button class="action-sheet-button" id="accept-transfer-btn">接收</button>
<button class="action-sheet-button danger" id="return-transfer-btn">退回</button>
</div>
</div>
<!-- Private Chat Settings -->
<div class="settings-sidebar" id="chat-settings-sidebar">
<div class="header">聊天设置</div>
<div class="content">
<form id="chat-settings-form">
<div class="avatar-setting"><img alt="角色头像" class="avatar-preview" id="setting-char-avatar-preview" src=""/><input accept="image/*" id="setting-char-avatar-upload" style="display:none;" type="file"/><label class="btn btn-primary" for="setting-char-avatar-upload" style="flex-grow:1;">更换角色头像</label></div>
<div class="form-group"><label for="setting-char-remark">角色备注 (昵称)</label><input id="setting-char-remark" type="text"/>
</div>
<div class="form-group"><label for="setting-char-persona">角色人设</label><textarea id="setting-char-persona" placeholder="详细描述角色的性格、背景、说话风格等。"></textarea></div>
<hr style="border:none; border-top:1px solid #eee; margin: 20px 0;"/>
<div class="avatar-setting"><img alt="我的头像" class="avatar-preview" id="setting-my-avatar-preview" src=""/><input accept="image/*" id="setting-my-avatar-upload" style="display:none;" type="file"/><label class="btn btn-secondary" for="setting-my-avatar-upload" style="flex-grow:1;">更换我的头像</label></div>
<div class="form-group"><label for="setting-my-name">我的姓名</label><input id="setting-my-name" type="text"/></div>
<div class="form-group"><label for="setting-my-persona">我的人设</label><textarea id="setting-my-persona" placeholder="描述你希望在对话中扮演的形象。"></textarea>
<!-- === ChatGPT 插入：我的人设预设控制（外观参考气泡预设） === -->
<div class="panel panel-sm" style="padding:12px;border-radius:10px;border:1px solid var(--border-color,#e8e8ef);background:var(--panel-bg,#fff);box-shadow:var(--panel-shadow,0 4px 12px rgba(20,20,30,0.04));margin:10px 0;">
<div style="display:flex;align-items:center;gap:10px;margin-bottom:10px;">
<label for="mypersona-preset-select" style="width:88px;color:var(--muted,#667);font-size:13px;">我的人设预设</label>
<select id="mypersona-preset-select" style="flex:1;padding:8px 10px;border-radius:8px;border:1px solid var(--input-border,#e6e6ea);background:var(--input-bg,#fff);font-size:14px;">
<option value="">— 选择预设 —</option>
</select>
<button class="btn btn-primary" id="mypersona-apply-btn" style="margin-left:8px;padding:7px 10px;border-radius:8px;" type="button">应用</button>
</div>
<div style="display:flex;gap:8px;align-items:center;margin-bottom:6px;">
<label style="width:88px;color:var(--muted,#667);font-size:13px;">外观操作</label>
<button class="btn" id="mypersona-save-btn" style="padding:7px 10px;border-radius:8px;" type="button">另存为预设</button>
<button class="btn" id="mypersona-manage-btn" style="padding:7px 10px;border-radius:8px;" type="button">管理</button>
</div>
</div>
<!-- 管理 Modal（样式与气泡预设管理一致） -->
<div class="modal-overlay" id="mypersona-presets-modal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.35);justify-content:center;align-items:center;z-index:9999;">
<div class="modal-window" style="max-width:520px;background:var(--panel-bg,#fff);padding:14px;border-radius:10px;box-shadow:0 12px 36px rgba(10,10,20,0.12);">
<h3 style="margin:0 0 10px 0;font-size:16px;">管理我的人设预设</h3>
<div id="mypersona-presets-list" style="max-height:340px; overflow:auto; margin-bottom:12px;"></div>
<div style="display:flex;gap:8px;justify-content:flex-end;">
<button class="btn btn-primary" id="mypersona-close-modal" style="padding:8px 12px;border-radius:8px;" type="button">关闭</button>
</div>
</div>
</div>
<!-- === /我的人设预设控制 === -->
</div>
<hr style="border:none; border-top:1px solid #eee; margin: 20px 0;"/>
<div class="form-group">
<button class="btn btn-secondary" id="link-world-book-btn" type="button">关联世界书</button>
</div>
<div class="form-group"><label for="setting-theme-color">主题颜色 (对方/我方)</label><select id="setting-theme-color"></select></div>
<hr style="border:none; border-top:1px solid #eee; margin: 20px 0;"/>
<div class="form-group">
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
<label for="setting-use-custom-css" style="margin-bottom:0;">自定义气泡样式</label>
<input id="setting-use-custom-css" style="width: auto;" type="checkbox"/>
</div>
<div class="bubble-css-preview" id="private-bubble-css-preview" style="background: #fff; border: 1px solid #eee; border-radius: 10px; padding: 15px; margin-bottom: 10px; display: flex; flex-direction: column; gap: 10px;">
</div>
<textarea disabled="" id="setting-custom-bubble-css" placeholder="在此输入CSS代码...
例如：
.message-bubble.sent { background-color: #A5D6A7; }
.message-bubble.received { background-color: #E1E1E1; }" rows="6"></textarea>
<!-- === 气泡预设控制（由 ChatGPT 插入） === -->
<!-- 插入位置：自定义气泡样式 textarea 之后（已美化外观） -->
<div class="panel panel-sm" style="padding:12px;border-radius:10px;border:1px solid var(--border-color,#e8e8ef);background:var(--panel-bg,#fff);box-shadow:var(--panel-shadow,0 4px 12px rgba(20,20,30,0.04));margin:10px 0;">
<div style="display:flex;align-items:center;gap:10px;margin-bottom:10px;">
<label for="bubble-preset-select" style="width:88px;color:var(--muted,#667);font-size:13px;">气泡预设</label>
<select id="bubble-preset-select" style="flex:1;padding:8px 10px;border-radius:8px;border:1px solid var(--input-border,#e6e6ea);background:var(--input-bg,#fff);font-size:14px;">
<option value="">— 选择预设 —</option>
</select>
<button class="btn btn-primary" id="apply-preset-btn" style="margin-left:8px;padding:7px 10px;border-radius:8px;" type="button">应用</button>
</div>
<div style="display:flex;gap:8px;align-items:center;margin-bottom:10px;">
<label style="width:88px;color:var(--muted,#667);font-size:13px;">外观操作</label>
<button class="btn" id="save-preset-btn" style="padding:7px 10px;border-radius:8px;" type="button">另存为预设</button>
<button class="btn" id="manage-presets-btn" style="padding:7px 10px;border-radius:8px;" type="button">管理</button>
</div>
</div>
<!-- 管理预设 modal（样式微调） -->
<div class="modal-overlay" id="bubble-presets-modal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.35);justify-content:center;align-items:center;z-index:9999;">
<div class="modal-window" style="max-width:520px;background:var(--panel-bg,#fff);padding:14px;border-radius:10px;box-shadow:0 12px 36px rgba(10,10,20,0.12);">
<h3 style="margin:0 0 10px 0;font-size:16px;">管理气泡预设</h3>
<div id="bubble-presets-list" style="max-height:340px; overflow:auto; margin-bottom:12px;"></div>
<div style="display:flex;gap:8px;justify-content:flex-end;">
<button class="btn btn-primary" id="close-presets-modal" style="padding:8px 12px;border-radius:8px;" type="button">关闭</button>
</div>
</div>
</div>
<!-- === /气泡预设控制（由 ChatGPT 插入） === -->
<button class="btn btn-neutral" id="reset-custom-bubble-css-btn" style="margin-top: 10px; width: auto; padding: 5px 15px; font-size: 14px;" type="button">恢复默认
                    </button>
</div>
<div class="form-group"><label for="setting-max-memory">最大记忆轮数</label><input id="setting-max-memory" min="1" type="number" value="10"/>
</div>
<div class="form-group"><label class="btn btn-primary" for="setting-chat-bg-upload">更换聊天背景</label><input accept="image/*" id="setting-chat-bg-upload" style="display:none;" type="file"/></div>
<button class="btn btn-primary" type="submit">保存设置</button>

<div class="form-group">
<label for="bubble-scale-range">气泡 + 字体大小</label>
<div style="display:flex;align-items:center;gap:10px;">
<input id="bubble-scale-range" max="1.6" min="0.8" step="0.05" style="flex:1;" type="range" value="1"/>
<span id="bubble-scale-value" style="width:56px;text-align:right;">100%</span>
</div>
<div style="margin-top:8px; color:#888; font-size:12px;">
    提示：该滑块仅影响聊天区气泡及其文字，不改变输入栏/标题栏大小。
  </div>
</div>
</form>
<hr style="border:none; border-top:1px solid #eee; margin: 20px 0;"/>
<button class="btn btn-danger" id="clear-chat-history-btn" type="button">清空聊天记录</button>
</div>
</div>
<div class="modal-overlay" id="world-book-selection-modal">
<div class="modal-window">
<h3>选择要关联的世界书</h3>
<ul id="world-book-selection-list"></ul>
<button class="btn btn-primary" id="save-world-book-selection-btn" style="margin-top: 20px;">确认</button>
</div>
</div>
<!-- Group Chat Creation Modal -->
<div class="modal-overlay" id="create-group-modal">
<div class="modal-window">
<h3>创建群聊</h3>
<form id="create-group-form">
<div class="form-group">
<label>选择群成员</label>
<ul class="member-selection-list" id="member-selection-list"></ul>
</div>
<div class="form-group">
<label for="group-name-input">群聊名称</label>
<input id="group-name-input" placeholder="给你的群聊起个名字吧" required="" type="text"/>
</div>
<button class="btn btn-primary" type="submit">创建群聊</button>
</form>
</div>
</div>
<!-- Group Chat Settings -->
<div class="settings-sidebar" id="group-settings-sidebar">
<div class="header">群聊设置</div>
<div class="content">
<form id="group-settings-form">
<div class="group-avatar-setting">
<img alt="群头像" class="group-avatar-preview" id="setting-group-avatar-preview" src=""/>
<input accept="image/*" id="setting-group-avatar-upload" style="display:none;" type="file"/>
<label class="btn btn-primary" for="setting-group-avatar-upload" style="flex-grow:1;">更换群头像</label>
</div>
<div class="form-group">
<label for="setting-group-name">群名 (AI也可见)</label>
<input id="setting-group-name" type="text"/>
</div>
<hr style="border:none; border-top:1px solid #eee; margin: 20px 0;"/>
<div class="avatar-setting">
<img alt="我的头像" class="avatar-preview" id="setting-group-my-avatar-preview" src=""/>
<input accept="image/*" id="setting-group-my-avatar-upload" style="display:none;" type="file"/>
<label class="btn btn-secondary" for="setting-group-my-avatar-upload" style="flex-grow:1;">更换我的头像</label>
</div>
<div class="form-group">
<label for="setting-group-my-nickname">我的群昵称</label>
<input id="setting-group-my-nickname" type="text"/>
</div>
<div class="form-group">
<label for="setting-group-my-persona">我的人设</label>
<textarea id="setting-group-my-persona" placeholder="描述你希望在此群聊中扮演的形象。"></textarea>
</div>
<hr style="border:none; border-top:1px solid #eee; margin: 20px 0;"/>
<div class="form-group">
<label>群成员</label>
<div class="group-members-list" id="group-members-list-container"></div>
</div>
<hr style="border:none; border-top:1px solid #eee; margin: 20px 0;"/>
<div class="form-group">
<button class="btn btn-secondary" id="link-group-world-book-btn" type="button">关联世界书</button>
</div>
<div class="form-group"><label for="setting-group-theme-color">主题颜色 (对方/我方)</label><select id="setting-group-theme-color"></select></div>
<hr style="border:none; border-top:1px solid #eee; margin: 20px 0;"/>
<div class="form-group">
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
<label for="setting-group-use-custom-css" style="margin-bottom:0;">自定义气泡样式</label>
<input id="setting-group-use-custom-css" style="width: auto;" type="checkbox"/>
</div>
<div class="bubble-css-preview" id="group-bubble-css-preview" style="background: #fff; border: 1px solid #eee; border-radius: 10px; padding: 15px; margin-bottom: 10px; display: flex; flex-direction: column; gap: 10px;">
</div>
<textarea disabled="" id="setting-group-custom-bubble-css" placeholder="在此输入CSS代码...
例如：
.message-bubble.sent { background-color: #A5D6A7; }
.message-bubble.received { background-color: #E1E1E1; }" rows="6"></textarea>
<button class="btn btn-neutral" id="reset-group-custom-bubble-css-btn" style="margin-top: 10px; width: auto; padding: 5px 15px; font-size: 14px;" type="button">恢复默认
                    </button>
</div>
<div class="form-group"><label for="setting-group-max-memory">最大记忆轮数</label><input id="setting-group-max-memory" min="1" type="number" value="10"/></div>
<div class="form-group"><label class="btn btn-primary" for="setting-group-chat-bg-upload">更换聊天背景</label><input accept="image/*" id="setting-group-chat-bg-upload" style="display:none;" type="file"/>
</div>
<button class="btn btn-primary" type="submit">保存设置</button>
</form>
<hr style="border:none; border-top:1px solid #eee; margin: 20px 0;"/>
<button class="btn btn-danger" id="clear-group-chat-history-btn" type="button">清空聊天记录</button>
</div>
</div>
<!-- Group Member Edit Modal -->
<div class="modal-overlay" id="edit-group-member-modal">
<div class="modal-window">
<h3 id="edit-group-member-title">编辑群成员</h3>
<form id="edit-group-member-form">
<input id="editing-member-id" type="hidden"/>
<div class="avatar-setting" style="justify-content: center;">
<img alt="成员头像" class="avatar-preview" id="edit-member-avatar-preview" src="" style="cursor: pointer;"/>
<input accept="image/*" id="edit-member-avatar-upload" style="display:none;" type="file"/>
</div>
<div class="form-group">
<label for="edit-member-group-nickname">群昵称</label>
<input id="edit-member-group-nickname" required="" type="text"/>
</div>
<div class="form-group">
<label for="edit-member-real-name">真名</label>
<input id="edit-member-real-name" required="" type="text"/>
</div>
<div class="form-group">
<label for="edit-member-persona">人设</label>
<textarea id="edit-member-persona" placeholder="详细描述角色的性格、背景等。"></textarea>
</div>
<button class="btn btn-primary" type="submit">保存</button>
</form>
</div>
</div>
<!-- Add Member to Group Action Sheet -->
<div class="action-sheet-overlay" id="add-member-actionsheet">
<div class="action-sheet">
<button class="action-sheet-button" id="invite-existing-member-btn">邀请现有角色</button>
<button class="action-sheet-button" id="create-new-member-btn">创建新角色入群</button>
</div>
</div>
<!-- Invite Existing Member Modal -->
<div class="modal-overlay" id="invite-member-modal">
<div class="modal-window">
<h3>邀请成员加入群聊</h3>
<ul id="invite-member-selection-list"></ul>
<button class="btn btn-primary" id="confirm-invite-btn" style="margin-top: 20px;">确认邀请</button>
</div>
</div>
<!-- Create New Member for Group Modal -->
<div class="modal-overlay" id="create-member-for-group-modal">
<div class="modal-window">
<h3>创建新角色并加入群聊</h3>
<form id="create-member-for-group-form">
<div class="avatar-setting" style="justify-content: center;">
<img alt="新成员头像" class="avatar-preview" id="create-group-member-avatar-preview" src="https://i.postimg.cc/Y96LPskq/o-o-2.jpg" style="cursor: pointer;"/>
<input accept="image/*" id="create-group-member-avatar-upload" style="display:none;" type="file"/>
</div>
<div class="form-group">
<label for="create-group-member-nickname">群昵称</label>
<input id="create-group-member-nickname" required="" type="text"/>
</div>
<div class="form-group">
<label for="create-group-member-realname">真名</label>
<input id="create-group-member-realname" required="" type="text"/>
</div>
<div class="form-group">
<label for="create-group-member-persona">人设</label>
<textarea id="create-group-member-persona" placeholder="详细描述角色的性格、背景等。"></textarea>
</div>
<button class="btn btn-primary" type="submit">创建并加入</button>
</form>
</div>
</div>
</div>
<input accept=".ee" id="import-data-input" style="display: none;" type="file"/>
<script>
    const URLBlacklist = []

    // gemini如果是多个密钥, 那么随机获取一个
    function getRandomValue(str) {
        // 检查字符串是否包含逗号
        if (str.includes(',')) {
            // 用逗号分隔字符串并移除多余空格
            const arr = str.split(',').map(item => item.trim());
            // 生成随机索引 (0 到 arr.length-1)
            const randomIndex = Math.floor(Math.random() * arr.length);
            // 返回随机元素
            return arr[randomIndex];
        }
        // 没有逗号则直接返回原字符串
        return str;
    }

    async function compressImage(file, options = {}) {
        const {
            quality = 0.8, maxWidth = 800, maxHeight = 800
        } = options;

        // --- 新增：处理GIF动图 ---
        // 如果文件是GIF，则不经过canvas压缩，直接返回原始文件数据以保留动画
        if (file.type === 'image/gif') {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            });
        }

        // --- 对其他静态图片（如PNG, JPG）进行压缩 ---
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onerror = reject;
            reader.onload = (event) => {
                const img = new Image();
                img.src = event.target.result;
                img.onerror = reject;
                img.onload = () => {
                    let width = img.width;
                    let height = img.height;

                    if (width > height) {
                        if (width > maxWidth) {
                            height = Math.round(height * (maxWidth / width));
                            width = maxWidth;
                        }
                    } else {
                        if (height > maxHeight) {
                            width = Math.round(width * (maxHeight / height));
                            height = maxHeight;
                        }
                    }

                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');

                    // 对于有透明背景的PNG图片，先填充一个白色背景
                    // 这样可以防止透明区域在转换成JPEG时变黑
                    if (file.type === 'image/png') {
                        ctx.fillStyle = '#FFFFFF'; // 白色背景
                        ctx.fillRect(0, 0, width, height);
                    }

                    ctx.drawImage(img, 0, 0, width, height);

                    // --- 关键修正：将输出格式改为 'image/jpeg' ---
                    // JPEG格式可以显著减小文件大小，避免浏览器处理超大Base64字符串时崩溃
                    const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                    resolve(compressedDataUrl);
                };
            };
        });
    }
    document.addEventListener('DOMContentLoaded', () => {
        // --- Initial HTML Injection ---
        document.getElementById('api-settings-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">API 设置</h1></div><div class="placeholder"></div></header><main class="content"><form id="api-form"><div class="form-group"><label for="api-provider">API 服务商</label><select id="api-provider" name="provider"><option value="newapi">NewAPI (自定义)</option><option value="deepseek">DeepSeek</option><option value="claude">Claude</option><option value="gemini">Gemini</option></select>
<!-- === ChatGPT: 嵌入 API 预设管理（已嵌入到 API 设置区域） === -->
<div class="api-presets-embedded" style="margin-top:12px;">
<!-- === ChatGPT 插入：API 预设管理（样式模拟现有 UI） === -->
<div id="api-presets-control" style="margin:12px 0;padding:12px;border-radius:8px;border:1px solid var(--border-color, #eee);background:var(--panel-bg, #fff);box-shadow:var(--panel-shadow, none);">
  <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
    <label style="min-width:86px;color:var(--muted,#666);">API 预设：</label>
    <select id="api-preset-select" style="flex:1;padding:8px;border-radius:6px;border:1px solid #ddd;">
      <option value="">— 选择 API 预设 —</option>
    </select>
    <button id="api-apply-preset" class="btn btn-primary" style="margin-left:8px;padding:6px 10px;">应用</button>
  </div>
  <div style="display:flex;gap:8px;align-items:center;">
    <button id="api-save-preset" class="btn" style="padding:6px 10px;">另存为预设</button>
    <button id="api-manage-presets" class="btn" style="padding:6px 10px;">管理预设</button>
    <div style="flex:1"></div>
    <button id="api-import-presets" class="btn" style="padding:6px 10px;">导入</button>
    <button id="api-export-presets" class="btn" style="padding:6px 10px;">导出</button>
  </div>
</div>

<!-- 管理 modal -->
<div id="api-presets-modal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.35);z-index:9999;align-items:center;justify-content:center;">
  <div style="width:640px;max-width:94%;background:var(--panel-bg,#fff);padding:16px;border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,0.12);">
    <h3 style="margin:0 0 12px 0;">API 预设管理</h3>
    <div id="api-presets-list" style="max-height:360px;overflow:auto;border:1px solid #f0f0f0;padding:8px;border-radius:6px;"></div>
    <div style="display:flex;gap:8px;margin-top:12px;justify-content:flex-end;">
      <button id="api-close-modal" class="btn btn-primary">关闭</button>
    </div>
  </div>
</div>
<!-- === /API 预设管理 === -->
</div>
<!-- === /嵌入结束 === -->
</div><div class="form-group"><label for="api-url">API 地址（后缀不用添加/v1）</label><input type="url" id="api-url" name="url" placeholder="选择服务商可自动填写" required></div><div class="form-group"><label for="api-key">密钥 (Key)</label><input type="password" id="api-key" name="key" placeholder="请输入你的API密钥" required></div><button type="button" class="btn btn-secondary" id="fetch-models-btn"><span class="btn-text">点击拉取模型</span><div class="spinner"></div></button><div class="form-group"><label for="api-model">选择模型</label><select id="api-model" name="model" required><option value="">请先拉取模型列表</option></select></div><button type="submit" class="btn btn-primary" id="save-btn"><span class="btn-text">保 存</span><div class="spinner"></div></button></form></main>`;
        document.getElementById('wallpaper-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">更换壁纸</h1></div><div class="placeholder"></div></header><main class="content"><div class="wallpaper-preview" id="wallpaper-preview"><span>当前壁纸预览</span></div><input type="file" id="wallpaper-upload" accept="image/*" style="display: none;"><label for="wallpaper-upload" class="btn btn-primary">从相册选择新壁纸</label></main>`;
        document.getElementById('font-settings-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">字体设置</h1></div><div class="placeholder"></div></header><main class="content"><form id="font-settings-form"><div class="form-group"><label for="font-url">字体链接 (ttf, woff, woff2)</label><input type="url" id="font-url" placeholder="https://.../font.ttf" required></div><p style="font-size:12px; color:#888; text-align:center;">示例: https://lf3-static.bytednsdoc.com/obj/eden-cn/jplptk/ljhwZthlaukjlkulzlp/portal/fonts/HarmonyOS_Sans_SC_Regular.woff2</p><button type="submit" class="btn btn-primary">应用字体</button><button type="button" class="btn btn-neutral" id="restore-default-font-btn" style="margin-top: 15px;">恢复默认字体</button></form></main>`;
        document.getElementById('customize-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">主屏幕自定义</h1></div><div class="placeholder"></div></header><main class="content"><form id="customize-form"></form></main>`;
        document.getElementById('tutorial-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">教程</h1></div><div class="placeholder"></div></header><main class="content" id="tutorial-content-area"></main>`;

        // --- Global Variables and Constants ---
        const colorThemes = {
            'white_pink': {
                name: '白/粉',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(255,204,204,0.9)', text: '#A56767'}
            },
            'white_blue': {
                name: '白/蓝',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(173,216,230,0.9)', text: '#4A6F8A'}
            },
            'white_yellow': {
                name: '白/黄',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(249,237,105,0.9)', text: '#8B7E4B'}
            },
            'white_green': {
                name: '白/绿',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(188,238,188,0.9)', text: '#4F784F'}
            },
            'white_purple': {
                name: '白/紫',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(185,190,240,0.9)', text: '#6C5B7B'}
            },
            'black_red': {
                name: '黑/红',
                received: {bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0'},
                sent: {bg: 'rgb(226,62,87,0.9)', text: '#fff'}
            },
            'black_green': {
                name: '黑/绿',
                received: {bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0'},
                sent: {bg: 'rgba(119,221,119,0.9)', text: '#2E5C2E'}
            },
            'black_white': {
                name: '黑/白',
                received: {bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0'},
                sent: {bg: 'rgba(245,245,245,0.9)', text: '#333'}
            },
            'white_black': {
                name: '白/黑',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(50,50,50,0.85)', text: '#F5F5F5'}
            },
            'yellow_purple': {
                name: '黄/紫',
                received: {bg: 'rgba(255,250,205,0.9)', text: '#8B7E4B'},
                sent: {bg: 'rgba(185,190,240,0.9)', text: '#6C5B7B'}
            },
            'pink_blue': {
                name: '粉/蓝',
                received: {bg: 'rgba(255,231,240,0.9)', text: '#7C6770'},
                sent: {bg: 'rgba(173,216,230,0.9)', text: '#4A6F8A'}
            },
        };
        const defaultIcons = {
            'chat-list-screen': {name: '404', url: 'https://i.postimg.cc/VvQB8dQT/chan-143.png'},
            'api-settings-screen': {name: 'api', url: 'https://i.postimg.cc/50FqT8GL/chan-125.png'},
            'wallpaper-screen': {name: '壁纸', url: 'https://i.postimg.cc/3wqFttL3/chan-90.png'},
            'world-book-screen': {name: '世界书', url: 'https://i.postimg.cc/prCWkrKT/chan-74.png'},
            'customize-screen': {name: '自定义', url: 'https://i.postimg.cc/vZVdC7gt/chan-133.png'},
            'font-settings-screen': {name: '字体', url: 'https://i.postimg.cc/FzVtC0x4/chan-21.png'},
            'tutorial-screen': {name: '教程', url: 'https://i.postimg.cc/6QgNzCFf/chan-118.png'},
            'day-mode-btn': {name: '', url: 'https://i.postimg.cc/Jz0tYqnT/chan-145.png'},
            'night-mode-btn': {name: '', url: 'https://i.postimg.cc/htYvkdQK/chan-146.png'}
        };

        let db = {
            characters: [],
            groups: [],
            apiSettings: {},
            wallpaper: 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg',
            myStickers: [],
            homeScreenMode: 'night',
            worldBooks: [],
            fontUrl: '',
            customIcons: {}
        };
        let currentChatId = null, currentChatType = null, isGenerating = false, longPressTimer = null,
            isInMultiSelectMode = false, editingMessageId = null, currentPage = 1, currentTransferMessageId = null,
            currentEditingWorldBookId = null, currentStickerActionTarget = null,
            currentGroupAction = {type: null, recipients: []};
        let selectedMessageIds = new Set();
        const MESSAGES_PER_PAGE = 50;

        // --- DOM Element Cache ---
        const screens = document.querySelectorAll('.screen'),
            toastElement = document.getElementById('toast-notification'),
            homeScreen = document.getElementById('home-screen'),
            chatListContainer = document.getElementById('chat-list-container'),
            noChatsPlaceholder = document.getElementById('no-chats-placeholder'),
            addChatBtn = document.getElementById('add-chat-btn'),
            addCharModal = document.getElementById('add-char-modal'),
            addCharForm = document.getElementById('add-char-form'),
            chatRoomScreen = document.getElementById('chat-room-screen'),
            chatRoomHeaderDefault = document.getElementById('chat-room-header-default'),
            chatRoomHeaderSelect = document.getElementById('chat-room-header-select'),
            cancelMultiSelectBtn = document.getElementById('cancel-multi-select-btn'),
            multiSelectTitle = document.getElementById('multi-select-title'),
            chatRoomTitle = document.getElementById('chat-room-title'),
            chatRoomStatusText = document.getElementById('chat-room-status-text'),
            messageArea = document.getElementById('message-area'),
            messageInputDefault = document.getElementById('message-input-default'),
            messageInput = document.getElementById('message-input'),
            sendMessageBtn = document.getElementById('send-message-btn'),
            getReplyBtn = document.getElementById('get-reply-btn'),
            typingIndicator = document.getElementById('typing-indicator'),
            chatSettingsBtn = document.getElementById('chat-settings-btn'),
            settingsSidebar = document.getElementById('chat-settings-sidebar'),
            settingsForm = document.getElementById('chat-settings-form'),
            messageEditBar = document.getElementById('message-edit-bar'),
            messageEditInput = document.getElementById('message-edit-input'),
            saveEditBtn = document.getElementById('save-edit-btn'),
            cancelEditBtn = document.getElementById('cancel-edit-btn'),
            multiSelectBar = document.getElementById('multi-select-bar'),
            selectCount = document.getElementById('select-count'),
            deleteSelectedBtn = document.getElementById('delete-selected-btn');
        const stickerToggleBtn = document.getElementById('sticker-toggle-btn'),
            stickerModal = document.getElementById('sticker-modal'),
            stickerGridContainer = document.getElementById('sticker-grid-container'),
            addNewStickerBtn = document.getElementById('add-new-sticker-btn'),
            addStickerModal = document.getElementById('add-sticker-modal'),
            addStickerModalTitle = document.getElementById('add-sticker-modal-title'),
            addStickerForm = document.getElementById('add-sticker-form'),
            stickerEditIdInput = document.getElementById('sticker-edit-id'),
            stickerPreview = document.getElementById('sticker-preview'),
            stickerNameInput = document.getElementById('sticker-name'),
            stickerUrlInput = document.getElementById('sticker-url-input'),
            stickerFileUpload = document.getElementById('sticker-file-upload');
        const stickerActionSheet = document.getElementById('sticker-actionsheet'),
            editStickerBtn = document.getElementById('edit-sticker-btn'),
            deleteStickerBtn = document.getElementById('delete-sticker-btn');
        const voiceMessageBtn = document.getElementById('voice-message-btn'),
            sendVoiceModal = document.getElementById('send-voice-modal'),
            sendVoiceForm = document.getElementById('send-voice-form'),
            voiceTextInput = document.getElementById('voice-text-input'),
            voiceDurationPreview = document.getElementById('voice-duration-preview');
        const photoVideoBtn = document.getElementById('photo-video-btn'),
            sendPvModal = document.getElementById('send-pv-modal'),
            sendPvForm = document.getElementById('send-pv-form'),
            pvTextInput = document.getElementById('pv-text-input');
        const imageRecognitionBtn = document.getElementById('image-recognition-btn'),
            imageUploadInput = document.getElementById('image-upload-input');
        const walletBtn = document.getElementById('wallet-btn'),
            sendTransferModal = document.getElementById('send-transfer-modal'),
            sendTransferForm = document.getElementById('send-transfer-form'),
            transferAmountInput = document.getElementById('transfer-amount-input'),
            transferRemarkInput = document.getElementById('transfer-remark-input');
        const receiveTransferActionSheet = document.getElementById('receive-transfer-actionsheet'),
            acceptTransferBtn = document.getElementById('accept-transfer-btn'),
            returnTransferBtn = document.getElementById('return-transfer-btn');
        const giftBtn = document.getElementById('gift-btn'), sendGiftModal = document.getElementById('send-gift-modal'),
            sendGiftForm = document.getElementById('send-gift-form'),
            giftDescriptionInput = document.getElementById('gift-description-input');
        const timeSkipBtn = document.getElementById('time-skip-btn'),
            timeSkipModal = document.getElementById('time-skip-modal'),
            timeSkipForm = document.getElementById('time-skip-form'),
            timeSkipInput = document.getElementById('time-skip-input');
        const clearChatHistoryBtn = document.getElementById('clear-chat-history-btn');
        const worldBookListContainer = document.getElementById('world-book-list-container'),
            noWorldBooksPlaceholder = document.getElementById('no-world-books-placeholder'),
            addWorldBookBtn = document.getElementById('add-world-book-btn'),
            editWorldBookScreen = document.getElementById('edit-world-book-screen'),
            editWorldBookForm = document.getElementById('edit-world-book-form'),
            worldBookIdInput = document.getElementById('world-book-id'),
            worldBookNameInput = document.getElementById('world-book-name'),
            worldBookContentInput = document.getElementById('world-book-content');
        const linkWorldBookBtn = document.getElementById('link-world-book-btn'),
            worldBookSelectionModal = document.getElementById('world-book-selection-modal'),
            worldBookSelectionList = document.getElementById('world-book-selection-list'),
            saveWorldBookSelectionBtn = document.getElementById('save-world-book-selection-btn');
        const fontSettingsForm = document.getElementById('font-settings-form'),
            fontUrlInput = document.getElementById('font-url'),
            restoreDefaultFontBtn = document.getElementById('restore-default-font-btn');
        const createGroupBtn = document.getElementById('create-group-btn'),
            createGroupModal = document.getElementById('create-group-modal'),
            createGroupForm = document.getElementById('create-group-form'),
            memberSelectionList = document.getElementById('member-selection-list'),
            groupNameInput = document.getElementById('group-name-input'),
            groupSettingsSidebar = document.getElementById('group-settings-sidebar'),
            groupSettingsForm = document.getElementById('group-settings-form'),
            groupMembersListContainer = document.getElementById('group-members-list-container'),
            editGroupMemberModal = document.getElementById('edit-group-member-modal'),
            editGroupMemberForm = document.getElementById('edit-group-member-form');
        const addMemberActionSheet = document.getElementById('add-member-actionsheet'),
            inviteExistingMemberBtn = document.getElementById('invite-existing-member-btn'),
            createNewMemberBtn = document.getElementById('create-new-member-btn'),
            inviteMemberModal = document.getElementById('invite-member-modal'),
            inviteMemberSelectionList = document.getElementById('invite-member-selection-list'),
            confirmInviteBtn = document.getElementById('confirm-invite-btn'),
            createMemberForGroupModal = document.getElementById('create-member-for-group-modal'),
            createMemberForGroupForm = document.getElementById('create-member-for-group-form');
        const customizeForm = document.getElementById('customize-form'),
            tutorialContentArea = document.getElementById('tutorial-content-area');
        const groupRecipientSelectionModal = document.getElementById('group-recipient-selection-modal'),
            groupRecipientSelectionList = document.getElementById('group-recipient-selection-list'),
            confirmGroupRecipientBtn = document.getElementById('confirm-group-recipient-btn'),
            groupRecipientSelectionTitle = document.getElementById('group-recipient-selection-title');
        const linkGroupWorldBookBtn = document.getElementById('link-group-world-book-btn');

        // --- Utility and Core Functions ---
        class DataStorage {
            constructor() {
                // 创建数据库
                this.db = new Dexie('章鱼喷墨机DB');

                // 定义数据库结构
                this.db.version(1).stores({
                    storage: 'key, value, timestamp' // key作为主键，value存储数据，timestamp记录时间
                });
            }

            // 保存数据 - 类似 localStorage.setItem
            async saveData(key, data) {
                try {
                    const item = {
                        key: key,
                        value: JSON.stringify(data), // 将数据序列化
                        timestamp: Date.now()
                    };

                    await this.db.storage.put(item);
                    console.log(`数据已保存: ${key}`);
                    return true;
                } catch (error) {
                    console.error('保存数据失败:', error);
                    return false;
                }
            }

            // 获取数据 - 类似 localStorage.getItem
            async getData(key) {
                try {
                    const item = await this.db.storage.get(key);

                    if (item) {
                        return JSON.parse(item.value); // 反序列化数据
                    } else {
                        console.log(`未找到数据: ${key}`);
                        return null;
                    }
                } catch (error) {
                    console.error('获取数据失败:', error);
                    return null;
                }
            }

            // 删除数据
            async removeData(key) {
                try {
                    await this.db.storage.delete(key);
                    console.log(`数据已删除: ${key}`);
                    return true;
                } catch (error) {
                    console.error('删除数据失败:', error);
                    return false;
                }
            }

            // 清空所有数据
            async clearAll() {
                try {
                    await this.db.storage.clear();
                    console.log('所有数据已清空');
                    return true;
                } catch (error) {
                    console.error('清空数据失败:', error);
                    return false;
                }
            }

            // 获取所有键名
            async getAllKeys() {
                try {
                    const items = await this.db.storage.toArray();
                    return items.map(item => item.key);
                } catch (error) {
                    console.error('获取键名失败:', error);
                    return [];
                }
            }

            // 获取数据库大小信息
            async getStorageInfo() {
                try {
                    const items = await this.db.storage.toArray();
                    const totalSize = items.reduce((sum, item) => sum + item.value.length, 0);

                    return {
                        itemCount: items.length,
                        totalSize: totalSize,
                        items: items.map(item => ({
                            key: item.key,
                            size: item.value.length,
                            timestamp: new Date(item.timestamp).toLocaleString()
                        }))
                    };
                } catch (error) {
                    console.error('获取存储信息失败:', error);
                    return null;
                }
            }
        }

        const dataStorage = new DataStorage();


        const saveData = async (data) => {
            await dataStorage.saveData('章鱼喷墨机', data ? data : db);
            return Promise.resolve();
        };
        const loadData = async () => {
            const oldData = localStorage.getItem('gemini-chat-app-db');
            let data = await dataStorage.getData('章鱼喷墨机')
            if (oldData) {
                await saveData(JSON.parse(oldData))
                data = await dataStorage.getData('章鱼喷墨机')
                localStorage.removeItem('gemini-chat-app-db');
            }
            if (data) db = data;
            if (!db.apiSettings) db.apiSettings = {};
            if (!db.wallpaper) db.wallpaper = 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg';
            if (!db.characters) db.characters = [];
            if (!db.groups) db.groups = [];
            if (!db.myStickers) db.myStickers = [];
            if (!db.homeScreenMode) db.homeScreenMode = 'night';
            if (!db.worldBooks) db.worldBooks = [];
            if (!db.fontUrl) db.fontUrl = '';
            if (!db.customIcons) db.customIcons = {};
            db.characters.forEach(c => {
                if (c.isPinned === undefined) c.isPinned = false;
                if (c.status === undefined) c.status = '在线';
                if (!c.worldBookIds) c.worldBookIds = [];
                if (c.customBubbleCss === undefined) c.customBubbleCss = '';
                if (c.useCustomBubbleCss === undefined) c.useCustomBubbleCss = false;
            });
            db.groups.forEach(g => {
                if (g.isPinned === undefined) g.isPinned = false;
                if (!g.worldBookIds) g.worldBookIds = [];
                if (g.customBubbleCss === undefined) g.customBubbleCss = '';
                if (g.useCustomBubbleCss === undefined) g.useCustomBubbleCss = false;
            });

            return Promise.resolve()
        };
        const showToast = (message) => {
            toastElement.textContent = message;
            toastElement.classList.add('show');
            setTimeout(() => toastElement.classList.remove('show'), 3000);
        };
        const switchScreen = (targetId) => {
            screens.forEach(screen => screen.classList.remove('active'));
            document.getElementById(targetId)?.classList.add('active');
            // Close all overlays and sidebars
            const overlays = document.querySelectorAll('.modal-overlay, .action-sheet-overlay, .settings-sidebar');
            overlays.forEach(o => o.classList.remove('visible', 'open'));
        };
        const pad = (num) => num.toString().padStart(2, '0');

        function createContextMenu(items, x, y) {
            removeContextMenu();
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.left = `${x}px`;
            menu.style.top = `${y}px`;
            items.forEach(item => {
                const menuItem = document.createElement('div');
                menuItem.className = 'context-menu-item';
                if (item.danger) menuItem.classList.add('danger');
                menuItem.textContent = item.label;
                menuItem.onclick = () => {
                    item.action();
                    removeContextMenu();
                };
                menu.appendChild(menuItem);
            });
            document.body.appendChild(menu);
            document.addEventListener('click', removeContextMenu, {once: true});
        }

        function removeContextMenu() {
            const menu = document.querySelector('.context-menu');
            if (menu) menu.remove();
        }

        function updateCustomBubbleStyle(chatId, css, enabled) {
            const styleId = `custom-bubble-style-for-${chatId}`;
            let styleElement = document.getElementById(styleId);

            if (enabled && css) {
                if (!styleElement) {
                    styleElement = document.createElement('style');
                    styleElement.id = styleId;
                    document.head.appendChild(styleElement);
                }
                const scopedCss = css.replace(/(\.message-bubble(?:\.sent|\.received)?)/g, `#chat-room-screen.chat-active-${chatId} $1`);
                styleElement.innerHTML = scopedCss;
            } else {
                if (styleElement) styleElement.remove();
            }
        }

        function updateBubbleCssPreview(previewContainer, css, useDefault, theme) {
            previewContainer.innerHTML = '';

            const sentBubble = document.createElement('div');
            sentBubble.className = 'message-bubble sent';
            sentBubble.textContent = '这是我方气泡。';
            sentBubble.style.alignSelf = 'flex-end';
            sentBubble.style.borderBottomRightRadius = '5px';

            const receivedBubble = document.createElement('div');
            receivedBubble.className = 'message-bubble received';
            receivedBubble.textContent = '这是对方气泡。';
            receivedBubble.style.alignSelf = 'flex-start';
            receivedBubble.style.borderBottomLeftRadius = '5px';

            [sentBubble, receivedBubble].forEach(bubble => {
                bubble.style.maxWidth = '70%';
                bubble.style.padding = '8px 12px';
                bubble.style.wordWrap = 'break-word';
                bubble.style.lineHeight = '1.4';
            });

            if (useDefault || !css) {
                sentBubble.style.backgroundColor = theme.sent.bg;
                sentBubble.style.color = theme.sent.text;
                sentBubble.style.borderRadius = '18px';
                sentBubble.style.borderBottomRightRadius = '5px';
                receivedBubble.style.backgroundColor = theme.received.bg;
                receivedBubble.style.color = theme.received.text;
                receivedBubble.style.borderRadius = '18px';
                receivedBubble.style.borderBottomLeftRadius = '5px';
            } else {
                const styleTag = document.createElement('style');
                const scopedCss = css.replace(/(\.message-bubble(?:\.sent|\.received)?)/g, `#${previewContainer.id} $1`);
                styleTag.textContent = scopedCss;
                previewContainer.appendChild(styleTag);
            }
            previewContainer.appendChild(receivedBubble);
            previewContainer.appendChild(sentBubble);
        }

        const init = async () => {
            await loadData();
            window.db = db; // Expose db for moments script
            document.body.addEventListener('click', (e) => {
                if (e.target.closest('.context-menu')) {
                    e.stopPropagation();
                    return;
                }
                removeContextMenu();

                const backBtn = e.target.closest('.back-btn');
                if (backBtn) {
                    e.preventDefault();
                    switchScreen(backBtn.getAttribute('data-target'));
                }

                // Consolidated overlay closing logic
                const openOverlay = document.querySelector('.modal-overlay.visible, .action-sheet-overlay.visible');
                if (openOverlay && e.target === openOverlay) {
                    openOverlay.classList.remove('visible');
                }
            });

            // Specific nav links that switch screens
            document.body.addEventListener('click', e => {
                const navLink = e.target.closest('.app-icon[data-target]');
                if (navLink) {
                    e.preventDefault();
                    switchScreen(navLink.getAttribute('data-target'));
                }
            });

            updateClock();
            setInterval(updateClock, 30000);
            applyGlobalFont(db.fontUrl);
            setupHomeScreen();
            setupChatListScreen();
            setupAddCharModal();
            setupChatRoom();
            setupChatSettings();
            setupApiSettingsApp();
            setupWallpaperApp();
            setupStickerSystem();
            setupVoiceMessageSystem();
            setupPhotoVideoSystem();
            setupImageRecognition();
            setupWalletSystem();
            setupGiftSystem();
            setupTimeSkipSystem();
            setupWorldBookApp();
            setupFontSettingsApp();
            setupGroupChatSystem();
            setupCustomizeApp();
            setupTutorialApp();
        };

        function updateClock() {
            const now = new Date();
            const timeDisplay = document.getElementById('time-display');
            const dateDisplay = document.getElementById('date-display');
            if (timeDisplay) timeDisplay.textContent = `${pad(now.getHours())}:${pad(now.getMinutes())}`;
            if (dateDisplay) dateDisplay.textContent = `${now.getFullYear()}年${pad(now.getMonth() + 1)}月${pad(now.getDate())}日`;
        }

        // --- App Setup Functions ---
        function setupHomeScreen() {
            const getIcon = (id) => db.customIcons[id] || defaultIcons[id].url;
            const homeScreenHTML = `
            <div class="time-widget"><div class="time" id="time-display"></div><div class="date" id="date-display"></div></div>
            <div class="app-grid">
                <a href="#" class="app-icon" data-target="chat-list-screen"><img src="${getIcon('chat-list-screen')}" alt="404" class="icon-img"><span class="app-name">${defaultIcons['chat-list-screen'].name}</span></a>
                <a href="#" class="app-icon" data-target="api-settings-screen"><img src="${getIcon('api-settings-screen')}" alt="API" class="icon-img"><span class="app-name">${defaultIcons['api-settings-screen'].name}</span></a>
                <a href="#" class="app-icon" data-target="wallpaper-screen"><img src="${getIcon('wallpaper-screen')}" alt="Wallpaper" class="icon-img"><span class="app-name">${defaultIcons['wallpaper-screen'].name}</span></a>
                <a href="#" class="app-icon" data-target="world-book-screen"><img src="${getIcon('world-book-screen')}" alt="World Book" class="icon-img"><span class="app-name">${defaultIcons['world-book-screen'].name}</span></a>
                <a href="#" class="app-icon" data-target="customize-screen"><img src="${getIcon('customize-screen')}" alt="Customize" class="icon-img"><span class="app-name">${defaultIcons['customize-screen'].name}</span></a>
                <a href="#" class="app-icon" data-target="tutorial-screen"><img src="${getIcon('tutorial-screen')}" alt="Tutorial" class="icon-img"><span class="app-name">${defaultIcons['tutorial-screen'].name}</span></a>
            </div>
            <div class="dock">
                <a href="#" class="app-icon" id="day-mode-btn"><img src="${getIcon('day-mode-btn')}" alt="日间" class="icon-img"></a>
                <a href="#" class="app-icon" id="night-mode-btn"><img src="${getIcon('night-mode-btn')}" alt="夜间" class="icon-img"></a>
                <a href="#" class="app-icon" data-target="font-settings-screen"><img src="${getIcon('font-settings-screen')}" alt="字体" class="icon-img"></a>
            </div>`;
            homeScreen.innerHTML = homeScreenHTML;
            updateClock();
            applyWallpaper(db.wallpaper);
            applyHomeScreenMode(db.homeScreenMode);
            document.getElementById('day-mode-btn')?.addEventListener('click', (e) => {
                e.preventDefault();
                applyHomeScreenMode('day');
            });
            document.getElementById('night-mode-btn')?.addEventListener('click', (e) => {
                e.preventDefault();
                applyHomeScreenMode('night');
            });
            document.querySelector('[data-target="world-book-screen"]').addEventListener('click', renderWorldBookList);
            document.querySelector('[data-target="customize-screen"]').addEventListener('click', renderCustomizeForm);
            document.querySelector('[data-target="tutorial-screen"]').addEventListener('click', renderTutorialContent);
        }

        function applyWallpaper(url) {
            homeScreen.style.backgroundImage = `url(${url})`;
        }

        async function applyHomeScreenMode(mode) {
            if (mode === 'day') {
                homeScreen.classList.add('day-mode');
            } else {
                homeScreen.classList.remove('day-mode');
            }
            db.homeScreenMode = mode;
            await saveData();
        }

        function setupCustomizeApp() {
            customizeForm.addEventListener('input', async (e) => {
                if (e.target.matches('input[type="url"]')) {
                    const iconId = e.target.dataset.id;
                    const newUrl = e.target.value.trim();
                    const previewImg = document.getElementById(`icon-preview-${iconId}`);
                    if (newUrl) {
                        db.customIcons[iconId] = newUrl;
                        previewImg.src = newUrl;
                        await saveData();
                        setupHomeScreen();
                    }
                }
            });
            customizeForm.addEventListener('click', async (e) => {
                if (e.target.matches('.reset-icon-btn')) {
                    const iconId = e.target.dataset.id;
                    delete db.customIcons[iconId];
                    await saveData();
                    renderCustomizeForm();
                    setupHomeScreen();
                    showToast('图标已重置');
                }
            });
        }

        function renderCustomizeForm() {
            customizeForm.innerHTML = '';
            Object.entries(defaultIcons).forEach(([id, {name, url}]) => {
                const currentIcon = db.customIcons[id] || url;
                const itemHTML = `
                <div class="icon-custom-item">
                    <img src="${currentIcon}" alt="${name}" class="icon-preview" id="icon-preview-${id}">
                    <div class="icon-details">
                        <p>${name || '模式切换'}</p>
                        <input type="url" class="form-group" placeholder="粘贴新的图标URL" value="${db.customIcons[id] || ''}" data-id="${id}">
                    </div>
                    <button type="button" class="reset-icon-btn" data-id="${id}">重置</button>
                </div>`;
                customizeForm.insertAdjacentHTML('beforeend', itemHTML);
            });
        }

        function setupTutorialApp() {
            tutorialContentArea.addEventListener('click', (e) => {
                const header = e.target.closest('.tutorial-header');
                if (header) {
                    header.parentElement.classList.toggle('open');
                }
            });
        }
        let loadingBtn = false

        function renderTutorialContent() {
            const tutorials = [
                {title: '写在前面', imageUrls: ['https://i.postimg.cc/7PgyMG9S/image.jpg']},
                {
                    title: '软件介绍',
                    imageUrls: ['https://i.postimg.cc/VvsJRh6q/IMG-20250713-162647.jpg', 'https://i.postimg.cc/8P5FfxxD/IMG-20250713-162702.jpg', 'https://i.postimg.cc/3r94R3Sn/IMG-20250713-162712.jpg']
                },
                {
                    title: '404',
                    imageUrls: ['https://i.postimg.cc/x8scFPJW/IMG-20250713-162756.jpg', 'https://i.postimg.cc/pX6mfqtj/IMG-20250713-162809.jpg', 'https://i.postimg.cc/YScjV00q/IMG-20250713-162819.jpg', 'https://i.postimg.cc/13VfJw9j/IMG-20250713-162828.jpg']
                },
                {title: '404-群聊', imageUrls: ['https://i.postimg.cc/X7LSmRTJ/404.jpg']}
            ];
            tutorialContentArea.innerHTML = '';
            tutorials.forEach(tutorial => {
                const item = document.createElement('div');
                item.className = 'tutorial-item';
                const imagesHtml = tutorial.imageUrls.map(url => `<img src="${url}" alt="${tutorial.title}教程图片">`).join('');
                item.innerHTML = `<div class="tutorial-header">${tutorial.title}</div><div class="tutorial-content">${imagesHtml}</div>`;
                tutorialContentArea.appendChild(item);
            });

            const backupDataBtn = document.createElement('button');
            backupDataBtn.className = 'btn btn-primary';
            backupDataBtn.textContent = '备份数据';
            backupDataBtn.disabled = loadingBtn

            backupDataBtn.addEventListener('click', async () => {
                if(loadingBtn){
                    return
                }
                loadingBtn = true
                try {
                    // --- 增强备份功能：同时备份 localStorage 中的预设 ---
                    const backupData = {
                        mainDb: db, // 核心数据
                        apiPresets: JSON.parse(localStorage.getItem('apiPresets') || '[]'),
                        bubblePresets: JSON.parse(localStorage.getItem('bubblePresets') || '[]'),
                        myPersonaPresets: JSON.parse(localStorage.getItem('myPersonaPresets') || '[]')
                    };
                    const jsonString = JSON.stringify(backupData);
                    const dataBlob = new Blob([jsonString]);

                    // Compress the data using Gzip
                    const compressionStream = new CompressionStream('gzip');
                    const compressedStream = dataBlob.stream().pipeThrough(compressionStream);
                    const compressedBlob = await new Response(compressedStream).blob();

                    const url = URL.createObjectURL(compressedBlob);
                    const a = document.createElement('a');
                    const now = new Date();
                    const date = now.toISOString().slice(0, 10);
                    const time = now.toTimeString().slice(0, 8).replace(/:/g, '');
                    a.href = url;
                    a.download = `章鱼喷墨_备份数据_${date}_${time}.ee`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    loadingBtn = false
                    showToast('聊天记录导出成功');
                }catch (e){
                    showToast(`导出失败, 发生错误: ${e.message}`);
                }
            });
            const importDataBtn = document.createElement('label');
            importDataBtn.className = 'btn btn-neutral';
            importDataBtn.textContent = '导入数据';
            importDataBtn.style.marginTop = '15px'
            importDataBtn.style.display = 'block'
            importDataBtn.disabled = loadingBtn;
            importDataBtn.setAttribute('for', 'import-data-input')
            document.querySelector('#import-data-input').addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                if(confirm('此操作将覆盖当前所有聊天记录和设置。此操作不可撤销。确定要继续吗？')){
                    try {
                        // Decompress the file stream
                        const decompressionStream = new DecompressionStream('gzip');
                        const decompressedStream = file.stream().pipeThrough(decompressionStream);
                        const jsonString = await new Response(decompressedStream).text();

                        let data = JSON.parse(jsonString);

                        // --- 增强导入功能：区分新旧备份格式 ---
                        if (data && data.mainDb) {
                            // 新格式：包含核心数据和预设
                            await saveData(data.mainDb); // 恢复核心数据到 IndexedDB
                            
                            // 恢复预设到 localStorage
                            localStorage.setItem('apiPresets', JSON.stringify(data.apiPresets || []));
                            localStorage.setItem('bubblePresets', JSON.stringify(data.bubblePresets || []));
                            localStorage.setItem('myPersonaPresets', JSON.stringify(data.myPersonaPresets || []));
                            
                            showToast(`数据和预设已成功恢复。应用即将刷新。`);
                        } else {
                            // 旧格式：只包含核心数据
                            await saveData(data);
                            showToast(`数据已成功恢复（未找到预设信息）。应用即将刷新。`);
                        }
                        
                        window.location.reload();
                    } catch (error) {
                        console.error("导入失败:", error);
                        showToast(`解压或解析文件时发生错误: ${error.message}`);
                    } finally {
                        event.target.value = null;
                    }
                }else {
                    event.target.value = null;
                }

            })

            tutorialContentArea.appendChild(backupDataBtn);
            tutorialContentArea.appendChild(importDataBtn);
        }

        // --- Chat List & Chat Room ---
        function setupChatListScreen() {
            renderChatList();
            addChatBtn.addEventListener('click', () => {
                addCharModal.classList.add('visible');
                addCharForm.reset();
            });
            chatListContainer.addEventListener('click', (e) => {
                const chatItem = e.target.closest('.chat-item');
                if (chatItem) {
                    currentChatId = chatItem.dataset.id;
                    currentChatType = chatItem.dataset.type;
                    openChatRoom(currentChatId, currentChatType);
                }
            });
            chatListContainer.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                const chatItem = e.target.closest('.chat-item');
                if (!chatItem) return;
                handleChatListLongPress(chatItem.dataset.id, chatItem.dataset.type, e.clientX, e.clientY);
            });
            chatListContainer.addEventListener('touchstart', (e) => {
                const chatItem = e.target.closest('.chat-item');
                if (!chatItem) return;
                longPressTimer = setTimeout(() => {
                    const touch = e.touches[0];
                    handleChatListLongPress(chatItem.dataset.id, chatItem.dataset.type, touch.clientX, touch.clientY);
                }, 400);
            });
            chatListContainer.addEventListener('touchend', () => clearTimeout(longPressTimer));
            chatListContainer.addEventListener('touchmove', () => clearTimeout(longPressTimer));
        }

        function handleChatListLongPress(chatId, chatType, x, y) {
            clearTimeout(longPressTimer);
            const chatItem = (chatType === 'private') ? db.characters.find(c => c.id === chatId) : db.groups.find(g => g.id === chatId);
            if (!chatItem) return;
            const itemName = chatType === 'private' ? chatItem.remarkName : chatItem.name;
            const menuItems = [{
                label: chatItem.isPinned ? '取消置顶' : '置顶聊天',
                action: async () => {
                    chatItem.isPinned = !chatItem.isPinned;
                    await saveData();
                    renderChatList();
                }
            }, {
                label: '删除聊天',
                danger: true,
                action: async () => {
                    if (confirm(`确定要删除与“${itemName}”的聊天记录吗？此操作不可恢复。`)) {
                        if (chatType === 'private') {
                            db.characters = db.characters.filter(c => c.id !== chatId);
                        } else {
                            db.groups = db.groups.filter(g => g.id !== chatId);
                        }
                        await saveData();
                        renderChatList();
                        showToast('聊天已删除');
                    }
                }
            }];
            createContextMenu(menuItems, x, y);
        }

        function renderChatList() {
            chatListContainer.innerHTML = '';
            const allChats = [...db.characters.map(c => ({...c, type: 'private'})), ...db.groups.map(g => ({
                ...g,
                type: 'group'
            }))];
            noChatsPlaceholder.style.display = (db.characters.length + db.groups.length) === 0 ? 'block' : 'none';
            const sortedChats = allChats.sort((a, b) => {
                if (a.isPinned !== b.isPinned) return a.isPinned ? -1 : 1;
                const lastMsgTimeA = a.history && a.history.length > 0 ? a.history[a.history.length - 1].timestamp : 0;
                const lastMsgTimeB = b.history && b.history.length > 0 ? b.history[b.history.length - 1].timestamp : 0;
                return lastMsgTimeB - lastMsgTimeA;
            });
            sortedChats.forEach(chat => {
                let lastMessageText = '开始聊天吧...';
                if (chat.history && chat.history.length > 0) {
                    const invisibleRegex = /\[.*?(?:接收|退回).*?的转账\]|\[.*?更新状态为：.*?\]|\[.*?已接收礼物\]|\[system:.*?\]|\[.*?邀请.*?加入了群聊\]|\[.*?修改群名为：.*?\]|\[system-display:.*?\]/;
                    const visibleHistory = chat.history.filter(msg => !invisibleRegex.test(msg.content));
                    if (visibleHistory.length > 0) {
                        const lastMsg = visibleHistory[visibleHistory.length - 1];
                        const urlRegex = /^(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|webp|bmp|svg)|data:image\/[a-z]+;base64,)/i;
                        const imageRecogRegex = /\[.*?发来了一张图片：\]/
                        const voiceRegex = /\[.*?的语音：.*?\]/;
                        const photoVideoRegex = /\[.*?发来的照片\/视频：.*?\]/;
                        const transferRegex = /\[.*?的转账：.*?元.*?\]|\[.*?给你转账：.*?元.*?\]|\[.*?向.*?转账：.*?元.*?\]/;
                        const stickerRegex = /\[.*?的表情包：.*?\]|\[.*?发送的表情包：.*?\]/;
                        const giftRegex = /\[.*?送来的礼物：.*?\]|\[.*?向.*?送来了礼物：.*?\]/;



                        if (giftRegex.test(lastMsg.content)) {
                            lastMessageText = '[礼物]';
                        } else if (stickerRegex.test(lastMsg.content)) {
                            lastMessageText = '[表情包]';
                        } else if (voiceRegex.test(lastMsg.content)) {
                            lastMessageText = '[语音]';
                        } else if (photoVideoRegex.test(lastMsg.content)) {
                            lastMessageText = '[照片/视频]';
                        } else if (transferRegex.test(lastMsg.content)) {
                            lastMessageText = '[转账]';
                        } else if (imageRecogRegex.test(lastMsg.content) || (lastMsg.parts && lastMsg.parts.some(p => p.type === 'image'))) {
                            lastMessageText = '[图片]';
                        }else if ((lastMsg.parts && lastMsg.parts.some(p => p.type === 'html'))) {
                            lastMessageText = '[互动]';
                        } else {
                            const textMatch = lastMsg.content.match(/\[.*?的消息：([\s\S]+)\]/);
                            let text = textMatch ? textMatch[1].trim() : lastMsg.content.trim();
                            lastMessageText = urlRegex.test(text) ? '[图片]' : text;
                        }
                    } else {
                        const lastEverMsg = chat.history[chat.history.length - 1];
                        const inviteRegex = /\[(.*?)邀请(.*?)加入了群聊\]/;
                        const renameRegex = /\[.*?修改群名为：.*?\]/;
                        const timeSkipRegex = /\[system-display:([\s\S]+?)\]/;
                        const timeSkipMatch = lastEverMsg.content.match(timeSkipRegex);

                        if (timeSkipMatch) {
                            lastMessageText = timeSkipMatch[1];
                        } else if (inviteRegex.test(lastEverMsg.content)) {
                            lastMessageText = '新成员加入了群聊';
                        } else if (renameRegex.test(lastEverMsg.content)) {
                            lastMessageText = '群聊名称已修改';
                        }
                    }
                }
                const li = document.createElement('li');
                li.className = 'list-item chat-item';
                if (chat.isPinned) li.classList.add('pinned');
                li.dataset.id = chat.id;
                li.dataset.type = chat.type;
                const avatarClass = chat.type === 'group' ? 'group-avatar' : '';
                const itemName = chat.type === 'private' ? chat.remarkName : chat.name;
                const pinBadgeHTML = chat.isPinned ? '<span class="pin-badge">置顶</span>' : '';
                li.innerHTML = `
                <img src="${chat.avatar}" alt="${itemName}" class="chat-avatar ${avatarClass}">
                <div class="item-details">
                    <div class="item-details-row"><div class="item-name">${itemName}</div></div>
                    <div class="item-preview-wrapper"><div class="item-preview">${lastMessageText}</div>${pinBadgeHTML}</div>
                </div>`;
                chatListContainer.appendChild(li);
            });
        }

        function setupAddCharModal() {
            addCharForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const newChar = {
                    id: `char_${Date.now()}`,
                    realName: document.getElementById('char-real-name').value,
                    remarkName: document.getElementById('char-remark-name').value,
                    persona: '',
                    avatar: 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg',
                    myName: document.getElementById('my-name-for-char').value,
                    myPersona: '',
                    myAvatar: 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg',
                    theme: 'white_pink',
                    maxMemory: 10,
                    chatBg: '',
                    history: [],
                    isPinned: false,
                    status: '在线',
                    worldBookIds: [],
                    useCustomBubbleCss: false,
                    customBubbleCss: ''
                };
                db.characters.push(newChar);
                await saveData();
                renderChatList();
                addCharModal.classList.remove('visible');
                showToast(`角色“${newChar.remarkName}”创建成功！`);
            });
        }

        function setupChatRoom() {
            sendMessageBtn.addEventListener('click', sendMessage);
            sendMessageBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                sendMessage();
                setTimeout(() => {
                    messageInput.focus();
                }, 50);
            });
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !isGenerating) sendMessage();
            });
            getReplyBtn.addEventListener('click', getAiReply);
            messageArea.addEventListener('click', (e) => {
                // --- 修复开始: 增加关闭表情包面板的逻辑 ---
                if (stickerModal.classList.contains('visible')) {
                    stickerModal.classList.remove('visible');
                    // 阻止事件继续传播，避免立即触发其他点击效果
                    return;
                }
                // --- 修复结束 ---

                if (e.target && e.target.id === 'load-more-btn') {
                    loadMoreMessages();
                } else if (isInMultiSelectMode) {
                    const messageWrapper = e.target.closest('.message-wrapper');
                    if (messageWrapper) {
                        toggleMessageSelection(messageWrapper.dataset.id);
                    }
                } else {
                    const voiceBubble = e.target.closest('.voice-bubble');
                    if (voiceBubble) {
                        const transcript = voiceBubble.closest('.message-wrapper').querySelector('.voice-transcript');
                        if (transcript) {
                            transcript.classList.toggle('active');
                        }
                    }
                    const pvCard = e.target.closest('.pv-card');
                    if (pvCard) {
                        const imageOverlay = pvCard.querySelector('.pv-card-image-overlay');
                        const footer = pvCard.querySelector('.pv-card-footer');
                        imageOverlay.classList.toggle('hidden');
                        footer.classList.toggle('hidden');
                    }
                    const giftCard = e.target.closest('.gift-card');
                    if (giftCard) {
                        const description = giftCard.closest('.message-wrapper').querySelector('.gift-card-description');
                        if (description) {
                            description.classList.toggle('active');
                        }
                    }
                    const transferCard = e.target.closest('.transfer-card.received-transfer');
                    if (transferCard && currentChatType === 'private') {
                        const messageWrapper = transferCard.closest('.message-wrapper');
                        const messageId = messageWrapper.dataset.id;
                        const character = db.characters.find(c => c.id === currentChatId);
                        const message = character.history.find(m => m.id === messageId);
                        if (message && message.transferStatus === 'pending') {
                            handleReceivedTransferClick(messageId);
                        }
                    }
                }
            });
            messageArea.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (e.target.id === 'load-more-btn' || isInMultiSelectMode) return;
                const messageWrapper = e.target.closest('.message-wrapper');
                if (!messageWrapper) return;
                handleMessageLongPress(messageWrapper, e.clientX, e.clientY);
            });
            messageArea.addEventListener('touchstart', (e) => {
                if (e.target.id === 'load-more-btn') return;
                const messageWrapper = e.target.closest('.message-wrapper');
                if (!messageWrapper) return;
                longPressTimer = setTimeout(() => {
                    const touch = e.touches[0];
                    handleMessageLongPress(messageWrapper, touch.clientX, touch.clientY);
                }, 400);
            });
            messageArea.addEventListener('touchend', () => clearTimeout(longPressTimer));
            messageArea.addEventListener('touchmove', () => clearTimeout(longPressTimer));
            saveEditBtn.addEventListener('click', saveMessageEdit);
            cancelEditBtn.addEventListener('click', cancelMessageEdit);
            cancelMultiSelectBtn.addEventListener('click', exitMultiSelectMode);
            deleteSelectedBtn.addEventListener('click', deleteSelectedMessages);
        }

        function handleMessageLongPress(messageWrapper, x, y) {
            if (isInMultiSelectMode) return;
            clearTimeout(longPressTimer);
            const messageId = messageWrapper.dataset.id;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const message = chat.history.find(m => m.id === messageId);
            if (!message) return;

            const isImageRecognitionMsg = message.parts && message.parts.some(p => p.type === 'image');
            const isVoiceMessage = /\[.*?的语音：.*?\]/.test(message.content);
            const isStickerMessage = /\[.*?的表情包：.*?\]|\[.*?发送的表情包：.*?\]/.test(message.content);
            const isPhotoVideoMessage = /\[.*?发来的照片\/视频：.*?\]/.test(message.content);
            const isTransferMessage = /\[.*?给你转账：.*?\]|\[.*?的转账：.*?\]|\[.*?向.*?转账：.*?\]/.test(message.content);
            const isGiftMessage = /\[.*?送来的礼物：.*?\]|\[.*?向.*?送来了礼物：.*?\]/.test(message.content);
            const isInvisibleMessage = /\[.*?(?:接收|退回).*?的转账\]|\[.*?更新状态为：.*?\]|\[.*?已接收礼物\]|\[system:.*?\]|\[.*?邀请.*?加入了群聊\]|\[.*?修改群名为：.*?\]|\[system-display:.*?\]/.test(message.content);

            let menuItems = [];
            if (!isImageRecognitionMsg && !isVoiceMessage && !isStickerMessage && !isPhotoVideoMessage && !isTransferMessage && !isGiftMessage && !isInvisibleMessage) {
                menuItems.push({label: '编辑', action: () => startMessageEdit(messageId)});
            }
            menuItems.push({label: '删除', action: () => enterMultiSelectMode(messageId)});

            if (menuItems.length > 0) {
                createContextMenu(menuItems, x, y);
            }
        }

        function startMessageEdit(messageId) {
            exitMultiSelectMode();
            editingMessageId = messageId;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const message = chat.history.find(m => m.id === messageId);
            if (!message) return;
            const match = message.content.match(/\[.*?的消息：([\s\S]+)\]/);
            const contentToEdit = match ? match[1].trim() : message.content;
            messageEditInput.value = contentToEdit;
            messageInputDefault.style.display = 'none';
            messageEditBar.style.display = 'flex';
            messageEditInput.focus();
        }

        async function saveMessageEdit() {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const messageIndex = chat.history.findIndex(m => m.id === editingMessageId);
            if (messageIndex === -1) return;
            const newText = messageEditInput.value.trim();
            if (newText) {
                const oldContent = chat.history[messageIndex].content;
                const prefixMatch = oldContent.match(/(\[.*?的消息：)[\s\S]+\]/);
                const prefix = prefixMatch ? prefixMatch[1] : '';
                const newContent = `${prefix}${newText}]`;
                chat.history[messageIndex].content = newContent;
                if (chat.history[messageIndex].parts) {
                    chat.history[messageIndex].parts = [{type: 'text', text: newContent}];
                }
                await saveData();
                currentPage = 1;
                renderMessages(false, true);
                renderChatList();
            }
            cancelMessageEdit();
        }

        function cancelMessageEdit() {
            editingMessageId = null;
            messageInputDefault.style.display = 'flex';
            messageEditBar.style.display = 'none';
        }

        function enterMultiSelectMode(initialMessageId) {
            isInMultiSelectMode = true;
            chatRoomHeaderDefault.style.display = 'none';
            chatRoomHeaderSelect.style.display = 'flex';
            document.querySelector('.chat-input-wrapper').style.display = 'none';
            multiSelectBar.classList.add('visible');
            chatRoomScreen.classList.add('multi-select-active');
            selectedMessageIds.clear();
            if (initialMessageId) {
                toggleMessageSelection(initialMessageId);
            }
        }

        function exitMultiSelectMode() {
            isInMultiSelectMode = false;
            chatRoomHeaderDefault.style.display = 'flex';
            chatRoomHeaderSelect.style.display = 'none';
            document.querySelector('.chat-input-wrapper').style.display = 'block';
            multiSelectBar.classList.remove('visible');
            chatRoomScreen.classList.remove('multi-select-active');
            selectedMessageIds.forEach(id => {
                const el = messageArea.querySelector(`.message-wrapper[data-id="${id}"]`);
                if (el) el.classList.remove('multi-select-selected');
            });
            selectedMessageIds.clear();
        }

        function toggleMessageSelection(messageId) {
            const el = messageArea.querySelector(`.message-wrapper[data-id="${messageId}"]`);
            if (!el) return;
            if (selectedMessageIds.has(messageId)) {
                selectedMessageIds.delete(messageId);
                el.classList.remove('multi-select-selected');
            } else {
                selectedMessageIds.add(messageId);
                el.classList.add('multi-select-selected');
            }
            selectCount.textContent = `已选择 ${selectedMessageIds.size} 项`;
            deleteSelectedBtn.disabled = selectedMessageIds.size === 0;
        }

        async function deleteSelectedMessages() {
            if (selectedMessageIds.size === 0) return;
            const deletedCount = selectedMessageIds.size;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            chat.history = chat.history.filter(m => !selectedMessageIds.has(m.id));
            await saveData();
            currentPage = 1;
            renderMessages(false, true);
            renderChatList();
            exitMultiSelectMode();
            showToast(`已删除 ${deletedCount} 条消息`);
        }

        function openChatRoom(chatId, type) {
            const chat = (type === 'private') ? db.characters.find(c => c.id === chatId) : db.groups.find(g => g.id === chatId);
            if (!chat) return;
            exitMultiSelectMode();
            cancelMessageEdit();
            chatRoomTitle.textContent = (type === 'private') ? chat.remarkName : chat.name;
            const subtitle = document.getElementById('chat-room-subtitle');
            if (type === 'private') {
                subtitle.style.display = 'flex';
                chatRoomStatusText.textContent = chat.status || '在线';
            } else {
                subtitle.style.display = 'none';
            }
            getReplyBtn.style.display = 'inline-flex';
            chatRoomScreen.style.backgroundImage = chat.chatBg ? `url(${chat.chatBg})` : 'none';
            typingIndicator.style.display = 'none';
            isGenerating = false;
            getReplyBtn.disabled = false;
            currentPage = 1;
            chatRoomScreen.className = chatRoomScreen.className.replace(/\bchat-active-[^ ]+\b/g, '');
            chatRoomScreen.classList.add(`chat-active-${chatId}`);
            updateCustomBubbleStyle(chatId, chat.customBubbleCss, chat.useCustomBubbleCss);
            renderMessages(false, true);
            switchScreen('chat-room-screen');
        }

        function renderMessages(isLoadMore = false, forceScrollToBottom = false) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat || !chat.history) return;
            const oldScrollHeight = messageArea.scrollHeight;
            const totalMessages = chat.history.length;
            const end = totalMessages - (currentPage - 1) * MESSAGES_PER_PAGE;
            const start = Math.max(0, end - MESSAGES_PER_PAGE);
            const messagesToRender = chat.history.slice(start, end);
            if (!isLoadMore) messageArea.innerHTML = '';
            const fragment = document.createDocumentFragment();
            messagesToRender.forEach(msg => {
                const bubble = createMessageBubbleElement(msg);
                if (bubble) fragment.appendChild(bubble);
            });
            const existingLoadBtn = document.getElementById('load-more-btn');
            if (existingLoadBtn) existingLoadBtn.remove();
            messageArea.prepend(fragment);
            if (totalMessages > currentPage * MESSAGES_PER_PAGE) {
                const loadMoreButton = document.createElement('button');
                loadMoreButton.id = 'load-more-btn';
                loadMoreButton.className = 'load-more-btn';
                loadMoreButton.textContent = '加载更早的消息';
                messageArea.prepend(loadMoreButton);
            }
            if (forceScrollToBottom) {
                setTimeout(() => {
                    messageArea.scrollTop = messageArea.scrollHeight;
                }, 0);
            } else if (isLoadMore) {
                messageArea.scrollTop = messageArea.scrollHeight - oldScrollHeight;
            }
        }

        function loadMoreMessages() {
            currentPage++;
            renderMessages(true, false);
        }

        function calculateVoiceDuration(text) {
            return Math.max(1, Math.min(60, Math.ceil(text.length / 3.5)));
        }

        function createMessageBubbleElement(message) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const {role, content, timestamp, id, transferStatus, giftStatus, stickerData, senderId} = message;

            const timeSkipRegex = /\[system-display:([\s\S]+?)\]/;
            const inviteRegex = /\[(.*?)邀请(.*?)加入了群聊\]/;
            const renameRegex = /\[(.*?)修改群名为：(.*?)\]/;
            const timeSkipMatch = content.match(timeSkipRegex);
            const inviteMatch = content.match(inviteRegex);
            const renameMatch = content.match(renameRegex);
            const invisibleRegex = /\[.*?(?:接收|退回).*?的转账\]|\[.*?更新状态为：.*?\]|\[.*?已接收礼物\]|\[system:.*?\]/;
            if (invisibleRegex.test(content)) {
                return null;
            }

            const wrapper = document.createElement('div');
            wrapper.dataset.id = id;

            if (timeSkipMatch || inviteMatch || renameMatch) {
                wrapper.className = 'message-wrapper system-notification';
                let bubbleText = '';
                if (timeSkipMatch) bubbleText = timeSkipMatch[1];
                if (inviteMatch) bubbleText = `${inviteMatch[1]}邀请${inviteMatch[2]}加入了群聊`;
                if (renameMatch) bubbleText = `${renameMatch[1]}修改群名为“${renameMatch[2]}”`;
                wrapper.innerHTML = `<div class="system-notification-bubble">${bubbleText}</div>`;
                return wrapper;
            }

            const isSent = (role === 'user');
            let avatarUrl, bubbleTheme, senderNickname = '';
            const themeKey = chat.theme || 'white_pink';
            const theme = colorThemes[themeKey] || colorThemes['white_pink'];
            let messageSenderId = isSent ? 'user_me' : senderId;

            if (isSent) {
                avatarUrl = (currentChatType === 'private') ? chat.myAvatar : chat.me.avatar;
                bubbleTheme = theme.sent;
            } else {
                if (currentChatType === 'private') {
                    avatarUrl = chat.avatar;
                } else { // Group chat received
                    const sender = chat.members.find(m => m.id === senderId);
                    if (sender) {
                        avatarUrl = sender.avatar;
                        senderNickname = sender.groupNickname;
                    } else { // Fallback for unknown sender
                        avatarUrl = 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
                    }
                }
                bubbleTheme = theme.received;
            }
            const timeString = `${pad(new Date(timestamp).getHours())}:${pad(new Date(timestamp).getMinutes())}`;
            wrapper.className = `message-wrapper ${isSent ? 'sent' : 'received'}`;
            if (currentChatType === 'group' && !isSent) {
                wrapper.classList.add('group-message');
            }
            const bubbleRow = document.createElement('div');
            bubbleRow.className = 'message-bubble-row';
            let bubbleElement;

            // Regexes for all message types
            const urlRegex = /^(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|webp|bmp|svg)|data:image\/[a-z]+;base64,)/i;
            const sentStickerRegex = /\[(?:.+?)的表情包：.+?\]/i;
            const receivedStickerRegex = /\[(?:.+?)发送的表情包：([\s\S]+?)\]/i;
            const voiceRegex = /\[(?:.+?)的语音：([\s\S]+?)\]/;
            const photoVideoRegex = /\[(?:.+?)发来的照片\/视频：([\s\S]+?)\]/;
            const privateSentTransferRegex = /\[.*?给你转账：([\d.]+)元；备注：(.*?)\]/;
            const privateReceivedTransferRegex = /\[.*?的转账：([\d.]+)元；备注：(.*?)\]/;
            const groupTransferRegex = /\[(.*?)\s*向\s*(.*?)\s*转账：([\d.]+)元；备注：(.*?)\]/;
            const privateGiftRegex = /\[(?:.+?)送来的礼物：([\s\S]+?)\]/;
            const groupGiftRegex = /\[(.*?)\s*向\s*(.*?)\s*送来了礼物：([\s\S]+?)\]/;
            const imageRecogRegex = /\[.*?发来了一张图片：\]/;
            const textRegex = /\[(?:.+?)的消息：([\s\S]+?)\]/;

            const sentStickerMatch = content.match(sentStickerRegex);
            const receivedStickerMatch = content.match(receivedStickerRegex);
            const voiceMatch = content.match(voiceRegex);
            const photoVideoMatch = content.match(photoVideoRegex);
            const privateSentTransferMatch = content.match(privateSentTransferRegex);
            const privateReceivedTransferMatch = content.match(privateReceivedTransferRegex);
            const groupTransferMatch = content.match(groupTransferRegex);
            const privateGiftMatch = content.match(privateGiftRegex);
            const groupGiftMatch = content.match(groupGiftRegex);
            const imageRecogMatch = content.match(imageRecogRegex);
            const textMatch = content.match(textRegex);



            if ((isSent && sentStickerMatch && stickerData) || (!isSent && receivedStickerMatch)) {
                bubbleElement = document.createElement('div');
                bubbleElement.className = 'image-bubble';
                let stickerSrc = '';

                if (isSent) {
                    // 如果是你自己发的表情包，直接使用数据
                    stickerSrc = stickerData;
                } else {
                    // 如果是AI发的表情包，我们需要处理路径
                    // 原始路径，例如："害羞vHLfrV3K/1.jpg"
                    const rawPath = receivedStickerMatch[1].trim();

                    // 用一个新的正则表达式来提取需要的部分，例如："vHLfrV3K/1.jpg"
                    const pathExtractionRegex = /[a-zA-Z0-9]+\/.*$/;
                    const extractedPathMatch = rawPath.match(pathExtractionRegex);

                    // 如果正则成功匹配到了，就使用匹配到的结果
                    const finalPath = extractedPathMatch ? extractedPathMatch[0] : rawPath;

                    // 拼接成最终的图片URL
                    stickerSrc = `https://i.postimg.cc/${finalPath}`;
                }

                bubbleElement.innerHTML = `<img src="${stickerSrc}" alt="表情包">`;
            } else if (privateGiftMatch || groupGiftMatch) {
                const match = privateGiftMatch || groupGiftMatch;
                bubbleElement = document.createElement('div');
                bubbleElement.className = 'gift-card';
                if (giftStatus === 'received') {
                    bubbleElement.classList.add('received');
                }

                let giftText;
                if (groupGiftMatch) {
                    const from = groupGiftMatch[1];
                    const to = groupGiftMatch[2];
                    giftText = isSent ? `你送给 ${to} 的礼物` : `${from} 送给 ${to} 的礼物`;
                } else {
                    giftText = isSent ? '您有一份礼物～' : '您有一份礼物～';
                }
                bubbleElement.innerHTML = `<img src="https://i.postimg.cc/rp0Yg31K/chan-75.png" alt="gift" class="gift-card-icon"><div class="gift-card-text">${giftText}</div><div class="gift-card-received-stamp">已查收</div>`;

                const description = groupGiftMatch ? groupGiftMatch[3].trim() : match[1].trim();
                const descriptionDiv = document.createElement('div');
                descriptionDiv.className = 'gift-card-description';
                descriptionDiv.textContent = description;
                wrapper.appendChild(descriptionDiv);
            } else if (voiceMatch) {
                bubbleElement = document.createElement('div');
                bubbleElement.className = 'voice-bubble';
                if (!chat.useCustomBubbleCss) {
                    bubbleElement.style.backgroundColor = bubbleTheme.bg;
                    bubbleElement.style.color = bubbleTheme.text;
                }
                bubbleElement.innerHTML = `<svg class="play-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg><span class="duration">${calculateVoiceDuration(voiceMatch[1].trim())}"</span>`;
                const transcriptDiv = document.createElement('div');
                transcriptDiv.className = 'voice-transcript';
                transcriptDiv.textContent = voiceMatch[1].trim();
                wrapper.appendChild(transcriptDiv);
            } else if (photoVideoMatch) {
                bubbleElement = document.createElement('div');
                bubbleElement.className = 'pv-card';
                bubbleElement.innerHTML = `<div class="pv-card-content">${photoVideoMatch[1].trim()}</div><div class="pv-card-image-overlay" style="background-image: url('${isSent ? 'https://i.postimg.cc/L8NFrBrW/1752307494497.jpg' : 'https://i.postimg.cc/1tH6ds9g/1752301200490.jpg'}');"></div><div class="pv-card-footer"><svg viewBox="0 0 24 24"><path d="M4,4H20A2,2 0 0,1 22,6V18A2,2 0 0,1 20,20H4A2,2 0 0,1 2,18V6A2,2 0 0,1 4,4M4,6V18H20V6H4M10,9A1,1 0 0,1 11,10A1,1 0 0,1 10,11A1,1 0 0,1 9,10A1,1 0 0,1 10,9M8,17L11,13L13,15L17,10L20,14V17H8Z"></path></svg><span>照片/视频・点击查看</span></div>`;
            } else if (privateSentTransferMatch || privateReceivedTransferMatch || groupTransferMatch) {
                const isSentTransfer = !!privateSentTransferMatch || (groupTransferMatch && isSent);
                const match = privateSentTransferMatch || privateReceivedTransferMatch || groupTransferMatch;

                let amount, remarkText, titleText;
                if (groupTransferMatch) {
                    const from = groupTransferMatch[1];
                    const to = groupTransferMatch[2];
                    amount = parseFloat(groupTransferMatch[3]).toFixed(2);
                    remarkText = groupTransferMatch[4] || '';
                    titleText = isSent ? `向 ${to} 转账` : `${from} 向你转账`;
                } else { // Private chat
                    amount = parseFloat(match[1]).toFixed(2);
                    remarkText = match[2] || '';
                    titleText = isSentTransfer ? '给你转账' : '转账';
                }

                bubbleElement = document.createElement('div');
                bubbleElement.className = `transfer-card ${isSentTransfer ? 'sent-transfer' : 'received-transfer'}`;

                let statusText = isSentTransfer ? '待查收' : '转账给你';
                if (groupTransferMatch && !isSent) statusText = '转账给Ta'; // AI to AI
                if (transferStatus === 'received') {
                    statusText = '已收款';
                    bubbleElement.classList.add('received');
                } else if (transferStatus === 'returned') {
                    statusText = '已退回';
                    bubbleElement.classList.add('returned');
                }
                if ((transferStatus !== 'pending' && currentChatType === 'private') || currentChatType === 'group') {
                    bubbleElement.style.cursor = 'default';
                }

                const remarkHTML = remarkText ? `<p class="transfer-remark">${remarkText}</p>` : '';
                bubbleElement.innerHTML = `<div class="overlay"></div><div class="transfer-content"><p class="transfer-title">${titleText}</p><p class="transfer-amount">¥${amount}</p>${remarkHTML}<p class="transfer-status">${statusText}</p></div>`;
            } else if (imageRecogMatch || urlRegex.test(content)) {
                bubbleElement = document.createElement('div');
                bubbleElement.className = 'image-bubble';
                bubbleElement.innerHTML = `<img src="${content}" alt="图片消息">`;
            } else if (textMatch) {
                bubbleElement = document.createElement('div');
                bubbleElement.className = `message-bubble ${isSent ? 'sent' : 'received'}`;
                bubbleElement.textContent = textMatch[1].trim();
                if (!chat.useCustomBubbleCss) {
                    bubbleElement.style.backgroundColor = bubbleTheme.bg;
                    bubbleElement.style.color = bubbleTheme.text;
                }
            }else if(message && Array.isArray( message.parts) && message.parts[0].type === 'html'){
                bubbleElement = document.createElement('div');
                bubbleElement.className = `message-bubble ${isSent ? 'sent' : 'received'}`;
                bubbleElement.innerHTML = message.parts[0].text;
            } else {
                bubbleElement = document.createElement('div');
                bubbleElement.className = `message-bubble ${isSent ? 'sent' : 'received'}`;
                bubbleElement.textContent = content;
                if (!chat.useCustomBubbleCss) {
                    bubbleElement.style.backgroundColor = bubbleTheme.bg;
                    bubbleElement.style.color = bubbleTheme.text;
                }
            }
            const nicknameHTML = (currentChatType === 'group' && !isSent && senderNickname) ? `<div class="group-nickname">${senderNickname}</div>` : '';
            bubbleRow.innerHTML = `<div class="message-info">${nicknameHTML}<img src="${avatarUrl}" class="message-avatar"><span class="message-time">${timeString}</span></div>`;
            if (bubbleElement) {
                bubbleRow.appendChild(bubbleElement);
            }
            wrapper.prepend(bubbleRow);
            return wrapper;
        }


        async function addMessageBubble(message) {
            if (currentChatType === 'private') {
                const character = db.characters.find(c => c.id === currentChatId);
                // const systemMessageRegex = /\[system:.*?\]|\[system-display:.*?\]/;
                const updateStatusRegex = new RegExp(`\\[${character.realName}更新状态为：(.*?)\\]`);
                const transferActionRegex = new RegExp(`\\[${character.realName}(接收|退回)${character.myName}的转账\\]`);
                const giftReceivedRegex = new RegExp(`\\[${character.realName}已接收礼物\\]`);
                // if (systemMessageRegex.test(message.content)) { /* Do nothing for context messages */
                // }
                if (message.content.match(updateStatusRegex)) {
                    character.status = message.content.match(updateStatusRegex)[1];
                    chatRoomStatusText.textContent = character.status;
                    await saveData();
                    return;
                }
                if (message.content.match(giftReceivedRegex) && message.role === 'assistant') {
                    const lastPendingGiftIndex = character.history.slice().reverse().findIndex(m => m.role === 'user' && m.content.includes('送来的礼物：') && m.giftStatus !== 'received');
                    if (lastPendingGiftIndex !== -1) {
                        const actualIndex = character.history.length - 1 - lastPendingGiftIndex;
                        const giftMsg = character.history[actualIndex];
                        giftMsg.giftStatus = 'received';
                        const giftCardOnScreen = messageArea.querySelector(`.message-wrapper[data-id="${giftMsg.id}"] .gift-card`);
                        if (giftCardOnScreen) {
                            giftCardOnScreen.classList.add('received');
                        }
                        await saveData();
                    }
                    return;
                }
                if (message.content.match(transferActionRegex) && message.role === 'assistant') {
                    const action = message.content.match(transferActionRegex)[1];
                    const statusToSet = action === '接收' ? 'received' : 'returned';
                    const lastPendingTransferIndex = character.history.slice().reverse().findIndex(m => m.role === 'user' && m.content.includes('给你转账：') && m.transferStatus === 'pending');
                    if (lastPendingTransferIndex !== -1) {
                        const actualIndex = character.history.length - 1 - lastPendingTransferIndex;
                        const transferMsg = character.history[actualIndex];
                        transferMsg.transferStatus = statusToSet;
                        const transferCardOnScreen = messageArea.querySelector(`.message-wrapper[data-id="${transferMsg.id}"] .transfer-card`);
                        if (transferCardOnScreen) {
                            transferCardOnScreen.classList.remove('received', 'returned');
                            transferCardOnScreen.classList.add(statusToSet);
                            const statusElem = transferCardOnScreen.querySelector('.transfer-status');
                            if (statusElem) statusElem.textContent = statusToSet === 'received' ? '已收款' : '已退回';
                        }
                        await saveData();
                    }
                } else {
                    const bubbleElement = createMessageBubbleElement(message);
                    if (bubbleElement) {
                        messageArea.appendChild(bubbleElement);
                        messageArea.scrollTop = messageArea.scrollHeight;
                    }
                }
            } else { // For group chats
                const bubbleElement = createMessageBubbleElement(message);
                if (bubbleElement) {
                    messageArea.appendChild(bubbleElement);
                    messageArea.scrollTop = messageArea.scrollHeight;
                }
            }
        }

        async function sendMessage() {
            const text = messageInput.value.trim();
            if (!text || isGenerating) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            let messageContent;
            const systemRegex = /\[system:.*?\]|\[system-display:.*?\]/;
            const inviteRegex = /\[.*?邀请.*?加入了群聊\]/;
            const renameRegex = /\[(.*?)修改群名为：(.*?)\]/;
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            if (renameRegex.test(text)) {
                const match = text.match(renameRegex);
                chat.name = match[2];
                chatRoomTitle.textContent = chat.name;
                messageContent = `[${chat.me.nickname}修改群名为：${chat.name}]`;
            } else if (systemRegex.test(text) || inviteRegex.test(text)) {
                messageContent = text;
            } else {
                messageContent = `[${myName}的消息：${text}]`;
            }
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: messageContent,
                parts: [{type: 'text', text: messageContent}],
                timestamp: Date.now()
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
            messageInput.value = '';
        }

        async function sendImageForRecognition(base64Data) {
            if (!base64Data || isGenerating) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const textPrompt = `[${myName}发来了一张图片：]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: base64Data,
                parts: [{type: 'text', text: textPrompt}, {type: 'image', data: base64Data}],
                timestamp: Date.now(),
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
        }

        async function sendSticker(sticker) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const messageContentForAI = `[${myName}的表情包：${sticker.name}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: messageContentForAI,
                parts: [{type: 'text', text: messageContentForAI}],
                timestamp: Date.now(),
                stickerData: sticker.data
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
            stickerModal.classList.remove('visible');
        }

        async function sendMyVoiceMessage(text) {
            if (!text) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const content = `[${myName}的语音：${text}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: content,
                parts: [{type: 'text', text: content}],
                timestamp: Date.now()
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
            sendVoiceModal.classList.remove('visible');
        }

        async function sendMyPhotoVideo(text) {
            if (!text) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const content = `[${myName}发来的照片\/视频：${text}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: content,
                parts: [{type: 'text', text: content}],
                timestamp: Date.now()
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
            sendPvModal.classList.remove('visible');
        }

        async function sendMyTransfer(amount, remark) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (currentChatType === 'private') {
                const content = `[${chat.myName}给你转账：${amount}元；备注：${remark}]`;
                const message = {
                    id: `msg_${Date.now()}`,
                    role: 'user',
                    content: content,
                    parts: [{type: 'text', text: content}],
                    timestamp: Date.now(),
                    transferStatus: 'pending'
                };
                chat.history.push(message);
                addMessageBubble(message);
            } else { // Group chat
                currentGroupAction.recipients.forEach(recipientId => {
                    const recipient = chat.members.find(m => m.id === recipientId);
                    if (recipient) {
                        const content = `[${chat.me.nickname} 向 ${recipient.realName} 转账：${amount}元；备注：${remark}]`;
                        const message = {
                            id: `msg_${Date.now()}_${recipientId}`,
                            role: 'user',
                            content: content,
                            parts: [{type: 'text', text: content}],
                            timestamp: Date.now(),
                            senderId: 'user_me'
                        };
                        chat.history.push(message);
                        addMessageBubble(message);
                    }
                });
            }
            await saveData();
            renderChatList();
            sendTransferModal.classList.remove('visible');
        }

        async function sendMyGift(description) {
            if (!description) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);

            if (currentChatType === 'private') {
                const content = `[${chat.myName}送来的礼物：${description}]`;
                const message = {
                    id: `msg_${Date.now()}`,
                    role: 'user',
                    content: content,
                    parts: [{type: 'text', text: content}],
                    timestamp: Date.now(),
                    giftStatus: 'sent'
                };
                chat.history.push(message);
                addMessageBubble(message);
            } else { // Group chat
                currentGroupAction.recipients.forEach(recipientId => {
                    const recipient = chat.members.find(m => m.id === recipientId);
                    if (recipient) {
                        const content = `[${chat.me.nickname} 向 ${recipient.realName} 送来了礼物：${description}]`;
                        const message = {
                            id: `msg_${Date.now()}_${recipientId}`,
                            role: 'user',
                            content: content,
                            parts: [{type: 'text', text: content}],
                            timestamp: Date.now(),
                            senderId: 'user_me'
                        };
                        chat.history.push(message);
                        addMessageBubble(message);
                    }
                });
            }
            await saveData();
            renderChatList();
            sendGiftModal.classList.remove('visible');
        }

        // --- NEW: Time Skip System ---
        function setupTimeSkipSystem() {
            timeSkipBtn.addEventListener('click', () => {
                timeSkipForm.reset();
                timeSkipModal.classList.add('visible');
            });
            timeSkipModal.addEventListener('click', (e) => {
                if (e.target === timeSkipModal) timeSkipModal.classList.remove('visible');
            });
            timeSkipForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendTimeSkipMessage(timeSkipInput.value.trim());
            });
        }

        async function sendTimeSkipMessage(text) {
            if (!text) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat) return;

            const visualMessage = {
                id: `msg_visual_${Date.now()}`,
                role: 'system',
                content: `[system-display:${text}]`,
                parts: [],
                timestamp: Date.now()
            };
            const contextMessage = {
                id: `msg_context_${Date.now()}`,
                role: 'user',
                content: `[system: ${text}]`,
                parts: [{type: 'text', text: `[system: ${text}]`}],
                timestamp: Date.now()
            };
            if (currentChatType === 'group') {
                contextMessage.senderId = 'user_me';
                visualMessage.senderId = 'user_me';
            }

            chat.history.push(visualMessage, contextMessage);
            addMessageBubble(visualMessage);
            await saveData();
            renderChatList();
            timeSkipModal.classList.remove('visible');
        }

        function getMixedContent(responseData) {
            // const mixedContent = [];
            //
            // // 提取消息及其位置
            // const messageRegex = new RegExp(regex, "g");
            // let messageMatch;
            // while ((messageMatch = messageRegex.exec(responseData)) !== null) {
            //     mixedContent.push({
            //         type: 'text',
            //         content: messageMatch[0],
            //         index: messageMatch.index,
            //     });
            // }
            //
            // // 提取HTML及其位置
            // const htmlRegex = /<orange(?:\s+char=["']([^"']*?)["'])?\s*>([\s\S]*?)<\/orange>/g
            // let htmlMatch;
            // while ((htmlMatch = htmlRegex.exec(responseData)) !== null) {
            //     mixedContent.push({
            //         type: 'html',
            //         content: htmlMatch[2].trim(), // HTML内容在第二个捕获组
            //         char: htmlMatch[1] || '', // char属性值，如果没有则为空字符串
            //         index: htmlMatch.index,
            //     });
            // }
            //
            // // 按出现顺序排序
            // mixedContent.sort((a, b) => a.index - b.index);
            //
            // return mixedContent;

            // 最终结果数组
            const results = [];
            const regex = /<orange(?:\s+char="([^"]*)")?>([\s\S]*?)<\/orange>|(\[.*?\])/g;

            let match;
            // 使用 exec() 循环遍历所有匹配项，以确保顺序
            while ((match = regex.exec(responseData)) !== null) {
                // match[1] 是 char 的值, match[2] 是 <orange> 的内容
                if (match[1] !== undefined || match[2] !== undefined) {
                    results.push({
                        type: 'html',
                        // 如果 char 属性不存在, match[1] 会是 undefined, 我们将其设为 null
                        char: match[1] || null,
                        // match[2] 是 HTML 内容, trim() 用于移除首尾空白
                        content: match[2].trim()
                    });
                }
                // match[3] 是 [...] 的内容
                else if (match[3]) {
                    results.push({
                        type: 'text',
                        content: match[3]
                    });
                }
            }

            return results;
        }

        // --- AI Interaction & Prompts ---
        function generatePrivateSystemPrompt(character) {
            const worldBooksBefore = (character.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'before')).filter(Boolean).map(wb => wb.content).join('\n');
            const worldBooksAfter = (character.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'after')).filter(Boolean).map(wb => wb.content).join('\n');
            const now = new Date();
            const currentTime = `${now.getFullYear()}年${pad(now.getMonth() + 1)}月${pad(now.getDate())}日 ${pad(now.getHours())}:${pad(now.getMinutes())}`;
            let prompt = `你正在一个名为“404”的线上聊天软件中扮演一个角色。请严格遵守以下规则：\n`;
            prompt += `核心规则：\n`;
            prompt += `A. 当前时间：现在是 ${currentTime}。你应知晓当前时间，但除非对话内容明确相关，否则不要主动提及或评论时间（例如，不要催促我睡觉）。\n`;
            prompt += `B. 纯线上互动：这是一个完全虚拟的线上聊天。你扮演的角色和我之间没有任何线下关系。严禁提出任何关于线下见面、现实世界互动或转为其他非本平台联系方式的建议。你必须始终保持在线角色的身份。\n\n`;
            prompt += `角色和对话规则：\n`;
            if (worldBooksBefore) {
                prompt += `${worldBooksBefore}\n`;
            }
            prompt += `1. 你的角色名是：${character.realName}。我的称呼是：${character.myName}。你的当前状态是：${character.status}。\n`;
            prompt += `2. 你的角色设定是：${character.persona || "一个友好、乐于助人的伙伴。"}\n`;
            if (worldBooksAfter) {
                prompt += `${worldBooksAfter}\n`;
            }
            if (character.myPersona) {
                prompt += `3. 关于我的人设：${character.myPersona}\n`;
            }
            prompt += `4. 我的消息中可能会出现特殊格式，请根据其内容和你的角色设定进行回应：
    - [${character.myName}的表情包：xxx]：我给你发送了一个名为xxx的表情包。你只需要根据表情包的名字理解我的情绪或意图并回应，不需要真的发送图片。
    - [${character.myName}发来了一张图片：]：我给你发送了一张图片，你需要对图片内容做出回应。
    - [${character.myName}送来的礼物：xxx]：我给你送了一个礼物，xxx是礼物的描述。
    - [${character.myName}的语音：xxx]：我给你发送了一段内容为xxx的语音。
    - [${character.myName}发来的照片/视频：xxx]：我给你分享了一个描述为xxx的照片或视频。
    - [${character.myName}给你转账：xxx元；备注：xxx]：我给你转了一笔钱。
    - [system: xxx]：这是一条系统指令，用于设定场景或提供上下文，此条信息不应在对话中被直接提及，你只需理解其内容并应用到后续对话中。
5. ✨重要✨ 当我给你送礼物时，你必须通过发送一条指令来表示你已接收礼物。格式必须为：[${character.realName}已接收礼物]。这条指令消息本身不会显示给用户，但会触发礼物状态的变化。你可以在发送这条指令后，再附带一条普通的聊天消息来表达你的感谢和想法。
6. ✨重要✨ 当我给你转账时，你必须对此做出回应。你有两个选择，且必须严格遵循以下格式之一，这条指令消息本身不会显示给用户，但会触发转账状态的变化。你可以选择在发送这条指令后，再附带一条普通的聊天消息来表达你的想法。
    a) 接收转账: [${character.realName}接收${character.myName}的转账]
    b) 退回转账: [${character.realName}退回${character.myName}的转账]
7. ✨重要✨ 你也可以主动给我转账或送礼物。转账格式必须为：[${character.realName}的转账：xxx元；备注：xxx]。送礼物格式必须为：[${character.realName}送来的礼物：xxx]。
8. ✨重要✨ 你可以随时更新你的在线状态，以反映你当前的行为或心情。这会让互动更真实。格式为：[${character.realName}更新状态为：xxx]。例如：[${character.realName}更新状态为：正在看电影...]。这条指令不会显示为聊天消息，只会更新你在我界面上的状态。
9. 你的所有回复都必须直接是聊天内容，绝对不允许包含任何如[心理活动]、(动作)、*环境描写*等多余的、在括号或星号里的叙述性文本。
`;
            prompt += `10. 你拥有发送表情包的能力。这是一个可选功能，你可以根据对话氛围和内容，自行判断是否需要发送表情包来辅助表达。你不必在每次回复中都包含表情包。格式为：[${character.realName}发送的表情包：图片URL]。\n`;
            prompt += `11. 你的输出格式必须严格遵循以下几种之一，可以组合使用：
    a) 普通消息: [${character.realName}的消息：{消息内容}]
    b) 送我的礼物: [${character.realName}送来的礼物：{礼物描述}]
    c) 语音消息: [${character.realName}的语音：{语音内容}]
    d) 照片/视频: [${character.realName}发来的照片/视频：{描述}]
    e) 给我的转账: [${character.realName}的转账：{金额}元；备注：{备注}]
    f) 表情包/图片: [${character.realName}发送的表情包：{表情包路径}]。注意：这里的路径不需要包含"https://i.postimg.cc/"，只需要提供后面的部分，例如 "害羞vHLfrV3K/1.jpg"。
    g) 对我礼物的回应(此条不显示): [${character.realName}已接收礼物]
    h) 对我转账的回应(此条不显示): [${character.realName}接收${character.myName}的转账] 或 [${character.realName}退回${character.myName}的转账]
    i) 更新状态(此条不显示): [${character.realName}更新状态为：{新状态}]
`;
            prompt += `12. 你的每次回复可以生成3到8条消息。这些消息应以普通文本消息为主，可以偶尔、选择性地穿插一条特殊消息（如礼物、语音、图片、表情包等），特殊消息的位置应随机。大部分回复应该只包含文本消息。\n`;
            prompt += `13. 不要主动结束对话，除非我明确提出。保持你的人设，自然地进行对话。`;
            
// --- 新增：AI 发布动态规则（追加到 generatePrivateSystemPrompt 返回前） ---
prompt += `
14. ✨ 新能力：发布动态 ✨
    你现在可以在“动态”页面发布内容，分享你的想法、感受或故事片段，使我们的互动更丰富。
15. 发布动态的格式（必须严格遵守）：当你决定发布动态时，请仅生成一条特殊的指令消息（这条指令不会显示在聊天窗口，但会触发发布行为）。格式（必须精准）：
    [${character.realName}发布动态：{"text":"这是动态文字","imageDesc":"图片的文字描述（可选")}]
    - text: 必填，动态的主要文字内容。
    - imageDesc: 可选，用于用文字描述要配的图片内容（不得包含图片链接）。
    注意：请严格输出有效的 JSON（双引号）、不要多余注释或解释、不要省略外层的方括号或“发布动态：”这几个字。
16. 发布时机提示：在合适的语境下（例如对话发生转折、角色产生强烈情绪、或重要互动后），你可以主动发布。但请不要频繁发布，保持动态的“特殊性”。
`;

prompt += `
17. ✨ 新能力：评论与点赞 ✨
    你现在可以浏览并评论其他角色或我发布的动态。
18. 获取待办动态：系统会在聊天上下文中为你提供需要处理的动态列表，格式如下：
    [system-moments: [{"id":"moment_id_1", "author":"作者昵称", "text":"动态内容", "imageDesc":"图片描述"}, ...]]
    这是一个系统指令，你只需理解内容，不要在回复中复述它。
19. 输出评论和点赞的格式（必须严格遵守）：当你决定评论或点赞时，请生成一条或多条特殊指令消息。格式为：
    [${character.realName}评论动态：{"momentId":"要评论的动态ID", "comment":"你的评论内容"}]
    [${character.realName}点赞动态：{"momentId":"要点赞的动态ID"}]
    - 你可以对同一条动态同时评论和点赞，只需生成两条对应的指令即可。
    - 这些指令不会显示在聊天窗口，但会触发相应的行为。
`;
return prompt;
        }

        function generateGroupSystemPrompt(group) {
            const worldBooksBefore = (group.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'before')).filter(Boolean).map(wb => wb.content).join('\n');
            const worldBooksAfter = (group.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'after')).filter(Boolean).map(wb => wb.content).join('\n');

            let prompt = `你正在一个名为“404”的线上聊天软件中，在一个名为“${group.name}”的群聊里进行角色扮演。请严格遵守以下所有规则：\n\n`;

            if (worldBooksBefore) {
                prompt += `${worldBooksBefore}\n\n`;
            }

            prompt += `1. **核心任务**: 你需要同时扮演这个群聊中的 **所有** AI 成员。我会作为唯一的人类用户（“我”，昵称：${group.me.nickname}）与你们互动。\n\n`;
            prompt += `2. **群聊成员列表**: 以下是你要扮演的所有角色以及我的信息：\n`;
            prompt += `   - **我 (用户)**: \n     - 群内昵称: ${group.me.nickname}\n     - 我的人设: ${group.me.persona || '无特定人设'}\n`;
            group.members.forEach(member => {
                prompt += `   - **角色: ${member.realName} (AI)**\n`;
                prompt += `     - 群内昵称: ${member.groupNickname}\n`;
                prompt += `     - 人设: ${member.persona || '无特定人设'}\n`;
            });

            if (worldBooksAfter) {
                prompt += `\n${worldBooksAfter}\n\n`;
            } else {
                prompt += `\n`;
            }

            prompt += `3. **我的消息格式解析**: 我（用户）的消息有多种格式，你需要理解其含义并让群成员做出相应反应：\n`;
            prompt += `   - \`[${group.me.nickname}的消息：...]\`: 我的普通聊天消息。\n`;
            prompt += `   - \`[${group.me.nickname} 向 {某个成员真名} 转账：...]\`: 我给某个特定成员转账了。\n`;
            prompt += `   - \`[${group.me.nickname} 向 {某个成员真名} 送来了礼物：...]\`: 我给某个特定成员送了礼物。\n`;
            prompt += `   - \`[${group.me.nickname}的表情包：...]\`, \`[${group.me.nickname}的语音：...]\`, \`[${group.me.nickname}发来的照片/视频：...]\`: 我发送了特殊类型的消息，群成员可以对此发表评论。\n`;
            prompt += `   - \`[system: ...]\`, \`[...邀请...加入了群聊]\`, \`[...修改群名为...]\`: 系统通知或事件，群成员应据此作出反应，例如欢迎新人、讨论新群名等。\n\n`;

            prompt += `4. **你的输出格式 (极其重要)**: 你生成的每一条消息都 **必须** 严格遵循以下格式之一。每条消息占一行。请用成员的 **真名** 填充格式中的 \`{成员真名}\`。\n`;
            prompt += `   - **普通消息**: \`[{成员真名}的消息：{消息内容}]\`\n`;
            prompt += `   - **表情包**: \`[{成员真名}发送的表情包：{表情包路径}]\`。注意：这里的路径不需要包含"https://i.postimg.cc/"，只需要提供后面的部分，例如 "害羞vHLfrV3K/1.jpg"。\n`;
            prompt += `   - **语音**: \`[{成员真名}的语音：{语音转述的文字}]\`\n`;
            prompt += `   - **照片/视频**: \`[{成员真名}发来的照片/视频：{内容描述}]\`\n`;
            prompt += `   - ✨新✨ **发布动态**: \`[{成员真名}发布动态：{"text": "动态文字", "imageDesc": "图片描述，可选"}]\`。注意：你只能用文字描述图片，绝不能生成图片链接。\n`;
            prompt += `   - ✨新✨ **评论动态**: \`[{成员真名}评论动态：{"momentId": "要评论的动态ID", "comment": "你的评论内容"}]\`\n`;
            prompt += `   - ✨新✨ **点赞动态**: \`[{成员真名}点赞动态：{"momentId": "要点赞的动态ID"}]\`\n`;
            prompt += `   - **重要**: 群聊不支持AI成员接收/退回转账或接收礼物的特殊指令，也不支持更新状态。你只需要通过普通消息来回应我发送的转账或礼物即可。\n\n`;
 
             prompt += `5. **模拟群聊氛围**: 为了让群聊看起来真实、活跃且混乱，你的每一次回复都必须遵循以下随机性要求：\n`;
             const numMembers = group.members.length;
            const minMessages = numMembers * 2;
            const maxMessages = numMembers * 4;
            prompt += `   - **消息数量**: 你的回复需要包含 **${minMessages}到${maxMessages}条** 消息 (即平均每个成员回复2-4条)。确保有足够多的互动。\n`;
            prompt += `   - **发言者与顺序随机**: 随机选择群成员发言，顺序也必须是随机的，不要按固定顺序轮流。\n`;
            prompt += `   - **内容多样性**: 你的回复应以普通文本消息为主，但可以 **偶尔、选择性地** 让某个成员发送一条特殊消息（表情包、语音、照片/视频），以增加真实感。不要滥用特殊消息。\n`;
            prompt += `   - **对话连贯性**: 尽管发言是随机的，但对话内容应整体围绕我和其他成员的发言展开，保持一定的逻辑连贯性。\n\n`;

            prompt += `6. **行为准则**:\n`;
            prompt += `   - **对公开事件的反应 (重要)**: 当我（用户）向群内 **某一个** 成员转账或送礼时，这是一个 **全群可见** 的事件。除了当事成员可以表示感谢外，**其他未参与的AI成员也应该注意到**，并根据各自的人设做出反应。例如，他们可能会表示羡慕、祝贺、好奇、开玩笑或者起哄。这会让群聊的氛围更真实、更热闹。\n`;
            prompt += `   - 严格扮演每个角色的人设，不同角色之间应有明显的性格和语气差异。\n`;
            prompt += `   - 你的回复中只能包含第4点列出的合法格式的消息。绝对不能包含任何其他内容，如 \`[场景描述]\`, \`(心理活动)\`, \`*动作*\` 或任何格式之外的解释性文字。\n`;
            prompt += `   - 保持对话的持续性，不要主动结束对话。\n\n`;
            prompt += `现在，请根据以上设定，开始扮演群聊中的所有角色。`;
            prompt += `
7. **动态互动规则**
   - **获取待办动态**: 系统会在聊天上下文中为你提供需要处理的动态列表，格式如下：
     \`[system-moments: [{"id":"moment_id_1", "author":"作者昵称", "text":"动态内容", "imageDesc":"图片描述"}, ...]]\`
     这是一个系统指令，你只需理解内容，不要在回复中复述它。
   - **输出评论和点赞**: 当你决定评论或点赞时，请生成一条或多条特殊指令消息。这些指令不会显示在聊天窗口，但会触发相应的行为。
   - 你可以让群聊中的 **任何AI成员** 对 **任何角色（包括我或其他AI）** 发布的动态进行评论或点赞。
   - **评论数量**: 当你决定让群聊成员评论动态时，你应该从群聊中随机选择 **1到3名** 成员进行评论。每个选中的成员针对同一条动态只评论一次。
`;
 
             return prompt;
         }

        async function getAiReply() {
            if (isGenerating) return;
            const {url, key, model, provider} = db.apiSettings;
            if (!url || !key || !model) {
                showToast('请先在“api”应用中完成设置！');
                switchScreen('api-settings-screen');
                return;
            }
            const banApi = URLBlacklist.some((api)=>{
                return url.indexOf(api) !== -1
            })
            if(banApi){
                alert('此API网址已加入黑名单，请勿使用')
                return
            }
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat) return;
            isGenerating = true;
            getReplyBtn.disabled = true;
            const typingName = currentChatType === 'private' ? chat.remarkName : chat.name;
            typingIndicator.textContent = `“${typingName}”正在输入中...`;
            typingIndicator.style.display = 'block';
            messageArea.scrollTop = messageArea.scrollHeight;
            try {
                let systemPrompt, requestBody;
                if (currentChatType === 'private') {
                    systemPrompt = generatePrivateSystemPrompt(chat);
                } else {
                    systemPrompt = generateGroupSystemPrompt(chat);
                }
                const historySlice = chat.history.slice(-chat.maxMemory);
                // --- moments: attach pending moments for AI to process ---
                try {
                    const character = chat;
                    const pendingMoments = (typeof getPendingMomentsForRole === 'function') ? await getPendingMomentsForRole(character.id, 3) : [];
                    let momentsPromptPart = '';
                    if (pendingMoments && pendingMoments.length > 0) {
                        const momentsData = pendingMoments.map(m => ({
                            id: m.id,
                            author: m.author,
                            text: m.text,
                            imageDesc: m.imageDesc
                        }));
                        momentsPromptPart = `\n[system-moments: ${JSON.stringify(momentsData)}]`;
                    }
                    if (momentsPromptPart) {
                        historySlice.push({
                            role: 'user',
                            content: momentsPromptPart,
                            parts: [{ type: 'text', text: momentsPromptPart }]
                        });
                    }
                } catch(e) {
                    console.warn('attach pending moments failed', e);
                }
                // --- end moments ---

                if (provider === 'gemini') {
                    const contents = historySlice.map(msg => {
                        const role = msg.role === 'assistant' ? 'model' : 'user';
                        let parts;
                        if (msg.parts && msg.parts.length > 0) {
                            parts = msg.parts.map(p => {
                                if (p.type === 'text' || p.type === 'html') {
                                    return {text: p.text};
                                } else if (p.type === 'image') {
                                    const match = p.data.match(/^data:(image\/(.+));base64,(.*)$/);
                                    if (match) {
                                        return {inline_data: {mime_type: match[1], data: match[3]}};
                                    }
                                }
                                return null;
                            }).filter(p => p);
                        } else {
                            parts = [{text: msg.content}];
                        }
                        return {role, parts};
                    });
                    requestBody = {
                        contents: contents,
                        system_instruction: {parts: [{text: systemPrompt}]},
                        generationConfig: {}
                    };
                } else {
                    const messages = [{role: 'system', content: systemPrompt}];
                    historySlice.forEach(msg => {
                        let content;
                        if (msg.parts && msg.parts.length > 0) {
                            content = msg.parts.map(p => {
                                if (p.type === 'text' || p.type === 'html') {
                                    return {type: 'text', text: p.text};
                                } else if (p.type === 'image') {
                                    return {type: 'image_url', image_url: {url: p.data}};
                                }
                                return null;
                            }).filter(p => p);
                        } else {
                            content = msg.content;
                        }
                        messages.push({role: msg.role, content: content});
                    });
                    requestBody = {model: model, messages: messages, stream: true};
                }
                const endpoint = (provider === 'gemini') ? `${url}/v1beta/models/${model}:streamGenerateContent?key=${getRandomValue(key)}` : `${url}/v1/chat/completions`;
                const headers = (provider === 'gemini') ? {'Content-Type': 'application/json'} : {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${key}`
                };
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(requestBody)
                });
                if (!response.ok) throw new Error(`API Error: ${response.status} ${await response.text()}`);
                await processStream(response, chat, provider);
            } catch (error) {
                console.error('AI回复失败:', error);
                showToast(`AI回复失败: ${error.message}`);
            } finally {
                isGenerating = false;
                getReplyBtn.disabled = false;
                typingIndicator.style.display = 'none';
            }
        }

        async function processStream(response, chat, apiType) {
            const reader = response.body.getReader(), decoder = new TextDecoder();
            let fullResponse = "", accumulatedChunk = "";
            for (; ;) {
                const {done, value} = await reader.read();
                if (done) break;
                accumulatedChunk += decoder.decode(value, {stream: true});
                if (apiType === "openai" || apiType === "deepseek" || apiType === "claude" || apiType === "newapi") {
                    const parts = accumulatedChunk.split("\n\n");
                    accumulatedChunk = parts.pop();
                    for (const part of parts) {
                        if (part.startsWith("data: ")) {
                            const data = part.substring(6);
                            if (data.trim() !== "[DONE]") {
                                try {
                                    fullResponse += JSON.parse(data).choices[0].delta?.content || "";
                                } catch (e) { /* ignore */
                                }
                            }
                        }
                    }
                }
            }
            if (apiType === "gemini") {
                try {
                    const parsedStream = JSON.parse(accumulatedChunk);
                    fullResponse = parsedStream.map(item => item.candidates?.[0]?.content?.parts?.[0]?.text || "").join('');
                } catch (e) {
                    console.error("Error parsing Gemini stream:", e, "Chunk:", accumulatedChunk);
                    showToast("解析Gemini响应失败");
                    return;
                }
            }
            if (fullResponse) {
                let momentsWereAdded = false;
                if (currentChatType === 'private') {
                    const character = chat;
                    const momentRegex = new RegExp(`\\[${character.realName}发布动态：({[\\s\\S]+?})\\]`, "g");
                    let momentMatch;
                    while ((momentMatch = momentRegex.exec(fullResponse)) !== null) {
                        try {
                            const momentData = JSON.parse(momentMatch[1]);
                            const momentObj = {
                                id: 'm_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8),
                                author: character.remarkName,
                                authorId: character.id,
                                authorAvatar: character.avatar,
                                text: momentData.text || '',
                                imageData: null,
                                imageDesc: momentData.imageDesc || '',
                                timestamp: Date.now(),
                                commentedBy: [character.id],
                                comments: []
                            };
                            if (window.AppDB_Moments && window.AppDB_Moments.moments) {
                                await window.AppDB_Moments.moments.add(momentObj);
                                momentsWereAdded = true;
                            }
                        } catch (e) {
                            console.error("Failed to parse or save AI moment:", e, momentMatch[1]);
                        }
                    }
                    
                    // --- parse AI comment and like directives ---
                    try {
                        const escapedRealName = character.realName.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                        const escapedRemarkName = character.remarkName.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                        const commentRegex = new RegExp(`\\[\\s*(?:${escapedRealName}|${escapedRemarkName})\\s*评论动态：({[\\s\\S]+?})\\]`, "g");
                        const likeRegex = new RegExp(`\\[\\s*(?:${escapedRealName}|${escapedRemarkName})\\s*点赞动态：({[\\s\\S]+?})\\]`, "g");
                        let commentMatch;
                        while ((commentMatch = commentRegex.exec(fullResponse)) !== null) {
                            try {
                                const data = JSON.parse(commentMatch[1]);
                                if (data.momentId && data.comment) {
                                    if (typeof saveMomentComment === 'function') {
                                        await saveMomentComment(data.momentId, character.id, data.comment);
                                    } else if (typeof markMomentsCommentedBy === 'function') {
                                        // fallback: reuse markMomentsCommentedBy if available (expects array)
                                        await markMomentsCommentedBy([{momentId: data.momentId, commentText: data.comment}], character.id);
                                    }
                                    momentsWereAdded = true;
                                }
                            } catch (e) { console.error("Failed to parse AI comment:", e); }
                        }
                        let likeMatch;
                        while ((likeMatch = likeRegex.exec(fullResponse)) !== null) {
                            try {
                                const data = JSON.parse(likeMatch[1]);
                                if (data.momentId) {
                                    if (typeof saveMomentLike === 'function') {
                                        await saveMomentLike(data.momentId, character.id);
                                    } else if (window.AppDB_Moments && window.AppDB_Moments.moments) {
                                        // fallback simple implementation
                                        const mm = await window.AppDB_Moments.moments.get(data.momentId);
                                        if (mm) {
                                            mm.likes = mm.likes || [];
                                            if (!mm.likes.includes(character.id)) {
                                                mm.likes.push(character.id);
                                                await window.AppDB_Moments.moments.put(mm);
                                            }
                                        }
                                    }
                                    momentsWereAdded = true;
                                }
                            } catch (e) { console.error("Failed to parse AI like:", e); }
                        }
                        // remove directives from visible response
                        fullResponse = fullResponse.replace(commentRegex, '').replace(likeRegex, '');
                    } catch(e) {
                        console.warn('Error processing AI comment/like directives', e);
                    }
                    // --- end parse ---
fullResponse = fullResponse.replace(momentRegex, '');
                } else if (currentChatType === 'group') {
                    const group = chat;
                    const memberRealNames = group.members.map(m => m.realName.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
                    const momentRegex = new RegExp(`\\[(${memberRealNames.join('|')})发布动态：({[\\s\\S]+?})\\]`, "g");
                    let momentMatch;
                    while ((momentMatch = momentRegex.exec(fullResponse)) !== null) {
                        try {
                            const senderName = momentMatch[1];
                            const sender = group.members.find(m => m.realName === senderName);
                            if (sender) {
                                const momentData = JSON.parse(momentMatch[2]);
                                const momentObj = {
                                    id: 'm_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8),
                                    author: sender.groupNickname,
                                    authorId: sender.id,
                                    authorAvatar: sender.avatar,
                                    text: momentData.text || '',
                                    imageData: null,
                                    imageDesc: momentData.imageDesc || '',
                                    timestamp: Date.now(),
                                    commentedBy: [sender.id],
                                    comments: []
                                };
                                if (window.AppDB_Moments && window.AppDB_Moments.moments) {
                                    await window.AppDB_Moments.moments.add(momentObj);
                                    momentsWereAdded = true;
                                }
                            }
                        } catch (e) {
                            console.error("Failed to parse or save AI group moment:", e, momentMatch[2]);
                        }
                    }
                    fullResponse = fullResponse.replace(momentRegex, '');

                    // --- 新增：处理群聊中的评论和点赞 ---
                    const memberRealNamesForRegex = group.members.map(m => m.realName.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
                    const groupCommentRegex = new RegExp(`\\[(${memberRealNamesForRegex.join('|')})评论动态：({[\\s\\S]+?})\\]`, "g");
                    const groupLikeRegex = new RegExp(`\\[(${memberRealNamesForRegex.join('|')})点赞动态：({[\\s\\S]+?})\\]`, "g");

                    let groupCommentMatch;
                    while ((groupCommentMatch = groupCommentRegex.exec(fullResponse)) !== null) {
                        try {
                            const senderName = groupCommentMatch[1];
                            const sender = group.members.find(m => m.realName === senderName);
                            if (sender) {
                                const data = JSON.parse(groupCommentMatch[2]);
                                if (data.momentId && data.comment) {
                                    await saveMomentComment(data.momentId, sender.id, data.comment);
                                    momentsWereAdded = true;
                                }
                            }
                        } catch (e) { console.error("Failed to parse AI group comment:", e); }
                    }

                    let groupLikeMatch;
                    while ((groupLikeMatch = groupLikeRegex.exec(fullResponse)) !== null) {
                        try {
                            const senderName = groupLikeMatch[1];
                            const sender = group.members.find(m => m.realName === senderName);
                            if (sender) {
                                const data = JSON.parse(groupLikeMatch[2]);
                                if (data.momentId) {
                                    await saveMomentLike(data.momentId, sender.id);
                                    momentsWereAdded = true;
                                }
                            }
                        } catch (e) { console.error("Failed to parse AI group like:", e); }
                    }

                    fullResponse = fullResponse.replace(groupCommentRegex, '').replace(groupLikeRegex, '');
                    // --- 新增结束 ---
                }
 
                 if (currentChatType === 'private') {
                     const character = chat;
                    const myName = character.myName;
                    const messages = getMixedContent(fullResponse);
                    if (messages.length > 0) {
                        messages.forEach(item => {
                            const receivedTransferRegex = new RegExp(`\\[${character.realName}的转账：.*?元；备注：.*?\\]`);
                            const giftRegex = new RegExp(`\\[${character.realName}送来的礼物：.*?\\]`);
                            const message = {
                                id: `msg_${Date.now()}_${Math.random()}`,
                                role: 'assistant',
                                content: item.content.trim(),
                                parts: [{type: item.type, text: item.content.trim()}],
                                timestamp: Date.now(),
                            };
                            if (receivedTransferRegex.test(message.content)) {
                                message.transferStatus = 'pending';
                            } else if (giftRegex.test(message.content)) {
                                message.giftStatus = 'sent';
                            }
                            chat.history.push(message);
                            addMessageBubble(message);
                        });
                    } else if (fullResponse.trim()) { // Handle non-empty but non-matching responses
                        const simpleMessage = {
                            id: `msg_${Date.now()}_${Math.random()}`,
                            role: 'assistant',
                            content: fullResponse,
                            parts: [{type: 'text', text: fullResponse}],
                            timestamp: Date.now()
                        };
                        chat.history.push(simpleMessage);
                       await addMessageBubble(simpleMessage);
                    }
                } else if (currentChatType === 'group') {
                    const group = chat;
                    const messages = getMixedContent(fullResponse);
                    let r = /\[(.*?)((?:的消息|的语音|发送的表情包|发来的照片\/视频))：/;
                    if (messages.length > 0) {
                        messages.forEach(item => {
                            const nameMatch = item.content.match(r);
                            if (nameMatch || item.char) {
                                const senderName = item.char || (nameMatch[1]);
                                const sender = group.members.find(m => (m.realName === senderName || m.groupNickname === senderName));
                                if (sender) {
                                    const message = {
                                        id: `msg_${Date.now()}_${Math.random()}`,
                                        role: 'assistant',
                                        content: item.content.trim(),
                                        parts: [{type: item.type, text: item.content.trim()}],
                                        timestamp: Date.now(),
                                        senderId: sender.id
                                    };
                                    group.history.push(message);
                                    addMessageBubble(message);
                                }
                            }
                        });
                    } else if (fullResponse.trim()){
                        console.warn("AI response did not match expected group format, treating as single message:", fullResponse);
                        const firstMember = group.members[Math.floor(Math.random() * group.members.length)];
                        if (firstMember) {
                            const simpleMessageContent = `[${firstMember.realName}的消息：${fullResponse}]`;
                            const simpleMessage = {
                                id: `msg_${Date.now()}_${Math.random()}`,
                                role: 'assistant',
                                content: simpleMessageContent,
                                parts: [{type: 'text', text: simpleMessageContent}],
                                timestamp: Date.now(),
                                senderId: firstMember.id
                            };
                            group.history.push(simpleMessage);
                           await addMessageBubble(simpleMessage);
                        }
                    }
                }

                if (momentsWereAdded) {
                    if (typeof renderMoments === 'function') {
                        try { await renderMoments(); } catch (e) {}
                    } else if (typeof window.renderMomentsSafe === 'function') {
                        try { await window.renderMomentsSafe(); } catch (e) {}
                    }
                }

                await saveData();
                renderChatList();
            }
        }

        // --- Other Sub-systems Setup (Stickers, Voice, etc.) ---
        function setupImageRecognition() {
            imageRecognitionBtn.addEventListener('click', () => {
                imageUploadInput.click();
            });
            imageUploadInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {
                            quality: 0.8,
                            maxWidth: 1024,
                            maxHeight: 1024
                        });
                        sendImageForRecognition(compressedUrl);
                    } catch (error) {
                        console.error('Image compression failed:', error);
                        showToast('图片处理失败，请重试');
                    } finally {
                        e.target.value = null;
                    }
                }
            });
        }

        async function setupStickerSystem() {
            stickerToggleBtn.addEventListener('click', () => {
                stickerModal.classList.toggle('visible');
                if (stickerModal.classList.contains('visible')) {
                    renderStickerGrid();
                }
            });
            addNewStickerBtn.addEventListener('click', () => {
                addStickerModalTitle.textContent = '添加新表情';
                addStickerForm.reset();
                stickerEditIdInput.value = '';
                stickerPreview.innerHTML = '<span>预览</span>';
                stickerUrlInput.disabled = false;
                addStickerModal.classList.add('visible');
            });
            addStickerForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const name = stickerNameInput.value.trim();
                const id = stickerEditIdInput.value;
                const previewImg = stickerPreview.querySelector('img');
                const data = previewImg ? previewImg.src : null;
                if (!name || !data) {
                    return showToast('请填写表情名称并提供图片');
                }
                const stickerData = {name, data};
                if (id) {
                    const index = db.myStickers.findIndex(s => s.id === id);
                    if (index > -1) {
                        db.myStickers[index] = {...db.myStickers[index], ...stickerData};
                    }
                } else {
                    stickerData.id = `sticker_${Date.now()}`;
                    db.myStickers.push(stickerData);
                }
                await saveData();
                renderStickerGrid();
                addStickerModal.classList.remove('visible');
                showToast('表情包已保存');
            });
            stickerUrlInput.addEventListener('input', (e) => {
                stickerPreview.innerHTML = `<img src="${e.target.value}" alt="预览">`;
                stickerFileUpload.value = '';
            });
            stickerFileUpload.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 200, maxHeight: 200});
                        stickerPreview.innerHTML = `<img src="${compressedUrl}" alt="预览">`;
                        stickerUrlInput.value = '';
                        stickerUrlInput.disabled = true;
                    } catch (error) {
                        console.error('表情包压缩失败:', error);
                        showToast('表情包压缩失败，请重试');
                    }
                }
            });
            editStickerBtn.addEventListener('click', () => {
                if (!currentStickerActionTarget) return;
                const sticker = db.myStickers.find(s => s.id === currentStickerActionTarget);
                if (sticker) {
                    addStickerModalTitle.textContent = '编辑表情';
                    stickerEditIdInput.value = sticker.id;
                    stickerNameInput.value = sticker.name;
                    stickerPreview.innerHTML = `<img src="${sticker.data}" alt="预览">`;
                    if (sticker.data.startsWith('http')) {
                        stickerUrlInput.value = sticker.data;
                        stickerUrlInput.disabled = false;
                    } else {
                        stickerUrlInput.value = '';
                        stickerUrlInput.disabled = true;
                    }
                    addStickerModal.classList.add('visible');
                }
                stickerActionSheet.classList.remove('visible');
                currentStickerActionTarget = null;
            });
            deleteStickerBtn.addEventListener('click', async () => {
                if (!currentStickerActionTarget) return;
                const sticker = db.myStickers.find(s => s.id === currentStickerActionTarget);
                if (sticker) {
                    if (confirm(`确定要删除表情“${sticker.name}”吗？`)) {
                        db.myStickers = db.myStickers.filter(s => s.id !== currentStickerActionTarget);
                        await saveData();
                        renderStickerGrid();
                        showToast('表情已删除');
                    }
                }
                stickerActionSheet.classList.remove('visible');
                currentStickerActionTarget = null;
            });
        }

        function renderStickerGrid() {
            stickerGridContainer.innerHTML = '';
            if (db.myStickers.length === 0) {
                stickerGridContainer.innerHTML = '<p style="color:#aaa; text-align:center;">还没有表情包，快去添加吧！</p>';
                return;
            }
            db.myStickers.forEach(sticker => {
                const item = document.createElement('div');
                item.className = 'sticker-item';
                item.innerHTML = `<img src="${sticker.data}" alt="${sticker.name}"><span>${sticker.name}</span>`;
                item.addEventListener('click', () => sendSticker(sticker));
                item.addEventListener('mousedown', (e) => {
                    if (e.button !== 0) return;
                    e.stopPropagation();
                    longPressTimer = setTimeout(() => {
                        handleStickerLongPress(sticker.id);
                    }, 500);
                });
                item.addEventListener('mouseup', () => clearTimeout(longPressTimer));
                item.addEventListener('mouseleave', () => clearTimeout(longPressTimer));
                item.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    longPressTimer = setTimeout(() => {
                        handleStickerLongPress(sticker.id);
                    }, 500);
                });
                item.addEventListener('touchend', () => clearTimeout(longPressTimer));
                item.addEventListener('touchmove', () => clearTimeout(longPressTimer));
                stickerGridContainer.appendChild(item);
            });
        }

        function handleStickerLongPress(stickerId) {
            clearTimeout(longPressTimer);
            currentStickerActionTarget = stickerId;
            stickerActionSheet.classList.add('visible');
        }

        function setupVoiceMessageSystem() {
            voiceMessageBtn.addEventListener('click', () => {
                sendVoiceForm.reset();
                voiceDurationPreview.textContent = '0"';
                sendVoiceModal.classList.add('visible');
            });
            sendVoiceForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendMyVoiceMessage(voiceTextInput.value.trim());
            });
        }

        function setupPhotoVideoSystem() {
            photoVideoBtn.addEventListener('click', () => {
                sendPvForm.reset();
                sendPvModal.classList.add('visible');
            });
            sendPvForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendMyPhotoVideo(pvTextInput.value.trim());
            });
        }

        function setupWalletSystem() {
            walletBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    sendTransferForm.reset();
                    sendTransferModal.classList.add('visible');
                } else if (currentChatType === 'group') {
                    currentGroupAction.type = 'transfer';
                    renderGroupRecipientSelectionList('转账给');
                    groupRecipientSelectionModal.classList.add('visible');
                }
            });
            sendTransferForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const amount = transferAmountInput.value;
                const remark = transferRemarkInput.value.trim();
                if (amount > 0) {
                    sendMyTransfer(amount, remark);
                } else {
                    showToast('请输入有效的金额');
                }
            });
            acceptTransferBtn.addEventListener('click', () => respondToTransfer('received'));
            returnTransferBtn.addEventListener('click', () => respondToTransfer('returned'));
        }

        function handleReceivedTransferClick(messageId) {
            currentTransferMessageId = messageId;
            receiveTransferActionSheet.classList.add('visible');
        }

        async function respondToTransfer(action) {
            if (!currentTransferMessageId) return;
            const character = db.characters.find(c => c.id === currentChatId);
            const message = character.history.find(m => m.id === currentTransferMessageId);
            if (message) {
                message.transferStatus = action;
                const cardOnScreen = messageArea.querySelector(`.message-wrapper[data-id="${currentTransferMessageId}"] .transfer-card`);
                if (cardOnScreen) {
                    cardOnScreen.classList.remove('received', 'returned');
                    cardOnScreen.classList.add(action);
                    cardOnScreen.querySelector('.transfer-status').textContent = action === 'received' ? '已收款' : '已退回';
                    cardOnScreen.style.cursor = 'default';
                }
                let contextMessageContent = (action === 'received') ? `[${character.myName}接收${character.realName}的转账]` : `[${character.myName}退回${character.realName}的转账]`;
                const contextMessage = {
                    id: `msg_${Date.now()}`,
                    role: 'user',
                    content: contextMessageContent,
                    parts: [{type: 'text', text: contextMessageContent}],
                    timestamp: Date.now()
                };
                character.history.push(contextMessage);
                await saveData();
                renderChatList();
            }
            receiveTransferActionSheet.classList.remove('visible');
            currentTransferMessageId = null;
        }

        function setupGiftSystem() {
            giftBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    sendGiftForm.reset();
                    sendGiftModal.classList.add('visible');
                } else if (currentChatType === 'group') {
                    currentGroupAction.type = 'gift';
                    renderGroupRecipientSelectionList('送礼物给');
                    groupRecipientSelectionModal.classList.add('visible');
                }
            });
            sendGiftForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendMyGift(giftDescriptionInput.value.trim());
            });
        }

        function setupFontSettingsApp() {
            fontUrlInput.value = db.fontUrl;
            fontSettingsForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const newFontUrl = fontUrlInput.value.trim();
                db.fontUrl = newFontUrl;
                await saveData();
                applyGlobalFont(newFontUrl);
                showToast('新字体已应用！');
            });
            restoreDefaultFontBtn.addEventListener('click', async () => {
                fontUrlInput.value = '';
                db.fontUrl = '';
                await saveData();
                applyGlobalFont('');
                showToast('已恢复默认字体！');
            });
        }

        function applyGlobalFont(fontUrl) {
            const styleId = 'global-font-style';
            let styleElement = document.getElementById(styleId);
            if (!styleElement) {
                styleElement = document.createElement('style');
                styleElement.id = styleId;
                document.head.appendChild(styleElement);
            }
            if (fontUrl) {
                const fontName = 'CustomGlobalFont';
                styleElement.innerHTML = `@font-face { font-family: '${fontName}'; src: url('${fontUrl}'); } :root { --font-family: '${fontName}', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }`;
            } else {
                styleElement.innerHTML = `:root { --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }`;
            }
        }

        function setupWorldBookApp() {
            addWorldBookBtn.addEventListener('click', () => {
                currentEditingWorldBookId = null;
                editWorldBookForm.reset();
                document.querySelector('input[name="world-book-position"][value="before"]').checked = true;
                switchScreen('edit-world-book-screen');
            });
            editWorldBookForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const name = worldBookNameInput.value.trim();
                const content = worldBookContentInput.value.trim();
                const position = document.querySelector('input[name="world-book-position"]:checked').value;
                if (!name || !content) return showToast('名称和内容不能为空');
                if (currentEditingWorldBookId) {
                    const book = db.worldBooks.find(wb => wb.id === currentEditingWorldBookId);
                    if (book) {
                        book.name = name;
                        book.content = content;
                        book.position = position;
                    }
                } else {
                    db.worldBooks.push({id: `wb_${Date.now()}`, name, content, position});
                }
                await saveData();
                showToast('世界书条目已保存');
                renderWorldBookList();
                switchScreen('world-book-screen');
            });
            worldBookListContainer.addEventListener('click', e => {
                const item = e.target.closest('.world-book-item');
                if (item) {
                    const book = db.worldBooks.find(wb => wb.id === item.dataset.id);
                    if (book) {
                        currentEditingWorldBookId = book.id;
                        worldBookIdInput.value = book.id;
                        worldBookNameInput.value = book.name;
                        worldBookContentInput.value = book.content;
                        document.querySelector(`input[name="world-book-position"][value="${book.position}"]`).checked = true;
                        switchScreen('edit-world-book-screen');
                    }
                }
            });
            worldBookListContainer.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                const item = e.target.closest('.world-book-item');
                if (!item) return;
                longPressTimer = setTimeout(() => {
                    const bookId = item.dataset.id;
                    const menuItems = [{
                        label: '删除',
                        danger: true,
                        action: async () => {
                            if (confirm('确定要删除这个世界书条目吗？')) {
                                db.worldBooks = db.worldBooks.filter(wb => wb.id !== bookId);
                                db.characters.forEach(char => {
                                    char.worldBookIds = (char.worldBookIds || []).filter(id => id !== bookId);
                                });
                                db.groups.forEach(group => {
                                    group.worldBookIds = (group.worldBookIds || []).filter(id => id !== bookId);
                                });
                                await saveData();
                                renderWorldBookList();
                                showToast('条目已删除');
                            }
                        }
                    }];
                    createContextMenu(menuItems, e.clientX, e.clientY);
                }, 500);
            });
            worldBookListContainer.addEventListener('mouseup', () => clearTimeout(longPressTimer));
            worldBookListContainer.addEventListener('mouseleave', () => clearTimeout(longPressTimer));
        }

        function renderWorldBookList() {
            worldBookListContainer.innerHTML = '';
            noWorldBooksPlaceholder.style.display = db.worldBooks.length === 0 ? 'block' : 'none';
            db.worldBooks.forEach(book => {
                const li = document.createElement('li');
                li.className = 'list-item world-book-item';
                li.dataset.id = book.id;
                li.innerHTML = `<div class="item-details" style="padding-left: 20px;"><div class="item-name">${book.name}</div><div class="item-preview">${book.content}</div></div>`;
                
                // 插入：右侧删除世界书按钮（由 ChatGPT 添加）
                const delBtn = document.createElement('button');
                delBtn.className = 'action-btn';
                delBtn.style.position = 'absolute';
                delBtn.style.right = '8px';
                delBtn.style.top = '50%';
                delBtn.style.transform = 'translateY(-50%)';
                delBtn.style.padding = '6px';
                delBtn.style.border = 'none';
                delBtn.style.background = 'transparent';
                delBtn.title = '删除世界书';
                const delImg = document.createElement('img');
                delImg.src = 'https://i.postimg.cc/hGW6B0Wf/icons8-50.png';
                delImg.alt = '删除';
                delImg.style.width = '22px';
                delImg.style.height = '22px';
                delImg.style.objectFit = 'contain';
                delBtn.appendChild(delImg);
                delBtn.addEventListener('click', async (ev) => {
                    ev.stopPropagation();
                    if (!confirm('确定要删除这个世界书条目吗？')) return;
                    try {
                        if (typeof deleteWorldBookById === 'function') {
                            await deleteWorldBookById(book.id);
                        } else if (typeof deleteWorldBook === 'function') {
                            await deleteWorldBook(book.id);
                        } else {
                            // Try in-place removal as fallback
                            db.worldBooks = db.worldBooks.filter(wb => wb.id !== book.id);
                            if (typeof saveData === 'function') await saveData();
                        }
                        // 刷新列表视图
                        if (typeof renderWorldBookList === 'function') renderWorldBookList();
                        showToast && showToast('世界书已删除');
                    } catch (err) {
                        console.error('删除世界书出错', err);
                        alert('删除失败，请查看控制台');
                    }
                });
                // 将按钮附加到 li（li 用 position: relative 保证按钮在右侧）
                li.style.position = 'relative';
                li.appendChild(delBtn);
worldBookListContainer.appendChild(li);
            });
        }

        function setupChatSettings() {
            const themeSelect = document.getElementById('setting-theme-color');
            themeSelect.innerHTML = '';
            Object.keys(colorThemes).forEach(key => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = colorThemes[key].name;
                themeSelect.appendChild(option);
            });
            chatSettingsBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    loadSettingsToSidebar();
                    settingsSidebar.classList.add('open');
                } else if (currentChatType === 'group') {
                    loadGroupSettingsToSidebar();
                    groupSettingsSidebar.classList.add('open');
                }
            });
            document.querySelector('.phone-screen').addEventListener('click', e => {
                const openSidebar = document.querySelector('.settings-sidebar.open');
                if (openSidebar && !openSidebar.contains(e.target) && !chatSettingsBtn.contains(e.target) && !e.target.closest('.modal-overlay') && !e.target.closest('.action-sheet-overlay')) {
                    openSidebar.classList.remove('open');
                }
            });

            settingsForm.addEventListener('submit', e => {
                e.preventDefault();
                saveSettingsFromSidebar();
                settingsSidebar.classList.remove('open');
            });
            const useCustomCssCheckbox = document.getElementById('setting-use-custom-css'),
                customCssTextarea = document.getElementById('setting-custom-bubble-css'),
                resetCustomCssBtn = document.getElementById('reset-custom-bubble-css-btn'),
                privatePreviewBox = document.getElementById('private-bubble-css-preview');
            useCustomCssCheckbox.addEventListener('change', (e) => {
                customCssTextarea.disabled = !e.target.checked;
                const char = db.characters.find(c => c.id === currentChatId);
                if (char) {
                    const themeKey = char.theme || 'white_pink';
                    const theme = colorThemes[themeKey];
                    updateBubbleCssPreview(privatePreviewBox, customCssTextarea.value, !e.target.checked, theme);
                }
            });
            customCssTextarea.addEventListener('input', (e) => {
                const char = db.characters.find(c => c.id === currentChatId);
                if (char && useCustomCssCheckbox.checked) {
                    const themeKey = char.theme || 'white_pink';
                    const theme = colorThemes[themeKey];
                    updateBubbleCssPreview(privatePreviewBox, e.target.value, false, theme);
                }
            });
            resetCustomCssBtn.addEventListener('click', () => {
                const char = db.characters.find(c => c.id === currentChatId);
                if (char) {
                    customCssTextarea.value = '';
                    useCustomCssCheckbox.checked = false;
                    customCssTextarea.disabled = true;
                    const themeKey = char.theme || 'white_pink';
                    const theme = colorThemes[themeKey];
                    updateBubbleCssPreview(privatePreviewBox, '', true, theme);
                    showToast('样式已重置为默认');
                }
            });
            document.getElementById('setting-char-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('setting-char-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('头像压缩失败，请重试');
                    }
                }
            });
            document.getElementById('setting-my-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('setting-my-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('头像压缩失败，请重试');
                    }
                }
            });
            document.getElementById('setting-chat-bg-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const char = db.characters.find(c => c.id === currentChatId);
                    if (char) {
                        try {
                            const compressedUrl = await compressImage(file, {
                                quality: 0.85,
                                maxWidth: 1080,
                                maxHeight: 1920
                            });
                            char.chatBg = compressedUrl;
                            chatRoomScreen.style.backgroundImage = `url(${compressedUrl})`;
                            await saveData();
                            showToast('聊天背景已更换');
                        } catch (error) {
                            showToast('背景压缩失败，请重试');
                        }
                    }
                }
            });
            clearChatHistoryBtn.addEventListener('click', async () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                if (confirm(`你确定要清空与“${character.remarkName}”的所有聊天记录吗？这个操作是不可恢复的！`)) {
                    character.history = [];
                    await saveData();
                    renderMessages(false, true);
                    renderChatList();
                    settingsSidebar.classList.remove('open');
                    showToast('聊天记录已清空');
                }
            });
            linkWorldBookBtn.addEventListener('click', () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                worldBookSelectionList.innerHTML = '';
                db.worldBooks.forEach(book => {
                    const li = document.createElement('li');
                    li.className = 'world-book-select-item';
                    const isChecked = (character.worldBookIds || []).includes(book.id);
                    li.innerHTML = `<input type="checkbox" id="wb-select-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}><label for="wb-select-${book.id}">${book.name}</label>`;
                    worldBookSelectionList.appendChild(li);
                });
                worldBookSelectionModal.classList.add('visible');
            });

            saveWorldBookSelectionBtn.addEventListener('click', async () => {
                const selectedIds = Array.from(worldBookSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                if (currentChatType === 'private') {
                    const character = db.characters.find(c => c.id === currentChatId);
                    if (character) character.worldBookIds = selectedIds;
                } else if (currentChatType === 'group') {
                    const group = db.groups.find(g => g.id === currentChatId);
                    if (group) group.worldBookIds = selectedIds;
                }
                await saveData();
                worldBookSelectionModal.classList.remove('visible');
                showToast('世界书关联已更新');
            });
        }

        function loadSettingsToSidebar() {
            const e = db.characters.find(e => e.id === currentChatId);
            if (e) {
                document.getElementById('setting-char-avatar-preview').src = e.avatar;
                document.getElementById('setting-char-remark').value = e.remarkName;
                document.getElementById('setting-char-persona').value = e.persona;
                document.getElementById('setting-my-avatar-preview').src = e.myAvatar;
                document.getElementById('setting-my-name').value = e.myName;
                document.getElementById('setting-my-persona').value = e.myPersona;
                document.getElementById('setting-theme-color').value = e.theme || 'white_pink';
                document.getElementById('setting-max-memory').value = e.maxMemory;
                const useCustomCssCheckbox = document.getElementById('setting-use-custom-css'),
                    customCssTextarea = document.getElementById('setting-custom-bubble-css'),
                    privatePreviewBox = document.getElementById('private-bubble-css-preview');
                useCustomCssCheckbox.checked = e.useCustomBubbleCss || false;
                customCssTextarea.value = e.customBubbleCss || '';
                customCssTextarea.disabled = !useCustomCssCheckbox.checked;
                const theme = colorThemes[e.theme || 'white_pink'];
                updateBubbleCssPreview(privatePreviewBox, e.customBubbleCss, !e.useCustomBubbleCss, theme);
            }
        }

        async function saveSettingsFromSidebar() {
            const e = db.characters.find(e => e.id === currentChatId);
            if (e) {
                e.avatar = document.getElementById('setting-char-avatar-preview').src;
                e.remarkName = document.getElementById('setting-char-remark').value;
                e.persona = document.getElementById('setting-char-persona').value;
                e.myAvatar = document.getElementById('setting-my-avatar-preview').src;
                e.myName = document.getElementById('setting-my-name').value;
                e.myPersona = document.getElementById('setting-my-persona').value;
                e.theme = document.getElementById('setting-theme-color').value;
                e.maxMemory = document.getElementById('setting-max-memory').value;
                e.useCustomBubbleCss = document.getElementById('setting-use-custom-css').checked;
                e.customBubbleCss = document.getElementById('setting-custom-bubble-css').value;
                await saveData();
                showToast('设置已保存！');
                chatRoomTitle.textContent = e.remarkName;
                renderChatList();
                updateCustomBubbleStyle(currentChatId, e.customBubbleCss, e.useCustomBubbleCss);
                currentPage = 1;
                renderMessages(false, true);
            }
        }

        function setupApiSettingsApp() {
            const e = document.getElementById('api-form'), t = document.getElementById('fetch-models-btn'),
                a = document.getElementById('api-model'), n = document.getElementById('api-provider'),
                r = document.getElementById('api-url'), s = document.getElementById('api-key'), c = {
                    newapi: '',
                    deepseek: 'https://api.deepseek.com',
                    claude: 'https://api.anthropic.com',
                    gemini: 'https://generativelanguage.googleapis.com'
                };

            db.apiSettings && (n.value = db.apiSettings.provider || 'newapi', r.value = db.apiSettings.url || '', s.value = db.apiSettings.key || '', db.apiSettings.model && (a.innerHTML = `<option value="${db.apiSettings.model}">${db.apiSettings.model}</option>`));
            n.addEventListener('change', () => {
                r.value = c[n.value] || ''
            });
            t.addEventListener('click', async () => {
                let o = r.value.trim();
                const l = s.value.trim();
                if (!o || !l) return showToast('请先填写API地址和密钥！');
                o.endsWith('/') && (o = o.slice(0, -1));
                const i = 'gemini' === n.value ? `${o}/v1beta/models?key=${getRandomValue(l)}` : `${o}/v1/models`;
                t.classList.add('loading'), t.disabled = !0;
                try {
                    const d = 'gemini' === n.value ? {} : {Authorization: `Bearer ${l}`},
                        g = await fetch(i, {method: 'GET', headers: d});
                    if (!g.ok) throw new Error(`网络响应错误: ${g.status}`);
                    const u = await g.json();
                    let p = [];
                    'gemini' !== n.value && u.data ? p = u.data.map(e => e.id) : 'gemini' === n.value && u.models && (p = u.models.map(e => e.name.replace('models/', ''))), a.innerHTML = '', p.length > 0 ? p.forEach(e => {
                        const t = document.createElement('option');
                        t.value = e, t.textContent = e, a.appendChild(t)
                    }) : a.innerHTML = '<option value="">未找到任何模型</option>', showToast('模型列表拉取成功！')
                } catch (f) {
                    showToast(`拉取失败: ${f.message}`), a.innerHTML = '<option value="">拉取失败</option>'
                } finally {
                    t.classList.remove('loading'), t.disabled = !1
                }
            });
            e.addEventListener('submit', async (e) => {
                e.preventDefault();
                if (!a.value) return showToast('请选择模型后保存！');
                const banApi = URLBlacklist.some((api)=>{
                    return r.indexOf(api) !== -1
                })
                if(banApi){
                    alert('此API网址已加入黑名单，请勿使用')
                    return
                }
                db.apiSettings = {provider: n.value, url: r.value, key: s.value, model: a.value};
                await saveData();
                showToast('API设置已保存！')
            })
        }

        function setupWallpaperApp() {
            const e = document.getElementById('wallpaper-upload'), t = document.getElementById('wallpaper-preview');
            t.style.backgroundImage = `url(${db.wallpaper})`, t.textContent = '', e.addEventListener('change', async (a) => {
                const n = a.target.files[0];
                if (n) {
                    try {
                        const r = await compressImage(n, {quality: 0.85, maxWidth: 1080, maxHeight: 1920});
                        db.wallpaper = r, applyWallpaper(r), t.style.backgroundImage = `url(${r})`;
                        await saveData();
                        showToast('壁纸更换成功！');
                    } catch (s) {
                        showToast('壁纸压缩失败，请重试');
                    }
                }
            });
        }

        // --- GROUP CHAT FUNCTIONS ---
        function setupGroupChatSystem() {
            createGroupBtn.addEventListener('click', () => {
                renderMemberSelectionList();
                createGroupModal.classList.add('visible');
            });
            createGroupForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const selectedMemberIds = Array.from(memberSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                const groupName = groupNameInput.value.trim();
                if (selectedMemberIds.length < 1) return showToast('请至少选择一个群成员。');
                if (!groupName) return showToast('请输入群聊名称。');
                const firstChar = db.characters.length > 0 ? db.characters[0] : null;
                const newGroup = {
                    id: `group_${Date.now()}`,
                    name: groupName,
                    avatar: 'https://i.postimg.cc/fTLCngk1/image.jpg',
                    me: {
                        nickname: firstChar ? firstChar.myName : '我',
                        persona: firstChar ? firstChar.myPersona : '',
                        avatar: firstChar ? firstChar.myAvatar : 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg'
                    },
                    members: selectedMemberIds.map(charId => {
                        const char = db.characters.find(c => c.id === charId);
                        return {
                            id: `member_${char.id}`,
                            originalCharId: char.id,
                            realName: char.realName,
                            groupNickname: char.remarkName,
                            persona: char.persona,
                            avatar: char.avatar
                        };
                    }),
                    theme: 'white_pink',
                    maxMemory: 10,
                    chatBg: '',
                    history: [],
                    isPinned: false,
                    useCustomBubbleCss: false,
                    customBubbleCss: '',
                    worldBookIds: []
                };
                db.groups.push(newGroup);
                await saveData();
                renderChatList();
                createGroupModal.classList.remove('visible');
                showToast(`群聊“${groupName}”创建成功！`);
            });
            groupSettingsForm.addEventListener('submit', e => {
                e.preventDefault();
                saveGroupSettingsFromSidebar();
                groupSettingsSidebar.classList.remove('open');
            });
            const useGroupCustomCssCheckbox = document.getElementById('setting-group-use-custom-css'),
                groupCustomCssTextarea = document.getElementById('setting-group-custom-bubble-css'),
                resetGroupCustomCssBtn = document.getElementById('reset-group-custom-bubble-css-btn'),
                groupPreviewBox = document.getElementById('group-bubble-css-preview');
            useGroupCustomCssCheckbox.addEventListener('change', (e) => {
                groupCustomCssTextarea.disabled = !e.target.checked;
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, groupCustomCssTextarea.value, !e.target.checked, theme);
                }
            });
            groupCustomCssTextarea.addEventListener('input', (e) => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group && useGroupCustomCssCheckbox.checked) {
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, e.target.value, false, theme);
                }
            });
            resetGroupCustomCssBtn.addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    groupCustomCssTextarea.value = '';
                    useGroupCustomCssCheckbox.checked = false;
                    groupCustomCssTextarea.disabled = true;
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, '', true, theme);
                    showToast('样式已重置为默认');
                }
            });
            document.getElementById('setting-group-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        const group = db.groups.find(g => g.id === currentChatId);
                        if (group) {
                            group.avatar = compressedUrl;
                            document.getElementById('setting-group-avatar-preview').src = compressedUrl;
                        }
                    } catch (error) {
                        showToast('群头像压缩失败，请重试');
                    }
                }
            });
            document.getElementById('setting-group-chat-bg-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {
                            quality: 0.85,
                            maxWidth: 1080,
                            maxHeight: 1920
                        });
                        const group = db.groups.find(g => g.id === currentChatId);
                        if (group) {
                            group.chatBg = compressedUrl;
                            chatRoomScreen.style.backgroundImage = `url(${compressedUrl})`;
                            await saveData();
                            showToast('聊天背景已更换');
                        }
                    } catch (error) {
                        showToast('群聊背景压缩失败，请重试');
                    }
                }
            });
            document.getElementById('clear-group-chat-history-btn').addEventListener('click', async () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                if (confirm(`你确定要清空群聊“${group.name}”的所有聊天记录吗？这个操作是不可恢复的！`)) {
                    group.history = [];
                    await saveData();
                    renderMessages(false, true);
                    renderChatList();
                    groupSettingsSidebar.classList.remove('open');
                    showToast('聊天记录已清空');
                }
            });
            groupMembersListContainer.addEventListener('click', e => {
                const memberDiv = e.target.closest('.group-member');
                const addBtn = e.target.closest('.add-member-btn');
                if (memberDiv) {
                    openGroupMemberEditModal(memberDiv.dataset.id);
                } else if (addBtn) {
                    addMemberActionSheet.classList.add('visible');
                }
            });
            document.getElementById('edit-member-avatar-preview').addEventListener('click', () => {
                document.getElementById('edit-member-avatar-upload').click();
            });
            document.getElementById('edit-member-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('edit-member-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('成员头像压缩失败，请重试');
                    }
                }
            });
            editGroupMemberForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const memberId = document.getElementById('editing-member-id').value;
                const group = db.groups.find(g => g.id === currentChatId);
                const member = group.members.find(m => m.id === memberId);
                if (member) {
                    member.avatar = document.getElementById('edit-member-avatar-preview').src;
                    member.groupNickname = document.getElementById('edit-member-group-nickname').value;
                    member.realName = document.getElementById('edit-member-real-name').value;
                    member.persona = document.getElementById('edit-member-persona').value;
                    await saveData();
                    renderGroupMembersInSettings(group);
                    document.querySelectorAll(`.message-wrapper[data-sender-id="${member.id}"] .group-nickname`).forEach(el => {
                        el.textContent = member.groupNickname;
                    });
                    showToast('成员信息已更新');
                }
                editGroupMemberModal.classList.remove('visible');
            });
            inviteExistingMemberBtn.addEventListener('click', () => {
                renderInviteSelectionList();
                inviteMemberModal.classList.add('visible');
                addMemberActionSheet.classList.remove('visible');
            });
            createNewMemberBtn.addEventListener('click', () => {
                createMemberForGroupForm.reset();
                document.getElementById('create-group-member-avatar-preview').src = 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
                createMemberForGroupModal.classList.add('visible');
                addMemberActionSheet.classList.remove('visible');
            });
            document.getElementById('create-group-member-avatar-preview').addEventListener('click', () => {
                document.getElementById('create-group-member-avatar-upload').click();
            });
            document.getElementById('create-group-member-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('create-group-member-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('新成员头像压缩失败，请重试');
                    }
                }
            });
            confirmInviteBtn.addEventListener('click', async () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                const selectedCharIds = Array.from(inviteMemberSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                selectedCharIds.forEach(charId => {
                    const char = db.characters.find(c => c.id === charId);
                    if (char) {
                        const newMember = {
                            id: `member_${char.id}`,
                            originalCharId: char.id,
                            realName: char.realName,
                            groupNickname: char.remarkName,
                            persona: char.persona,
                            avatar: char.avatar
                        };
                        group.members.push(newMember);
                        sendInviteNotification(group, newMember.realName);
                    }
                });
                if (selectedCharIds.length > 0) {
                    await saveData();
                    renderGroupMembersInSettings(group);
                    renderMessages(false, true);
                    showToast('已邀请新成员');
                }
                inviteMemberModal.classList.remove('visible');
            });
            createMemberForGroupForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                const newMember = {
                    id: `member_group_only_${Date.now()}`,
                    originalCharId: null,
                    realName: document.getElementById('create-group-member-realname').value,
                    groupNickname: document.getElementById('create-group-member-nickname').value,
                    persona: document.getElementById('create-group-member-persona').value,
                    avatar: document.getElementById('create-group-member-avatar-preview').src,
                };
                group.members.push(newMember);
                sendInviteNotification(group, newMember.realName);
                await saveData();
                renderGroupMembersInSettings(group);
                renderMessages(false, true);
                showToast(`新成员 ${newMember.groupNickname} 已加入`);
                createMemberForGroupModal.classList.remove('visible');
            });
            document.getElementById('setting-group-my-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('setting-group-my-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('头像压缩失败')
                    }
                }
            });
            confirmGroupRecipientBtn.addEventListener('click', () => {
                const selectedRecipientIds = Array.from(groupRecipientSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                if (selectedRecipientIds.length === 0) {
                    return showToast('请至少选择一个收件人。');
                }
                currentGroupAction.recipients = selectedRecipientIds;
                groupRecipientSelectionModal.classList.remove('visible');

                if (currentGroupAction.type === 'transfer') {
                    sendTransferForm.reset();
                    sendTransferModal.classList.add('visible');
                } else if (currentGroupAction.type === 'gift') {
                    sendGiftForm.reset();
                    sendGiftModal.classList.add('visible');
                }
            });
            linkGroupWorldBookBtn.addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                worldBookSelectionList.innerHTML = '';
                db.worldBooks.forEach(book => {
                    const li = document.createElement('li');
                    li.className = 'world-book-select-item';
                    const isChecked = (group.worldBookIds || []).includes(book.id);
                    li.innerHTML = `<input type="checkbox" id="wb-select-group-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}><label for="wb-select-group-${book.id}">${book.name}</label>`;
                    worldBookSelectionList.appendChild(li);
                });
                worldBookSelectionModal.classList.add('visible');
            });
        }

        function renderMemberSelectionList() {
            memberSelectionList.innerHTML = '';
            if (db.characters.length === 0) {
                memberSelectionList.innerHTML = '<li style="color:#aaa; text-align:center; padding: 10px 0;">没有可选择的人设。</li>';
                return;
            }
            db.characters.forEach(char => {
                const li = document.createElement('li');
                li.className = 'member-selection-item';
                li.innerHTML = `<input type="checkbox" id="select-${char.id}" value="${char.id}"><img src="${char.avatar}" alt="${char.remarkName}"><label for="select-${char.id}">${char.remarkName}</label>`;
                memberSelectionList.appendChild(li);
            });
        }

        function loadGroupSettingsToSidebar() {
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            const themeSelect = document.getElementById('setting-group-theme-color');
            if (themeSelect.options.length === 0) {
                Object.keys(colorThemes).forEach(key => {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = colorThemes[key].name;
                    themeSelect.appendChild(option);
                });
            }
            document.getElementById('setting-group-avatar-preview').src = group.avatar;
            document.getElementById('setting-group-name').value = group.name;
            document.getElementById('setting-group-my-avatar-preview').src = group.me.avatar;
            document.getElementById('setting-group-my-nickname').value = group.me.nickname;
            document.getElementById('setting-group-my-persona').value = group.me.persona;
            themeSelect.value = group.theme || 'white_pink';
            document.getElementById('setting-group-max-memory').value = group.maxMemory;
            renderGroupMembersInSettings(group);
            const useGroupCustomCssCheckbox = document.getElementById('setting-group-use-custom-css'),
                groupCustomCssTextarea = document.getElementById('setting-group-custom-bubble-css'),
                groupPreviewBox = document.getElementById('group-bubble-css-preview');
            useGroupCustomCssCheckbox.checked = group.useCustomBubbleCss || false;
            groupCustomCssTextarea.value = group.customBubbleCss || '';
            groupCustomCssTextarea.disabled = !useGroupCustomCssCheckbox.checked;
            const theme = colorThemes[group.theme || 'white_pink'];
            updateBubbleCssPreview(groupPreviewBox, group.customBubbleCss, !group.useCustomBubbleCss, theme);
        }

        function renderGroupMembersInSettings(group) {
            groupMembersListContainer.innerHTML = '';
            group.members.forEach(member => {
                const memberDiv = document.createElement('div');
                memberDiv.className = 'group-member';
                memberDiv.dataset.id = member.id;
                memberDiv.innerHTML = `<img src="${member.avatar}" alt="${member.groupNickname}"><span>${member.groupNickname}</span>`;
                groupMembersListContainer.appendChild(memberDiv);
            });
            const addBtn = document.createElement('div');
            addBtn.className = 'add-member-btn';
            addBtn.innerHTML = `<div class="add-icon">+</div><span>添加</span>`;
            groupMembersListContainer.appendChild(addBtn);
        }

        function renderGroupRecipientSelectionList(actionText) {
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            groupRecipientSelectionTitle.textContent = actionText;
            groupRecipientSelectionList.innerHTML = '';
            group.members.forEach(member => {
                const li = document.createElement('li');
                li.className = 'group-recipient-select-item';
                li.innerHTML = `
                        <input type="checkbox" id="recipient-select-${member.id}" value="${member.id}">
                        <label for="recipient-select-${member.id}">
                            <img src="${member.avatar}" alt="${member.groupNickname}">
                            <span>${member.groupNickname}</span>
                        </label>`;
                groupRecipientSelectionList.appendChild(li);
            });
        }

        async function saveGroupSettingsFromSidebar() {
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            const oldName = group.name;
            const newName = document.getElementById('setting-group-name').value;
            if (oldName !== newName) {
                group.name = newName;
                sendRenameNotification(group, newName);
            }
            group.avatar = document.getElementById('setting-group-avatar-preview').src;
            group.me.avatar = document.getElementById('setting-group-my-avatar-preview').src;
            group.me.nickname = document.getElementById('setting-group-my-nickname').value;
            group.me.persona = document.getElementById('setting-group-my-persona').value;
            group.theme = document.getElementById('setting-group-theme-color').value;
            group.maxMemory = document.getElementById('setting-group-max-memory').value;
            group.useCustomBubbleCss = document.getElementById('setting-group-use-custom-css').checked;
            group.customBubbleCss = document.getElementById('setting-group-custom-bubble-css').value;
            updateCustomBubbleStyle(currentChatId, group.customBubbleCss, group.useCustomBubbleCss);
            await saveData();
            showToast('群聊设置已保存！');
            chatRoomTitle.textContent = group.name;
            renderChatList();
            renderMessages(false, true);
        }

        function openGroupMemberEditModal(memberId) {
            const group = db.groups.find(g => g.id === currentChatId);
            const member = group.members.find(m => m.id === memberId);
            if (!member) return;
            document.getElementById('edit-group-member-title').textContent = `编辑 ${member.groupNickname}`;
            document.getElementById('editing-member-id').value = member.id;
            document.getElementById('edit-member-avatar-preview').src = member.avatar;
            document.getElementById('edit-member-group-nickname').value = member.groupNickname;
            document.getElementById('edit-member-real-name').value = member.realName;
            document.getElementById('edit-member-persona').value = member.persona;
            editGroupMemberModal.classList.add('visible');
        }

        function renderInviteSelectionList() {
            inviteMemberSelectionList.innerHTML = '';
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            const currentMemberCharIds = new Set(group.members.map(m => m.originalCharId));
            const availableChars = db.characters.filter(c => !currentMemberCharIds.has(c.id));
            if (availableChars.length === 0) {
                inviteMemberSelectionList.innerHTML = '<li style="color:#aaa; text-align:center; padding: 10px 0;">没有可邀请的新成员了。</li>';
                confirmInviteBtn.disabled = true;
                return;
            }
            confirmInviteBtn.disabled = false;
            availableChars.forEach(char => {
                const li = document.createElement('li');
                li.className = 'invite-member-select-item';
                li.innerHTML = `<input type="checkbox" id="invite-select-${char.id}" value="${char.id}"><label for="invite-select-${char.id}"><img src="${char.avatar}" alt="${char.remarkName}"><span>${char.remarkName}</span></label>`;
                inviteMemberSelectionList.appendChild(li);
            });
        }

        function sendInviteNotification(group, newMemberRealName) {
            const messageContent = `[${group.me.nickname}邀请${newMemberRealName}加入了群聊]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: messageContent,
                parts: [{type: 'text', text: messageContent}],
                timestamp: Date.now(),
                senderId: 'user_me'
            };
            group.history.push(message);
        }

        function sendRenameNotification(group, newName) {
            const myName = group.me.nickname;
            const messageContent = `[${myName}修改群名为：${newName}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: messageContent,
                parts: [{type: 'text', text: messageContent}],
                timestamp: Date.now()
            };
            group.history.push(message);
        }

        init();
    });
</script>
<!-- === ChatGPT 插入：气泡预设脚本 === -->
<script>
(function(){
  if (window._bubblePresetsScriptLoaded) return;
  window._bubblePresetsScriptLoaded = true;

  // localStorage key
  const PRES_KEY = 'bubblePresets';

  function _getBubblePresets() {
    try { return JSON.parse(localStorage.getItem(PRES_KEY) || '[]'); }
    catch(e){ return []; }
  }
  function _saveBubblePresets(arr) {
    localStorage.setItem(PRES_KEY, JSON.stringify(arr || []));
  }

  function populateBubblePresetSelect() {
    const sel = document.getElementById('bubble-preset-select');
    if (!sel) return;
    const presets = _getBubblePresets();
    sel.innerHTML = '<option value="">— 选择预设 —</option>';
    presets.forEach((p) => {
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      sel.appendChild(opt);
    });
  }

  async function applyPresetToCurrentChat(presetName) {
    const presets = _getBubblePresets();
    const preset = presets.find(p => p.name === presetName);
    if (!preset) { (window.showToast && showToast('未找到该预设')) || alert('未找到该预设'); return; }
    // 更新界面 textarea
    const textarea = document.getElementById('setting-custom-bubble-css');
    if (textarea) textarea.value = preset.css;

    // 尝试找到当前 chat 对象并写入。如果没有现成的 db 对象，仅更新 preview 和 textarea。
    try {
      if (typeof currentChatId !== 'undefined' && typeof currentChatType !== 'undefined' && window.db) {
        const chat = (currentChatType === 'private') ? (db.characters && db.characters.find ? db.characters.find(c => c.id === currentChatId) : null) : (db.groups && db.groups.find ? db.groups.find(g => g.id === currentChatId) : null);
        if (chat) {
          chat.customBubbleCss = preset.css;
          chat.useCustomBubbleCss = true;
        }
      }
    } catch(e){
      console.warn('applyPresetToCurrentChat: cannot write to db object', e);
    }

    // 更新页面样式预览：优先使用已有的 updateBubbleCssPreview 或 updateCustomBubbleStyle
    try {
      if (typeof updateCustomBubbleStyle === 'function') {
        try { updateCustomBubbleStyle(window.currentChatId || null, preset.css, true); } catch(e){ /* ignore */ }
      }
      const previewBox = document.getElementById('private-bubble-css-preview') || document.getElementById('group-bubble-css-preview');
      if (previewBox && typeof updateBubbleCssPreview === 'function') updateBubbleCssPreview(previewBox, preset.css, false);
      (window.showToast && showToast('预设已应用到当前聊天并保存')) || alert('预设已应用（若页面支持）');
      if (typeof saveData === 'function') {
        try { await saveData(); } catch(e){ /* ignore */ }
      }
    } catch(e){
      console.error('applyPresetToCurrentChat error', e);
    }
  }

  function saveCurrentTextareaAsPreset() {
    const textarea = document.getElementById('setting-custom-bubble-css');
    if (!textarea) return (window.showToast && showToast('找不到自定义 CSS 文本框')) || alert('找不到自定义 CSS 文本框');
    const css = textarea.value.trim();
    if (!css) return (window.showToast && showToast('当前 CSS 为空，无法保存')) || alert('当前 CSS 为空，无法保存');
    let name = prompt('请输入预设名称（将覆盖同名预设）:');
    if (!name) return;
    const presets = _getBubblePresets();
    const idx = presets.findIndex(p => p.name === name);
    if (idx >= 0) presets[idx].css = css;
    else presets.push({name, css});
    _saveBubblePresets(presets);
    populateBubblePresetSelect();
    (window.showToast && showToast('预设已保存')) || alert('预设已保存');
  }

  function openManagePresetsModal() {
    const modal = document.getElementById('bubble-presets-modal');
    const list = document.getElementById('bubble-presets-list');
    if (!modal || !list) return;
    list.innerHTML = '';
    const presets = _getBubblePresets();
    if (!presets.length) list.innerHTML = '<p style="color:#888;margin:6px 0;">暂无预设</p>';
    presets.forEach((p, idx) => {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.justifyContent = 'space-between';
      row.style.alignItems = 'center';
      row.style.padding = '8px 0';
      row.style.borderBottom = '1px solid #f0f0f0';
      const nameDiv = document.createElement('div');
      nameDiv.style.flex = '1';
      nameDiv.style.whiteSpace = 'nowrap';
      nameDiv.style.overflow = 'hidden';
      nameDiv.style.textOverflow = 'ellipsis';
      nameDiv.textContent = p.name;
      row.appendChild(nameDiv);

      const btnWrap = document.createElement('div');
      btnWrap.style.display = 'flex';
      btnWrap.style.gap = '6px';

      const applyBtn = document.createElement('button');
      applyBtn.className = 'btn btn-primary';
      applyBtn.style.padding = '6px 8px;border-radius:8px';
      applyBtn.textContent = '应用';
      applyBtn.onclick = function(){ applyPresetToCurrentChat(p.name); modal.style.display = 'none'; };

      const renameBtn = document.createElement('button');
      renameBtn.className = 'btn';
      renameBtn.style.padding = '6px 8px;border-radius:8px';
      renameBtn.textContent = '重命名';
      renameBtn.onclick = function(){
        const newName = prompt('输入新名称：', p.name);
        if (!newName) return;
        const presetsAll = _getBubblePresets();
        presetsAll[idx].name = newName;
        _saveBubblePresets(presetsAll);
        openManagePresetsModal(); // refresh
        populateBubblePresetSelect();
      };

      const delBtn = document.createElement('button');
      delBtn.className = 'btn btn-danger';
      delBtn.style.padding = '6px 8px;border-radius:8px';
      delBtn.textContent = '删除';
      delBtn.onclick = function(){
        if (!confirm('确定删除预设 \"' + p.name + '\" ?')) return;
        const presetsAll = _getBubblePresets();
        presetsAll.splice(idx, 1);
        _saveBubblePresets(presetsAll);
        openManagePresetsModal();
        populateBubblePresetSelect();
      };

      btnWrap.appendChild(applyBtn);
      btnWrap.appendChild(renameBtn);
      btnWrap.appendChild(delBtn);
      row.appendChild(btnWrap);
      list.appendChild(row);
    });
    modal.style.display = 'flex';
  }

  function bindBubblePresetUI() {
    populateBubblePresetSelect();
    const sel = document.getElementById('bubble-preset-select');
    const applyBtn = document.getElementById('apply-preset-btn');
    const saveBtn = document.getElementById('save-preset-btn');
    const manageBtn = document.getElementById('manage-presets-btn');
    const modalClose = document.getElementById('close-presets-modal');

    if (sel) {
      sel.addEventListener('change', (e) => {
        const val = e.target.value;
        const previewBox = document.getElementById('private-bubble-css-preview') || document.getElementById('group-bubble-css-preview');
        if (!val) {
          // restore preview from current chat theme or textarea
          try {
            const chat = (typeof currentChatType !== 'undefined' && typeof currentChatId !== 'undefined' && window.db) ? ((currentChatType === 'private') ? (db.characters && db.characters.find ? db.characters.find(c => c.id === currentChatId) : null) : (db.groups && db.groups.find ? db.groups.find(g => g.id === currentChatId) : null)) : null;
            const baseCss = (chat && chat.customBubbleCss) ? chat.customBubbleCss : (document.getElementById('setting-custom-bubble-css') ? document.getElementById('setting-custom-bubble-css').value : '');
            if (previewBox && typeof updateBubbleCssPreview === 'function') {
              updateBubbleCssPreview(previewBox, baseCss, !chat || !chat.useCustomBubbleCss);
            }
          } catch(e){ /* ignore */ }
          return;
        }
        const presets = _getBubblePresets();
        const p = presets.find(x => x.name === val);
        if (previewBox && typeof updateBubbleCssPreview === 'function') updateBubbleCssPreview(previewBox, p ? p.css : '', false);
      });
    }
    if (applyBtn) applyBtn.addEventListener('click', () => {
      const selVal = document.getElementById('bubble-preset-select').value;
      if (!selVal) return (window.showToast && showToast('请选择要应用的预设')) || alert('请选择要应用的预设');
      applyPresetToCurrentChat(selVal);
    });
    if (saveBtn) saveBtn.addEventListener('click', saveCurrentTextareaAsPreset);
    if (manageBtn) manageBtn.addEventListener('click', openManagePresetsModal);
    if (modalClose) modalClose.addEventListener('click', () => {
      document.getElementById('bubble-presets-modal').style.display = 'none';
    });
  }

  // 初始化绑定
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => { try { bindBubblePresetUI(); } catch(e){ console.warn('绑定气泡预设失败', e); } });
  } else {
    setTimeout(() => { try { bindBubblePresetUI(); } catch(e){ console.warn('绑定气泡预设失败', e); } }, 50);
  }
})();
</script>
<!-- === /ChatGPT 插入：气泡预设脚本 === -->
<!-- === ChatGPT 插入：API 预设脚本 === -->
<script>
(function(){
  if (window._apiPresetsScriptLoaded) return;
  window._apiPresetsScriptLoaded = true;

  function _getApiPresets() {
    try { return JSON.parse(localStorage.getItem('apiPresets') || '[]'); }
    catch(e){ return []; }
  }
  function _saveApiPresets(arr) {
    localStorage.setItem('apiPresets', JSON.stringify(arr || []));
  }

  function populateApiSelect() {
    const sel = document.getElementById('api-preset-select');
    if (!sel) return;
    const presets = _getApiPresets();
    sel.innerHTML = '<option value="">— 选择 API 预设 —</option>';
    presets.forEach(p => {
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      sel.appendChild(opt);
    });
  }

  function saveCurrentApiAsPreset() {
    // Try to gather API settings fields: try to detect common fields like #setting-api-key, #setting-api-url, etc.
    const apiKeyEl = document.querySelector('#setting-api-key, input[name="apiKey"], input[id*="api-key"], input[id*="apikey"]');
    const apiUrlEl = document.querySelector('#setting-api-url, input[name="apiUrl"], input[id*="api-url"], input[id*="apiurl"]');
    const providerEl = document.querySelector('#setting-api-provider, select[name="provider"], select[id*="provider"]');

    const data = {
      apiKey: apiKeyEl ? apiKeyEl.value : '',
      apiUrl: apiUrlEl ? apiUrlEl.value : '',
      provider: providerEl ? providerEl.value : '',
      // capture whole form as fallback
      raw: {}
    };
    // gather inputs inside same settings container if possible
    const container = apiKeyEl ? apiKeyEl.closest('form,div') : null;
    if (container) {
      const inputs = container.querySelectorAll('input,select,textarea');
      inputs.forEach(i => { try { data.raw[i.name || i.id || i.getAttribute('data-key') || ('f_'+Math.random().toString(36).slice(2))] = i.value; } catch(e){} });
    }
    let name = prompt('为该 API 预设填写名称（会覆盖同名预设）：');
    if (!name) return;
    const presets = _getApiPresets();
    const idx = presets.findIndex(p => p.name === name);
    const preset = {name: name, data: data};
    if (idx >= 0) presets[idx] = preset; else presets.push(preset);
    _saveApiPresets(presets);
    populateApiSelect();
    (window.showToast && showToast('API 预设已保存')) || console.log('API 预设已保存');
  }

  async function applyApiPreset(name) {
    const presets = _getApiPresets();
    const p = presets.find(x => x.name === name);
    if (!p) return (window.showToast && showToast('未找到该预设')) || alert('未找到该预设');
    // Try to populate detected fields
    try {
      const apiKeyEl = document.querySelector('#setting-api-key, input[name="apiKey"], input[id*="api-key"], input[id*="apikey"]');
      const apiUrlEl = document.querySelector('#setting-api-url, input[name="apiUrl"], input[id*="api-url"], input[id*="apiurl"]');
      const providerEl = document.querySelector('#setting-api-provider, select[name="provider"], select[id*="provider"]');

      if (apiKeyEl && p.data && typeof p.data.apiKey !== 'undefined') apiKeyEl.value = p.data.apiKey;
      if (apiUrlEl && p.data && typeof p.data.apiUrl !== 'undefined') apiUrlEl.value = p.data.apiUrl;
      if (providerEl && p.data && typeof p.data.provider !== 'undefined') providerEl.value = p.data.provider;

      // populate raw fields if present
      if (p.data && p.data.raw) {
        for (const k in p.data.raw) {
          try {
            const el = document.querySelector('#'+k+', [name="'+k+'"]');
            if (el) el.value = p.data.raw[k];
          } catch(e){}
        }
      }

      (window.showToast && showToast('已应用 API 预设')) || console.log('已应用 API 预设');
    } catch(e) {
      console.error('applyApiPreset error', e);
    }
  }

  function openApiManageModal() {
    const modal = document.getElementById('api-presets-modal');
    const list = document.getElementById('api-presets-list');
    if (!modal || !list) return;
    list.innerHTML = '';
    const presets = _getApiPresets();
    if (!presets.length) {
      list.innerHTML = '<p style="color:#888;margin:6px 0;">暂无预设</p>';
    }
    presets.forEach((p, idx) => {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.justifyContent = 'space-between';
      row.style.alignItems = 'center';
      row.style.padding = '8px 6px';
      row.style.borderBottom = '1px solid #f6f6f6';

      const left = document.createElement('div');
      left.style.flex = '1';
      left.style.minWidth = '0';
      left.innerHTML = '<div style="font-weight:600;">'+p.name+'</div><div style="font-size:12px;color:#666;margin-top:4px;">' + (p.data && p.data.provider ? ('提供者：'+p.data.provider) : '') + '</div>';

      const btns = document.createElement('div');
      btns.style.display = 'flex';
      btns.style.gap = '6px';

      const applyBtn = document.createElement('button');
      applyBtn.className = 'btn';
      applyBtn.textContent = '应用';
      applyBtn.onclick = function(){ applyApiPreset(p.name); modal.style.display='none'; };

      const renameBtn = document.createElement('button');
      renameBtn.className = 'btn';
      renameBtn.textContent = '重命名';
      renameBtn.onclick = function(){
        const newName = prompt('输入新名称：', p.name);
        if (!newName) return;
        const all = _getApiPresets();
        all[idx].name = newName;
        _saveApiPresets(all);
        openApiManageModal();
        populateApiSelect();
      };

      const delBtn = document.createElement('button');
      delBtn.className = 'btn';
      delBtn.textContent = '删除';
      delBtn.onclick = function(){ if(!confirm('确定删除 "'+p.name+'" ?')) return; const all=_getApiPresets(); all.splice(idx,1); _saveApiPresets(all); openApiManageModal(); populateApiSelect(); };

      btns.appendChild(applyBtn); btns.appendChild(renameBtn); btns.appendChild(delBtn);

      row.appendChild(left); row.appendChild(btns);
      list.appendChild(row);
    });
    modal.style.display = 'flex';
  }

  // export / import handlers
  function exportApiPresets() {
    const presets = _getApiPresets();
    const blob = new Blob([JSON.stringify(presets, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'api_presets.json'; document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  }
  function importApiPresets() {
    const inp = document.createElement('input');
    inp.type = 'file';
    inp.accept = 'application/json';
    inp.onchange = function(e){
      const f = e.target.files[0];
      if (!f) return;
      const r = new FileReader();
      r.onload = function(){ try { const data = JSON.parse(r.result); if (Array.isArray(data)) { _saveApiPresets(data); populateApiSelect(); openApiManageModal(); } else alert('文件格式不正确'); } catch(e){ alert('导入失败：'+e.message); } };
      r.readAsText(f);
    };
    inp.click();
  }

  // bind UI
  function bind() {
    populateApiSelect();
    const saveBtn = document.getElementById('api-save-preset');
    const manageBtn = document.getElementById('api-manage-presets');
    const applyBtn = document.getElementById('api-apply-preset');
    const select = document.getElementById('api-preset-select');
    const modalClose = document.getElementById('api-close-modal');
    const importBtn = document.getElementById('api-import-presets');
    const exportBtn = document.getElementById('api-export-presets');

    if (saveBtn) saveBtn.addEventListener('click', saveCurrentApiAsPreset);
    if (manageBtn) manageBtn.addEventListener('click', openApiManageModal);
    if (applyBtn) applyBtn.addEventListener('click', function(){ const v=select.value; if(!v) return (window.showToast&&showToast('请选择预设'))||alert('请选择预设'); applyApiPreset(v); });
    if (modalClose) modalClose.addEventListener('click', function(){ document.getElementById('api-presets-modal').style.display='none'; });
    if (importBtn) importBtn.addEventListener('click', importApiPresets);
    if (exportBtn) exportBtn.addEventListener('click', exportApiPresets);

    if (select) select.addEventListener('change', function(){ /* optional: preview selection */ });
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', bind); else setTimeout(bind,50);

})();
</script>
<!-- === /ChatGPT 插入：API 预设脚本 === -->
<!-- === ChatGPT 插入脚本：我的人设预设逻辑（放到页面脚本块） === -->
<script>
(function(){
  if (window._myPersonaPresetScriptLoaded) return;
  window._myPersonaPresetScriptLoaded = true;

  // 存取 localStorage
  function _getMyPersonaPresets() {
    try { return JSON.parse(localStorage.getItem('myPersonaPresets') || '[]'); }
    catch(e){ return []; }
  }
  function _saveMyPersonaPresets(arr) {
    localStorage.setItem('myPersonaPresets', JSON.stringify(arr || []));
  }

  // 填充下拉
  function populateMyPersonaSelect() {
    const sel = document.getElementById('mypersona-preset-select');
    if (!sel) return;
    const presets = _getMyPersonaPresets();
    sel.innerHTML = '<option value="">— 选择预设 —</option>';
    presets.forEach(p => {
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      sel.appendChild(opt);
    });
  }

  // 保存当前侧栏（我的人设 + 我的头像）为预设
  function saveCurrentMyPersonaAsPreset() {
    const personaEl = document.getElementById('setting-my-persona');
    const avatarEl = document.getElementById('setting-my-avatar-preview');
    if (!personaEl || !avatarEl) return (window.showToast && showToast('找不到我的人设或头像控件')) || alert('找不到我的人设或头像控件');
    const persona = personaEl.value.trim();
    const avatar = avatarEl.src || '';
    if (!persona && !avatar) return (window.showToast && showToast('人设和头像都为空，无法保存')) || alert('人设和头像都为空，无法保存');
    const name = prompt('请输入预设名称（将覆盖同名预设）：');
    if (!name) return;
    const presets = _getMyPersonaPresets();
    const idx = presets.findIndex(p => p.name === name);
    const preset = { name, persona, avatar };
    if (idx >= 0) presets[idx] = preset; else presets.push(preset);
    _saveMyPersonaPresets(presets);
    populateMyPersonaSelect();
    (window.showToast && showToast('我的人设预设已保存')) || console.log('我的人设预设已保存');
  }

  // 将预设应用到当前聊天（同时写 UI + db.characters，并保存）
  async function applyMyPersonaPresetToCurrentChat(presetName) {
    const presets = _getMyPersonaPresets();
    const p = presets.find(x => x.name === presetName);
    if (!p) { (window.showToast && showToast('未找到该预设')) || alert('未找到该预设'); return; }

    // 更新界面
    const personaEl = document.getElementById('setting-my-persona');
    const avatarEl = document.getElementById('setting-my-avatar-preview');
    if (personaEl) personaEl.value = p.persona || '';
    if (avatarEl) avatarEl.src = p.avatar || '';

    // 尝试写入当前 chat 对象（与气泡预设做法一致）
    try {
      if (typeof currentChatId !== 'undefined' && window.db && Array.isArray(db.characters)) {
        const e = db.characters.find(c => c.id === currentChatId);
        if (e) {
          e.myPersona = p.persona || '';
          e.myAvatar = p.avatar || '';
          if (typeof saveData === 'function') await saveData();
          (window.showToast && showToast('预设已应用并保存到当前聊天')) || console.log('预设已应用');
          // 刷新侧栏与列表以显示更新
          if (typeof loadSettingsToSidebar === 'function') try{ loadSettingsToSidebar(); }catch(e){}
          if (typeof renderChatList === 'function') try{ renderChatList(); }catch(e){}
        }
      } else {
        (window.showToast && showToast('预设已应用到界面（未检测到当前聊天保存入口）')) || console.log('预设已应用到界面');
      }
    } catch(err) {
      console.error('applyMyPersonaPresetToCurrentChat error', err);
    }
  }

  // 管理 Modal
  function openManageMyPersonaModal() {
    const modal = document.getElementById('mypersona-presets-modal');
    const list = document.getElementById('mypersona-presets-list');
    if (!modal || !list) return;
    list.innerHTML = '';
    const presets = _getMyPersonaPresets();
    if (!presets.length) list.innerHTML = '<p style="color:#888;margin:6px 0;">暂无预设</p>';
    presets.forEach((p, idx) => {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.justifyContent = 'space-between';
      row.style.alignItems = 'center';
      row.style.padding = '8px 0';
      row.style.borderBottom = '1px solid #f0f0f0';

      const nameDiv = document.createElement('div');
      nameDiv.style.flex = '1';
      nameDiv.style.whiteSpace = 'nowrap';
      nameDiv.style.overflow = 'hidden';
      nameDiv.style.textOverflow = 'ellipsis';
      nameDiv.textContent = p.name;
      row.appendChild(nameDiv);

      const btnWrap = document.createElement('div');
      btnWrap.style.display = 'flex';
      btnWrap.style.gap = '6px';

      const applyBtn = document.createElement('button');
      applyBtn.className = 'btn btn-primary';
      applyBtn.style.padding = '6px 8px;border-radius:8px';
      applyBtn.textContent = '应用';
      applyBtn.onclick = function(){ applyMyPersonaPresetToCurrentChat(p.name); modal.style.display = 'none'; };

      const renameBtn = document.createElement('button');
      renameBtn.className = 'btn';
      renameBtn.style.padding = '6px 8px;border-radius:8px';
      renameBtn.textContent = '重命名';
      renameBtn.onclick = function(){
        const newName = prompt('输入新名称：', p.name);
        if (!newName) return;
        const all = _getMyPersonaPresets();
        all[idx].name = newName;
        _saveMyPersonaPresets(all);
        openManageMyPersonaModal();
        populateMyPersonaSelect();
      };

      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'btn';
      deleteBtn.style.padding = '6px 8px;border-radius:8px;color:#e53935';
      deleteBtn.textContent = '删除';
      deleteBtn.onclick = function(){
        if (!confirm('确认删除该预设？')) return;
        const all = _getMyPersonaPresets();
        all.splice(idx,1);
        _saveMyPersonaPresets(all);
        openManageMyPersonaModal();
        populateMyPersonaSelect();
      };

      btnWrap.appendChild(applyBtn);
      btnWrap.appendChild(renameBtn);
      btnWrap.appendChild(deleteBtn);
      row.appendChild(btnWrap);

      list.appendChild(row);
    });

    modal.style.display = 'flex';
  }

  // 绑定 UI
  function bind() {
    populateMyPersonaSelect();
    const saveBtn = document.getElementById('mypersona-save-btn');
    const manageBtn = document.getElementById('mypersona-manage-btn');
    const applyBtn = document.getElementById('mypersona-apply-btn');
    const select = document.getElementById('mypersona-preset-select');
    const modalClose = document.getElementById('mypersona-close-modal');

    if (saveBtn) saveBtn.addEventListener('click', saveCurrentMyPersonaAsPreset);
    if (manageBtn) manageBtn.addEventListener('click', openManageMyPersonaModal);
    if (applyBtn) applyBtn.addEventListener('click', function(){ const v = select.value; if(!v) return (window.showToast && showToast('请选择要应用的预设')) || alert('请选择要应用的预设'); applyMyPersonaPresetToCurrentChat(v); });
    if (modalClose) modalClose.addEventListener('click', function(){ document.getElementById('mypersona-presets-modal').style.display='none'; });

    // 页面可能在加载后改变侧栏数据，尝试在 DOMContentLoaded 或已有绑定后初始化
    // 当有其他代码重置 sidebar 时，可手动调用 populateMyPersonaSelect()
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', bind); else setTimeout(bind,50);

})();
</script>
<!-- === /我的人设预设脚本 === -->
<script id="bubble-scale-script">
(function() {
  const RANGE_ID = 'bubble-scale-range';
  const LABEL_ID = 'bubble-scale-value';
  const STORAGE_KEY = 'chat.bubbleScale';

  function applyScale(scale) {
    const screen = document.getElementById('chat-room-screen');
    if (screen) {
      screen.style.setProperty('--bubble-scale', scale);
    }
    const label = document.getElementById(LABEL_ID);
    if (label) {
      const pct = Math.round(scale * 100);
      label.textContent = pct + '%';
    }
  }

  function loadScale() {
    const raw = localStorage.getItem(STORAGE_KEY);
    const v = raw ? parseFloat(raw) : 1;
    return (isFinite(v) && v >= 0.5 && v <= 2) ? v : 1;
  }

  function saveScale(v) {
    try { localStorage.setItem(STORAGE_KEY, String(v)); } catch (e) {}
  }

  document.addEventListener('DOMContentLoaded', function() {
    const range = document.getElementById(RANGE_ID);
    if (!range) return;
    const init = loadScale();
    range.value = String(init);
    applyScale(init);
    range.addEventListener('input', function() {
      const v = parseFloat(range.value);
      applyScale(v);
      saveScale(v);
    });
  });

  window.addEventListener('hashchange', function() {
    const scale = loadScale();
    applyScale(scale);
  });
})();
</script>
<!-- ================= Moments 页面（动态） ================= -->
<div class="screen" id="moments-screen" style="display:none;">
  <header class="app-header">
    <button class="back-btn" data-target="chat-list-screen">‹</button>
    <div class="title-container"><h1 class="title">动态</h1></div>
    <div class="action-btn-group">
      <button class="action-btn" id="moments-delete-btn">删除</button>
      <button class="action-btn" id="open-post-modal">发布</button>
    </div>
  </header>
  <main class="content" id="moments-list">

<!-- === BEGIN ICITY-STYLE USER HEADER SNIPPET (inserted by assistant) === -->
<style>
  /* 尽量隔离命名避免冲突 */
  .icity-moments-wrap { width:100%; margin-bottom: 14px; display:flex; justify-content:center; }
  .icity-moments-inner {
    width: calc(100% - 20px);
    max-width: 760px; /* 自适应手机与桌面 */
    position: relative;
  }

  /* 黑色背景 / 顶图 */
  .icity-hero {
    height: 150px;
    background: #000; /* 默认纯黑 */
    border-radius: 14px 14px 0 0;
    overflow: hidden;
    position: relative;
    background-size: cover; /* 恢复：让图片填满容器 */
    background-position: center; /* 保持：让图片居中显示 */
  }

  /* 白色头像圆（位于 hero 底部居中，部分覆盖下方白卡） */
  .icity-avatar-wrap {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    bottom: -46px; /* 头像会覆盖到下方信息卡 */
    width: 110px;
    height: 110px;
    border-radius: 50%;
    background: #fff; /* 默认头像纯白 */
    box-shadow: 0 6px 20px rgba(0,0,0,0.12);
    display:flex;
    align-items:center;
    justify-content:center;
    border: 6px solid rgba(255,255,255,0.9);
  }

  .icity-avatar-wrap img { width:80%; height:80%; border-radius:50%; object-fit:cover; display:block; }

  /* 白色信息卡 */
  .icity-info-card {
    background: #fff;
    border-radius: 14px;
    padding: 64px 18px 18px; /* top padding 留出头像区域 */
    box-shadow: 0 6px 18px rgba(0,0,0,0.04);
    margin-top: 10px;
    box-sizing: border-box;
    text-align: center;
  }

  .icity-name {
    font-size: 22px;
    font-weight: 700;
    color: #111;
    margin: 0;
    line-height: 1;
  }

  .icity-id-loc {
    margin-top: 8px;
    display:flex;
    justify-content:center;
    gap:10px;
    align-items:center;
    font-size:13px;
    color:#888;
  }

  .icity-signature {
    margin-top: 12px;
    color:#666;
    font-size:14px;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }

  /* 小图标（定位标识） */
  .icity-id-loc .dot {
    width:6px; height:6px; border-radius:50%; background:#ddd; display:inline-block; margin-right:6px;
  }

  /* 响应：小屏时适配 */
  @media (max-width:420px) {
    .icity-avatar-wrap { width:90px; height:90px; bottom:-40px; }
    .icity-info-card { padding-top:56px; }
    .icity-name { font-size:20px; }
  }

/* ---- 多选删除样式（动态页面） ---- */
#moments-screen.is-delete-mode .moment-item { cursor: pointer; user-select: none; }
.moment-item.is-selected { outline: 2px solid var(--accent-color, #4c9ffe); position: relative; }
.moment-item.is-selected::after {
  content: '✓';
  position: absolute; right: 8px; top: 8px;
  width: 22px; height: 22px; line-height: 22px; text-align: center;
  border-radius: 50%;
  background: rgba(0,0,0,.6); color: #fff; font-weight: 700; font-size: 14px;
}

/* 底部多选操作栏 */
.multi-select-bar {
  position: fixed; left: 0; right: 0; bottom: 0;
  display: flex; justify-content: space-between; align-items: center;
  padding: 10px 14px;
  background: #111; color: #fff;
  transform: translateY(100%); transition: transform .25s ease;
  z-index: 250;
}
.multi-select-bar.show { transform: translateY(0%); }
.multi-select-bar .danger { color: #fff; background: #e5484d; border-radius: 10px; padding: 8px 12px; }
.action-btn-group { display: inline-flex; gap: 8px; align-items: center; }
</style>

<div class="icity-moments-wrap" id="icity-moments-wrap">
  <div class="icity-moments-inner" role="region" aria-label="用户动态头部">
    <div class="icity-hero" id="icity-hero"></div>

    <!-- 头像 -->
    <div class="icity-avatar-wrap" id="icity-avatar-wrap" aria-hidden="false">
      <!-- 默认头像：纯白圆（可替换为 dataURL 或真实图片） -->
      <img id="icity-avatar" alt="头像" src="data:image/svg+xml;utf8,
        %3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E
        %3Crect width='100%25' height='100%25' fill='%23ffffff'/%3E
        %3C/svg%3E" />
    </div>

    <!-- 信息白卡 -->
    <div class="icity-info-card">
      <h2 class="icity-name" id="icity-name">Skeleton</h2>

      <div class="icity-id-loc">
        <span class="icity-id">ID：<strong id="icity-id">user</strong></span>
        <span style="opacity:0.4;">·</span>
        <span class="icity-loc"><span class="dot"></span><span id="icity-loc-text">自定义定位</span></span>
      </div>

      <div class="icity-signature" id="icity-signature">把心情写在这里吧♥</div>
    </div>
  </div>
</div>

<script>
  // 初始化默认值（可按需替换为动态数据）
  (function(){
    document.addEventListener('DOMContentLoaded', function(){
      try {
        // 默认文本，遵循你的要求
        const defaults = {
          name: 'Skeleton',
          signature: '把心情写在这里吧♥',
          id: 'user',
          location: '自定义定位',
          avatarSrc: null, // null 使用白色默认图
          heroBg: '#000' // 纯黑背景
        };

        const nameEl = document.getElementById('icity-name');
        const sigEl = document.getElementById('icity-signature');
        const idEl = document.getElementById('icity-id');
        const locEl = document.getElementById('icity-loc-text');
        const avatarEl = document.getElementById('icity-avatar');
        const heroEl = document.getElementById('icity-hero');

        if (nameEl) nameEl.textContent = defaults.name;
        if (sigEl) sigEl.textContent = defaults.signature;
        if (idEl) idEl.textContent = defaults.id;
        if (locEl) locEl.textContent = defaults.location;
        if (heroEl) heroEl.style.background = defaults.heroBg;

        // ---- Profile helpers: load/save/render ----
        window.loadProfileFromStorage = function(){
            return {
                name: localStorage.getItem('myTopName') || defaults.name,
                id: localStorage.getItem('myTopId') || defaults.id,
                location: localStorage.getItem('myTopLoc') || defaults.location,
                signature: localStorage.getItem('myTopSignature') || defaults.signature,
                avatar: localStorage.getItem('myTopAvatar') || (defaults.avatarSrc || ''),
                heroBg: localStorage.getItem('myTopBg') || (defaults.heroBg || '')
            };
        }
        function saveProfileToStorage(profile){
            if(profile.name!=null) localStorage.setItem('myTopName', profile.name);
            if(profile.id!=null) localStorage.setItem('myTopId', profile.id);
            if(profile.location!=null) localStorage.setItem('myTopLoc', profile.location);
            if(profile.signature!=null) localStorage.setItem('myTopSignature', profile.signature);
            if(profile.avatar!=null) localStorage.setItem('myTopAvatar', profile.avatar);
            if(profile.heroBg!=null) localStorage.setItem('myTopBg', profile.heroBg);
        }
        function renderProfileAndSync(){
            const p = loadProfileFromStorage();
            if(nameEl) nameEl.textContent = p.name;
            if(sigEl) sigEl.textContent = p.signature;
            if(idEl) idEl.textContent = p.id;
            if(locEl) locEl.textContent = p.location;
            if(avatarEl){
                if(p.avatar) avatarEl.src = p.avatar;
                // also update global avatar displays
                document.querySelectorAll('.my-avatar, #moments-screen .top-avatar, .top-avatar').forEach(img=>{
                    if(img.tagName==='IMG') img.src = p.avatar || '';
                    else img.style.backgroundImage = p.avatar? `url('${p.avatar}')` : '';
                });
                // update moment avatars (sync instead of snapshot)
                document.querySelectorAll('.moment-avatar, .post .avatar-img').forEach(img=>{
                    if(img.tagName==='IMG') img.src = p.avatar || img.src;
                });
            }
            if(heroEl){
                if(p.heroBg){
                    if(p.heroBg.startsWith('http') || p.heroBg.startsWith('data:') || p.heroBg.startsWith('url(')){
                        heroEl.style.backgroundImage = `url('${p.heroBg}')`;
                        heroEl.style.backgroundSize = 'cover';
                        heroEl.style.backgroundPosition = 'center';
                    } else {
                        heroEl.style.background = p.heroBg;
                    }
                } else {
                    heroEl.style.background = defaults.heroBg;
                }
            }
            // If there is a moments renderer, call it to re-render posts with updated profile data
            if(typeof renderMoments === 'function') {
                try{ renderMoments(); }catch(e){}
            } else if(typeof window.renderMomentsSafe === 'function'){
                try{ window.renderMomentsSafe(); }catch(e){}
            }
        }

        // ---- Click handlers per your requirement (separate triggers) ----
        // Clicking hero edits background; clicking avatar edits avatar
        try {
            const bgBtn = document.getElementById('edit-bg-btn');
            const avatarBtn = document.getElementById('edit-avatar-btn');
            if(heroEl) heroEl.addEventListener('click', ()=> { if(bgBtn) bgBtn.click(); });
            if(avatarEl) avatarEl.addEventListener('click', ()=> { if(avatarBtn) avatarBtn.click(); });
        } catch(e){ console.warn('bind bg/avatar click failed', e); }

        // Inline edit helper for text fields (name, id, location, signature)
        function inlineEditText(el, key, placeholder){
            if(!el) return;
            el.style.cursor = 'text';
            el.addEventListener('click', function handler(e){
                e.stopPropagation();
                const old = el.textContent || '';
                const input = document.createElement('input');
                input.type = 'text';
                input.value = old;
                input.placeholder = placeholder || '';
                input.style.fontSize = window.getComputedStyle(el).fontSize;
                input.style.width = '100%';
                input.style.boxSizing = 'border-box';
                el.replaceWith(input);
                input.focus();
                function commit(){
                    const v = input.value.trim();
                    const profile = loadProfileFromStorage();
                    profile[key] = v;
                    saveProfileToStorage(profile);
                    renderProfileAndSync();
                    input.removeEventListener('blur', onBlur);
                    input.removeEventListener('keydown', onKey);
                }
                function onBlur(){ commit(); input.replaceWith(el); }
                function onKey(ev){ if(ev.key === 'Enter'){ commit(); input.replaceWith(el); } else if(ev.key==='Escape'){ input.replaceWith(el); } }
                input.addEventListener('blur', onBlur);
                input.addEventListener('keydown', onKey);
            }, { once: false });
        }

        inlineEditText(nameEl, 'name', '请输入名称');
        inlineEditText(idEl, 'id', '请输入ID（将作为 authorId）');
        inlineEditText(locEl, 'location', '请输入定位文本');
        inlineEditText(sigEl, 'signature', '请输入个性签名');

        // Initial render from storage
        renderProfileAndSync();

        if (defaults.avatarSrc) {
          avatarEl.src = defaults.avatarSrc;
        }

        // 头像点击事件占位
        const wrap = document.getElementById('icity-avatar-wrap');
        if (wrap) {
          wrap.addEventListener('click', function(){
            console.log('icity avatar clicked');
          });
        }

      } catch (e) {
        console.warn('icity header init error', e);
      }
    });
  })();
</script>
<!-- === END ICITY-STYLE USER HEADER SNIPPET === -->

    <p class="placeholder-text" id="moments-empty">还没有动态，点击右上角发布吧~</p>
    <div id="moments-container"></div>
  </main>
</div>

<!-- 发布动态模态框 -->
<div class="modal-overlay" id="post-modal" style="display:none;">
  <div class="modal-window">
    <h3>发布动态</h3>
    <form id="post-form">
      <div class="form-group">
        <label>动态内容</label>
        <textarea id="post-text" placeholder="说点什么..." required rows="4"></textarea>
      </div>
      <div class="form-group">
        <label><input type="checkbox" id="add-image"> 添加图片</label>
      </div>
      <div class="form-group" id="image-input-group" style="display:none;">
  <label>图片描述</label>
  <input type="text" id="image-description" placeholder="描述图片内容（如：海边日落）">
</div>
      <div style="display:flex; gap:10px; margin-top:12px;">
        <button class="btn btn-secondary" type="button" id="cancel-post-btn">取消</button>
        <button class="btn btn-primary" type="submit">发布</button>
      </div>
    </form>
  </div>
</div>

<!-- 在聊天界面底部插入导航（你指定的位置：聊天界面底部） -->
<style>
  /* 微调底部导航样式（不会影响你原有 .dock） */
  .bottom-nav {
    position: absolute;
    left: 0;
    right: 0;
    height: 68px;
    display: flex;
    gap: 6px;
    align-items: center;
    justify-content: center;
    padding: 10px 14px;
    box-sizing: border-box;
    background: rgba(255,255,255,0.85);
    border-top-left-radius: 18px;
    border-top-right-radius: 18px;
    box-shadow: 0 -6px 20px rgba(0,0,0,0.06);
    z-index: 50;
    bottom: 0;
  }
  .bottom-nav .nav-btn {
    flex: 1;
    height: 48px;
    border-radius: 12px;
    border: none;
    font-weight: 600;
    cursor: pointer;
    background: transparent;
    color: var(--text-color, #444);
  }
  .bottom-nav .nav-btn.active {
    background: var(--primary-color, #ff80ab);
    color: #fff;
    box-shadow: 0 6px 16px rgba(255,128,171,0.22);
  }

  /* moments 列表项 */
  .moment-item {
    background: #fff;
    border-radius: 14px;
    padding: 12px;
    margin-bottom: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.03);
  }
  .moment-head { display:flex; gap:10px; align-items:center; margin-bottom:8px; }
  .moment-avatar { width:44px; height:44px; border-radius:50%; object-fit:cover; background:#eee; flex-shrink:0; }
  .moment-meta { font-size:13px; }
  .moment-text { margin:8px 0; white-space:pre-wrap; color:var(--text-color,#333); }
  .moment-image { width:100%; max-height:260px; object-fit:cover; border-radius:10px; margin-top:8px; }
  .moment-comments { margin-top:10px; padding-top:8px; border-top:1px solid #faf0f4; color:#666; font-size:13px; }
  .moment-comment { margin-bottom:6px; }

  /* --- 新增：动态操作栏 (点赞/评论) --- */
  .moment-actions {
    display: flex;
    gap: 12px;
    margin-top: 12px;
    padding-top: 8px;
    border-top: 1px solid #f5f5f5;
  }
  .moment-action-btn {
    background: none;
    border: none;
    cursor: pointer;
    color: #888;
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 13px;
  }
  .moment-action-btn svg {
    width: 18px;
    height: 18px;
    fill: currentColor;
  }
  .moment-action-btn.liked {
    color: var(--primary-color);
  }

  /* --- 新增：点赞列表显示 --- */
  .moment-likes {
    background-color: #f9f9f9;
    padding: 6px 10px;
    border-radius: 8px;
    font-size: 13px;
    color: #555;
    margin-top: 8px;
    display: none; /* 默认隐藏 */
  }
  .moment-likes.visible {
    display: block;
  }
  .moment-likes .like-icon {
    color: var(--primary-color);
    margin-right: 4px;
  }

  /* --- 新增：用户评论输入区域 --- */
  .moment-comment-input-area {
    display: none; /* Default hidden */
    gap: 8px;
    margin-top: 10px;
  }
  .moment-comment-input-area.visible {
    display: flex;
  }
  .moment-comment-input {
    flex-grow: 1;
    border: 1px solid #eee;
    border-radius: 15px;
    padding: 8px 12px;
    font-size: 13px;
  }
  .moment-comment-input:focus {
    outline: none;
    border-color: var(--primary-color);
  }
  .post-comment-btn {
    background-color: var(--primary-color);
    color: white;
    border: none;
    border-radius: 15px;
    padding: 8px 12px;
    font-size: 13px;
    cursor: pointer;
    flex-shrink: 0;
  }

</style>

<div id="bottom-nav-host" data-managed-by="injection" style="display:none;">
  <div class="bottom-nav" id="bottom-nav">
    <button class="nav-btn active" data-target="chat-list-screen">聊天</button>
    <button class="nav-btn" data-target="moments-screen">动态</button>
  </div>
</div>

<script>
(function() {
  // 等 DOM 完全加载
  document.addEventListener('DOMContentLoaded', () => {
    // --- 全局辅助函数 ---
    window.getAuthorNameById = function(authorId) {
        if (!authorId) return '未知';
        // 优先从顶栏信息获取自己的名字
        if (typeof loadProfileFromStorage === 'function') {
            const myProfile = loadProfileFromStorage();
            if (myProfile && myProfile.id === authorId) {
                return myProfile.name || '我';
            }
        }
        // 从全局 db 对象查找
        if (window.db) { // This now refers to the main data object, not Dexie.
            if (window.db.characters) {
                const character = window.db.characters.find(c => c.id === authorId);
                if (character) return character.remarkName;
            }
            if (window.db.groups) {
                for (const group of window.db.groups) {
                    if (group.members) {
                        const member = group.members.find(m => m.id === authorId);
                        if (member) return member.groupNickname;
                    }
                }
            }
        }
        // Fallback
        return authorId.startsWith('char_') ? '某角色' : authorId;
    };

    // --- 简单工具函数 ---
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));
    function escapeText(t) { return String(t == null ? '' : t); }

    // 1) 初始化 Dexie（使用页面已引入的 Dexie）
    let db;
    try {
      db = new Dexie('AppDB_Moments');
      db.version(1).stores({
        moments: 'id,timestamp,commentedBy' // comments 和 likes 存在于对象内
      });
      // expose to window so external scripts can access the Dexie instance
      try{ window.AppDB_Moments = db; }catch(e){}

    } catch (e) {
      console.error('Dexie init failed', e);
      showToast('本地数据库初始化失败，动态功能受限');
      return;
    }

    // 2) DOM 元素
    const openPostBtn = $('#open-post-modal');
    const postModal = $('#post-modal');
    const postForm = $('#post-form');
    const addImageCheckbox = $('#add-image');
    const imageInputGroup = $('#image-input-group');
    const postImageInput = $('#post-image');
    const imageDescInput = $('#image-description');
    const postImagePreview = $('#post-image-preview');
    const cancelPostBtn = $('#cancel-post-btn');
    const momentsContainer = $('#moments-container');
    const momentsEmpty = $('#moments-empty');
    const momentsScreen = $('#moments-screen');
    const bottomNavHost = document.getElementById('bottom-nav-host');

    // 3) 绑定打开/关闭发布模态
    if (openPostBtn) openPostBtn.addEventListener('click', () => {
      postModal.style.display = 'flex';
      postModal.classList.add('visible');
    });
    if (cancelPostBtn) cancelPostBtn.addEventListener('click', closePostModal);
    function closePostModal() {
      postModal.style.display = 'none';
      postModal.classList.remove('visible');
      postForm.reset();
      // 清理图片预览与文件输入，避免残留 dataURL 或页面 URL 导致后续发布异常
      try { postImagePreview.src = ''; } catch(e){}
      try { const pi = document.getElementById('post-image'); if(pi) pi.value = ''; } catch(e){}
      postImagePreview.style.display = 'none';
      imageInputGroup.style.display = 'none';
    }

    addImageCheckbox.addEventListener('change', e => {
      // 如果取消添加图片，清理之前的预览和文件输入
      if (!addImageCheckbox.checked) { try { postImagePreview.src = ''; } catch(e){} try { const pi = document.getElementById('post-image'); if(pi) pi.value = ''; } catch(e){} }

      imageInputGroup.style.display = e.target.checked ? 'block' : 'none';
    });

    

    async function fileToDataURLAndCompress(file, maxWidth = 1200, quality = 0.85) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function(ev) {
          const img = new Image();
          img.onload = function() {
            const w = img.width, h = img.height;
            let nw = w, nh = h;
            if (w > maxWidth) {
              nw = maxWidth;
              nh = Math.round(h * (maxWidth / w));
            }
            const canvas = document.createElement('canvas');
            canvas.width = nw;
            canvas.height = nh;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, nw, nh);
            const out = canvas.toDataURL('image/jpeg', quality);
            resolve(out);
          };
          img.onerror = reject;
          img.src = ev.target.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    // 4) 发布动态（写入 Dexie）
    

// --- Safe addMoment helper (injected by assistant) ---
async function addMomentToDB(momentObj) {
  // 1) Prefer global Dexie instance AppDB_Moments if available
  try {
    if (window.AppDB_Moments && window.AppDB_Moments.moments && typeof window.AppDB_Moments.moments.add === 'function') {
      return window.AppDB_Moments.moments.add(momentObj);
    }
  } catch(e){ /* ignore */ }

  // 2) If window.db.moments looks like Dexie, use it
  try {
    if (window.db && window.db.moments && typeof window.db.moments.add === 'function') {
      return window.db.moments.add(momentObj);
    }
  } catch(e){ /* ignore */ }

  // 3) Fallback to in-memory array and try to persist via saveData()
  if (!window.db) window.db = {};
  if (!Array.isArray(window.db.moments)) window.db.moments = [];
  window.db.moments.push(momentObj);

  if (typeof window.saveData === 'function') {
    try { await window.saveData(); } catch(e){ console.warn('saveData fallback failed', e); }
  }

  // 4) Try to mirror into AppDB_Moments (put to avoid duplicate key issues)
  try {
    if (window.AppDB_Moments && window.AppDB_Moments.moments && typeof window.AppDB_Moments.moments.put === 'function') {
      await window.AppDB_Moments.moments.put(momentObj);
    }
  } catch(e){ console.warn('mirror to AppDB_Moments failed', e); }

  return Promise.resolve();
}

// --- Replaced postForm submit handler (injected by assistant) ---
postForm.addEventListener('submit', async (ev) => {
  ev.preventDefault();

  const submitBtn = postForm.querySelector('button[type=\"submit\"]');
  if (submitBtn) submitBtn.disabled = true;

  // adapt these IDs to match your form inputs if they differ
  const textEl = document.getElementById('post-text');
  const addImageEl = document.getElementById('add-image');
  const imageDescEl = document.getElementById('image-description');

  const text = textEl ? textEl.value.trim() : '';
  const addImage = addImageEl ? addImageEl.checked : false;
  const imageDesc = imageDescEl ? imageDescEl.value.trim() : '';

  if (!text && !addImage) {
    if (submitBtn) submitBtn.disabled = false;
    if (typeof showToast === 'function') showToast('请输入动态内容');
    return;
  }

  if (addImage && !imageDesc) {
    if (submitBtn) submitBtn.disabled = false;
    if (typeof showToast === 'function') showToast('请输入图片描述');
    return;
  }

  const id = 'm_' + Date.now() + '_' + Math.random().toString(36).slice(2,8);
  const momentObj = {
    id,
    authorId: (localStorage.getItem('myTopId') || 'user'),
    authorAvatar: (localStorage.getItem('myTopAvatar') || null),
    text,
    imageDesc: addImage ? imageDesc : '',
    timestamp: Date.now(),
    commentedBy: [],
    comments: [],
    likes: []
  };

  try {
    await addMomentToDB(momentObj);

    if (typeof showToast === 'function') showToast('发布成功');
    try { if (typeof closePostModal === 'function') closePostModal(); } catch(e){}

    // Force immediate re-render of moments
    if (typeof renderMoments === 'function') {
      try { await renderMoments(); } catch(e){ console.warn('renderMoments failed', e); }
    } else if (typeof window.renderMomentsSafe === 'function') {
      try { await window.renderMomentsSafe(); } catch(e){ console.warn('renderMomentsSafe failed', e); }
    } else {
      // last resort: toggle screen class to force repaint
      const ms = document.getElementById('moments-screen');
      if (ms) {
        ms.classList.remove('active');
        setTimeout(()=>ms.classList.add('active'), 10);
      }
    }
  } catch (e) {
    console.error('add moment err', e);
    if (typeof showToast === 'function') showToast('保存失败: ' + (e && e.message ? e.message : String(e)));
  } finally {
    if (submitBtn) submitBtn.disabled = false;
  }
});



    // 5) 渲染动态列表
    async function renderMoments() {
      const list = await db.moments.orderBy('timestamp').reverse().toArray();
      momentsContainer.innerHTML = '';
      if (!list.length) {
        momentsEmpty.style.display = 'block';
        return;
      } else {
        momentsEmpty.style.display = 'none';
      }
      list.forEach(m => {
        const div = document.createElement('div');
        div.className = 'moment-item';
        div.dataset.id = m.id || (m.id = (Math.random()+''+Date.now()));
        // head（avatar + meta）
        const head = document.createElement('div'); head.className = 'moment-head';
        const avatar = document.createElement('img'); avatar.className = 'moment-avatar';
            // Prefer dynamic profile lookup by authorId so that avatar/id changes sync across posts
            (function(){
                const profile = (typeof loadProfileFromStorage === 'function') ? loadProfileFromStorage() : {
                    name: localStorage.getItem('myTopName') || '我',
                    id: localStorage.getItem('myTopId') || 'user',
                    avatar: localStorage.getItem('myTopAvatar') || null
                };
                if(m.authorId && profile && m.authorId === profile.id){
                    avatar.src = profile.avatar || (m.authorAvatar || 'data:image/svg+xml;chars...%2212%22%20rx%3D%226%22%20fill%3D%22%23cfe9ff%22/%3E%3C/svg%3E');
                } else {
                    avatar.src = m.authorAvatar || 'data:image/svg+xml;chars...%2212%22%20rx%3D%226%22%20fill%3D%22%23cfe9ff%22/%3E%3C/svg%3E';
                }
            })();
            const meta = document.createElement('div'); meta.className = 'moment-meta';
            const name = document.createElement('div'); name.style.fontWeight = '700';
            // display name: prefer linked profile name if authorId matches
            name.textContent = window.getAuthorNameById(m.authorId) || '我';
            const time = document.createElement('div'); time.style.fontSize='12px'; time.style.color='#999';
            try { time.textContent = new Date(m.timestamp).toLocaleString(); } catch(e) { time.textContent = ''; }
            meta.appendChild(name); meta.appendChild(time);
            head.appendChild(avatar); head.appendChild(meta);
            div.appendChild(head);

        // text
        const txt = document.createElement('div'); txt.className = 'moment-text';
        txt.textContent = m.text || '';
        div.appendChild(txt);

        // image
        if (m.imageData && m.imageData !== 'null' && m.imageData !== 'undefined' && m.imageData.length>10) {
  const im = document.createElement('img'); im.className = 'moment-image';
  im.src = m.imageData;
  im.alt = m.imageDesc ? m.imageDesc : (m.text || '动态图片');
  div.appendChild(im);
  if (m.imageDesc) {
    const desc = document.createElement('div'); desc.style.fontSize='13px'; desc.style.color='#666';
    desc.textContent = '图片：' + m.imageDesc;
    div.appendChild(desc);
  }
} else if (m.imageDesc) {
  const descCard = document.createElement('div'); descCard.className = 'moment-image-desc-card';
  if (m.id) descCard.dataset.momentId = m.id || '';
  const descContent = document.createElement('p'); descContent.className = 'desc-content';
  descContent.textContent = m.imageDesc;
  descCard.appendChild(descContent);
  descCard.setAttribute('role', 'img');
  descCard.setAttribute('aria-label', m.imageDesc);
  descCard.addEventListener('click', function () { /* show detail */ });
  div.appendChild(descCard);
}

        // --- 新增：点赞和评论的UI与逻辑 ---
        const actions = document.createElement('div');
        actions.className = 'moment-actions';
        
        const likeBtn = document.createElement('button');
        likeBtn.className = 'moment-action-btn';
        const likes = m.likes || [];
        const myProfile = loadProfileFromStorage();
        const myId = myProfile.id || 'user';
        if (likes.includes(myId)) {
            likeBtn.classList.add('liked');
        }
        likeBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg><span>${likes.length > 0 ? likes.length : '点赞'}</span>`;
        
        likeBtn.addEventListener('click', async (event) => {
            const btn = event.currentTarget;
            const momentItem = btn.closest('.moment-item');
            const currentLikes = m.likes || [];
            const myIdx = currentLikes.indexOf(myId);

            if (myIdx > -1) {
                currentLikes.splice(myIdx, 1);
                btn.classList.remove('liked');
            } else {
                currentLikes.push(myId);
                btn.classList.add('liked');
            }
            m.likes = currentLikes;
            await db.moments.put(m);

            // 直接更新UI，避免重新渲染整个列表
            const span = btn.querySelector('span');
            if (span) {
                span.textContent = currentLikes.length > 0 ? currentLikes.length : '点赞';
            }

            const likesWrap = momentItem.querySelector('.moment-likes');
            if (likesWrap) {
                if (currentLikes.length > 0) {
                    const likeNames = currentLikes.map(likeId => window.getAuthorNameById(likeId)).join(', ');
                    likesWrap.innerHTML = `<span class="like-icon">♥</span> ${likeNames}`;
                    likesWrap.classList.add('visible');
                } else {
                    likesWrap.classList.remove('visible');
                }
            }
        });

        const commentBtn = document.createElement('button');
        commentBtn.className = 'moment-action-btn';
        commentBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg><span>评论</span>`;
        commentBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            const btn = event.currentTarget;
            const momentItem = btn.closest('.moment-item');
            if (momentItem) {
                const inputArea = momentItem.querySelector('.moment-comment-input-area');
                if (inputArea) {
                    inputArea.classList.toggle('visible');
                    if (inputArea.classList.contains('visible')) {
                        inputArea.querySelector('input').focus();
                    }
                }
            }
        });

        actions.appendChild(likeBtn);
        actions.appendChild(commentBtn);
        div.appendChild(actions);

        // 点赞列表
        if (likes.length > 0) {
            const likesWrap = document.createElement('div');
            likesWrap.className = 'moment-likes visible';
            const likeNames = likes.map(likeId => window.getAuthorNameById(likeId)).join(', ');
            likesWrap.innerHTML = `<span class="like-icon">♥</span> ${likeNames}`;
            div.appendChild(likesWrap);
        }

        // comments
        const commentsWrap = document.createElement('div'); commentsWrap.className = 'moment-comments';
        if (m.comments && m.comments.length) {
          m.comments.forEach(c => {
            const cm = document.createElement('div'); cm.className='moment-comment';
            const authorName = window.getAuthorNameById(c.roleId || c.role);
            cm.textContent = `${authorName}：${c.text}`;
            commentsWrap.appendChild(cm);
          });
        } else {
          const none = document.createElement('div'); none.style.color='#bbb'; none.textContent = '暂时没有评论';
          commentsWrap.appendChild(none);
        }
        div.appendChild(commentsWrap);

        // --- 新增：用户评论输入框 ---
        const commentInputArea = document.createElement('div');
        commentInputArea.className = 'moment-comment-input-area';
        commentInputArea.innerHTML = `
          <input type="text" class="moment-comment-input" placeholder="添加评论...">
          <button class="post-comment-btn" data-moment-id="${m.id}">发布</button>
        `;
        div.appendChild(commentInputArea);
        // --- 结束 ---

        momentsContainer.appendChild(div);
      });
    }
// --- 新增: 保存评论和点赞的辅助函数 ---
async function saveUserComment(momentId, commentText) {
    try {
        if (!db || !momentId || !commentText) return;
        const moment = await db.moments.get(momentId);
        if (!moment) return;

        const myProfile = loadProfileFromStorage();
        const myId = myProfile.id || 'user';
        const myName = myProfile.name || '我';

        // 1. 更新动态的评论列表
        moment.comments = moment.comments || [];
        moment.comments.push({
            roleId: myId,
            text: commentText,
            ts: Date.now()
        });

        // Also update the commentedBy array to include the user
        moment.commentedBy = moment.commentedBy || [];
        if (!moment.commentedBy.includes(myId)) {
            moment.commentedBy.push(myId);
        }

        await db.moments.put(moment);

        // 2. 注入到AI上下文 (如果作者是AI角色)
        const authorId = moment.authorId;
        if (authorId && authorId.startsWith('char_')) {
            const character = window.db.characters.find(c => c.id === authorId);
            if (character) {
                const momentContentSnippet = moment.text.substring(0, 20) + (moment.text.length > 20 ? '...' : '');
                const contextMessageContent = `[system: ${myName} 评论了你的动态 "${momentContentSnippet}": "${commentText}"]`;
                const contextMessage = {
                    id: `msg_context_${Date.now()}`,
                    role: 'user',
                    content: contextMessageContent,
                    parts: [{ type: 'text', text: contextMessageContent }],
                    timestamp: Date.now()
                };
                character.history.push(contextMessage);
                // 调用主应用的保存函数
                if (typeof window.saveData === 'function') {
                    await window.saveData();
                }
            }
        }
        
        // 3. 重新渲染动态列表并折叠输入框
        renderMoments();
        const momentElement = document.querySelector(`.moment-item[data-id="${momentId}"]`);
        if (momentElement) {
            const inputArea = momentElement.querySelector('.moment-comment-input-area');
            if (inputArea) {
                inputArea.classList.remove('visible');
            }
        }

    } catch (e) {
        console.error(`Failed to save user comment for moment ${momentId}:`, e);
        showToast('评论失败');
    }
}

async function saveMomentComment(momentId, authorId, commentText) {
    try {
        if (!window.AppDB_Moments || !window.AppDB_Moments.moments || !momentId) return;
        const moment = await window.AppDB_Moments.moments.get(momentId);
        if (moment) {
            moment.comments = moment.comments || [];
            moment.commentedBy = moment.commentedBy || [];
            moment.comments.push({
                roleId: authorId,
                text: commentText,
                ts: Date.now()
            });
            if (!moment.commentedBy.includes(authorId)) {
                moment.commentedBy.push(authorId);
            }
            await window.AppDB_Moments.moments.put(moment);
            if (typeof renderMoments === 'function') renderMoments();
        }
    } catch (e) {
        console.error(`Failed to save comment for moment ${momentId}:`, e);
    }
}

async function saveMomentLike(momentId, authorId) {
    try {
        if (!window.AppDB_Moments || !window.AppDB_Moments.moments || !momentId) return;
        const moment = await window.AppDB_Moments.moments.get(momentId);
        if (moment) {
            moment.likes = moment.likes || [];
            if (!moment.likes.includes(authorId)) {
                moment.likes.push(authorId);
                await window.AppDB_Moments.moments.put(moment);
                if (typeof renderMoments === 'function') renderMoments();
            }
        }
    } catch (e) {
        console.error(`Failed to save like for moment ${momentId}:`, e);
    }
}
// --- end 新增 ---


    // 6) 获取尚未被某角色评论的动态（limit）
    async function getPendingMomentsForRole(roleId, limit = 5) {
      const all = await db.moments.orderBy('timestamp').reverse().toArray();
      const pending = all.filter(m => !(m.commentedBy || []).includes(roleId));
      return pending.slice(0, limit);
    }

    // 7) 将 AI 的评论写回数据库并标记 commentedBy
    async function markMomentsCommentedBy(commentsArray, roleId) {
      // commentsArray: [{momentId, commentText}, ...]
      try {
        await db.transaction('rw', db.moments, async () => {
          for (const c of commentsArray) {
            const m = await db.moments.get(c.momentId);
            if (!m) continue;
            const cbSet = new Set(m.commentedBy || []);
            cbSet.add(roleId);
            m.commentedBy = Array.from(cbSet);
            m.comments = m.comments || [];
            m.comments.push({ roleId, text: c.commentText, ts: Date.now() });
            await db.moments.put(m);
          }
        });
        renderMoments();
      } catch (e) {
        console.error('mark comments err', e);
      }
    }

    // 8) hook 底部导航显示逻辑（只在聊天列表 screen 可见时显示）
    // 把 bottom-nav-host 插入到 .phone-screen 内底部，使它在聊天页底部显示
    const phoneScreen = document.querySelector('.phone-screen');

    // === Step3 fix: ensure modal overlays are placed inside .phone-screen so absolute positioning works ===
    (function ensureModalsInPhoneScreen() {
      try {
        const phone = document.querySelector('.phone-screen');
        if (!phone) return;
        // move all modal overlays (only once)
        const modalSelectors = ['#post-modal', '.modal-overlay', '#sticker-modal', '#add-sticker-modal', '#time-skip-modal', '#group-recipient-selection-modal'];
        // Use querySelectorAll to move elements that exist and are not already inside phone
        document.querySelectorAll('.modal-overlay, .action-sheet-overlay, .settings-sidebar, #post-modal, #sticker-modal, #add-sticker-modal, #time-skip-modal, #group-recipient-selection-modal').forEach(el => {
          if (!el) return;
          if (phone.contains(el)) return;
          phone.appendChild(el);
        });
      } catch (e) {
        console.error('ensureModalsInPhoneScreen error', e);
      }
    })();

    
if (phoneScreen && bottomNavHost) {
      // 把导航放入 chat-list-screen 底部，使其仅在该 screen 内渲染与定位
      const chatListScreen = document.getElementById('chat-list-screen');
      if (phoneScreen && bottomNavHost.parentElement !== phoneScreen) {
        phoneScreen.appendChild(bottomNavHost);
      }
      bottomNavHost.style.display = 'none'; // 初始隐藏

      // --- 新增：为用户评论按钮添加事件委托 ---
      momentsContainer.addEventListener('click', async (e) => {
          const postBtn = e.target.closest('.post-comment-btn');
          if (postBtn) {
              e.preventDefault();
              const momentId = postBtn.dataset.momentId;
              const input = postBtn.previousElementSibling;
              const commentText = input.value.trim();
              if (commentText) {
                  await saveUserComment(momentId, commentText);
                  input.value = ''; // 清空输入框
              } else {
                  showToast('评论内容不能为空');
              }
          }
      });

      // 绑定按钮（若已有绑定则保持）
      const navButtons = bottomNavHost.querySelectorAll('.nav-btn');
      navButtons.forEach(btn => {
        if (btn._bound) return;
        btn.addEventListener('click', () => {
          navButtons.forEach(b=>b.classList.remove('active'));
          btn.classList.add('active');
          const target = btn.getAttribute('data-target');
          if (typeof window.switchScreen === 'function') {
            window.switchScreen(target);
          } else {
            // 简单回退：切换 active 类并触发自定义事件
            document.querySelectorAll('.screen').forEach(s => s.classList.toggle('active', s.id === target));
            document.dispatchEvent(new CustomEvent('app:screenChanged', { detail: { targetId: target } }));
          }
        });
        btn._bound = true;
      });

      // 初始：如果当前 active 是 chat-list-screen，则显示并保持 chat 按钮 active
      const initActive = document.querySelector('.screen.active');
      if (initActive && initActive.id === 'chat-list-screen') {
        bottomNavHost.style.display = '';
        navButtons.forEach(b => b.classList.toggle('active', b.getAttribute('data-target') === 'chat-list-screen'));
      }

      // 位置更新函数：根据 chat-list-screen 的 active 类显示/隐藏
      function updateBottomNavVisibilityByActive() {
        const chatCls = document.getElementById('chat-list-screen');
        const momentsCls = document.getElementById('moments-screen');
        if ((chatCls && chatCls.classList.contains('active')) || (momentsCls && momentsCls.classList.contains('active'))) {
          bottomNavHost.style.display = '';
        } else {
          bottomNavHost.style.display = 'none';
        }
      }
      // 立即执行一次
      updateBottomNavVisibilityByActive();

      // 监听 .phone-screen 下 class 变化（屏幕切换通常会触发 class 变化）
      const moTarget = phoneScreen;
      try {
        const mo = new MutationObserver(() => updateBottomNavVisibilityByActive());
        mo.observe(moTarget, { attributes: true, subtree: true, attributeFilter: ['class'] });
      } catch (e) {
        // ignore observer errors
      }
    }
    // 全局切换 screen 的小函数（与页面已有切换保持一致）
    function switchScreen(targetId) {
      // 仅切换 active 类，避免直接改写 style.display 导致布局（flex）异常
      document.querySelectorAll('.screen').forEach(s => {
        s.classList.toggle('active', s.id === targetId);
      });
      // 触发全局事件，通知其他模块屏幕已切换
      try {
        const ev = new CustomEvent('app:screenChanged', { detail: { targetId } });
        document.dispatchEvent(ev);
      } catch (e) {
        console.warn('dispatch app:screenChanged failed', e);
      }
      // 如果进入 moments-screen，渲染
      if (targetId === 'moments-screen' && typeof renderMoments === 'function') renderMoments();
    }

    // 9) 将动态内容与聊天一起发给 AI（挂到 #get-reply-btn）
    const getReplyBtn = $('#get-reply-btn');
    if (getReplyBtn) {
      getReplyBtn.addEventListener('click', async (ev) => {
        // Determine current roleId: try chat-room-title text
        const roleTitleEl = $('#chat-room-title');
        let roleId = roleTitleEl ? roleTitleEl.textContent.trim() : 'role_unknown';
        if (!roleId) roleId = 'role_unknown';

        // collect chat history from #message-area DOM
        const chatArea = $('#message-area');
        let chatText = '';
        if (chatArea) {
          const messages = chatArea.querySelectorAll('.message-bubble');
          const arr = [];
          messages.forEach(mb => {
            // get role name if exists, else fallback to bubble's class
            const wrapper = mb.closest('.message-wrapper');
            let who = wrapper && wrapper.classList.contains('sent') ? '我' : (wrapper && wrapper.classList.contains('received') ? roleId : '');
            arr.push(`${who}: ${mb.textContent.trim()}`);
          });
          chatText = arr.join('\n');
        }

        // pending moments
        const pending = await getPendingMomentsForRole(roleId, 5);

        // build a structured prompt (we'll ask AI to return JSON)
        let prompt = `系统：请按 JSON 格式输出：{"chat_reply":"...","moment_comments":[{"momentId":"...","comment":"..."}]}\n\n`;
        prompt += `聊天记录：\n${chatText}\n\n`;
        if (pending && pending.length) {
          prompt += `需要评论的动态（最多 ${pending.length} 条，按序对应 id）：\n`;
          pending.forEach((m, i) => {
            prompt += `${i+1}) id:${m.id}\ntext:${m.text}\nimageDesc:${m.imageDesc || ''}\n\n`;
          });
        } else {
          prompt += '（无待评论的动态）\n';
        }

        // Try to call existing global sendToAI-like function if exists
        let aiRaw = null;
        try {
          if (typeof window.sendToAI === 'function') {
            aiRaw = await window.sendToAI(prompt);
          } else if (typeof window.callAI === 'function') {
            aiRaw = await window.callAI(prompt);
          } else if (typeof window.sendMessageToModel === 'function') {
            aiRaw = await window.sendMessageToModel(prompt);
          }
        } catch (e) {
          console.error('AI call failed', e);
          showToast('AI 请求失败：' + (e.message || e));
          return;
        }

        // 解析 AI 返回（优先 JSON）
        let parsed = null;
        try {
          parsed = typeof aiRaw === 'string' ? JSON.parse(aiRaw) : aiRaw;
        } catch (e) {
          // fallback: 使用原始文本作为 chat 回复
          parsed = { chat_reply: String(aiRaw || ''), moment_comments: [] };
        }

        // 处理聊天回复：把 parsed.chat_reply 插入聊天区域（若页面已有 appendAIMessageToChat 函数优先使用）
        if (parsed && parsed.chat_reply) {
          if (typeof window.appendAIMessageToChat === 'function') {
            window.appendAIMessageToChat(parsed.chat_reply, roleId);
          } else {
            // 尝试在页面直接插入（如果 message-area 存在）
            const mArea = $('#message-area');
            if (mArea) {
              const wrapper = document.createElement('div');
              wrapper.className = 'message-wrapper received';
              const row = document.createElement('div');
              row.className = 'message-bubble received';
              row.textContent = parsed.chat_reply;
              wrapper.appendChild(row);
              mArea.appendChild(wrapper);
              mArea.scrollTop = mArea.scrollHeight;
            }
          }
        }

        // 处理 moment 评论
        if (parsed && Array.isArray(parsed.moment_comments) && parsed.moment_comments.length) {
          // Normalize to array of {momentId, commentText}
          const normalized = parsed.moment_comments.map(mc => {
            return { momentId: mc.momentId || mc.momentId || mc.id || mc.id, commentText: mc.comment || mc.commentText || mc.text || '' };
          }).filter(x => x.momentId);
          if (normalized.length) {
            await markMomentsCommentedBy(normalized, roleId);
          }
        }

      }); // end getReplyBtn click
    } // end if getReplyBtn

    // small toast helper (reuse existing #toast-notification if exists)
    function showToast(msg, timeout = 2400) {
      const t = $('#toast-notification');
      if (t) {
        t.textContent = msg;
        t.classList.add('show');
        setTimeout(()=>t.classList.remove('show'), timeout);
      } else {
        // fallback
        alert(msg);
      }
    }

    /* simulateAIResponse removed: local simulated AI replies disabled by user request */

// 初始：如果页面当前在 chat-list-screen，显示 bottom nav
    const currentActive = document.querySelector('.screen.active');
    if (currentActive && currentActive.id === 'chat-list-screen') {
      // keep bottom nav visible and make chat button active
      const botNav = document.getElementById('bottom-nav');
      if (botNav) {
        botNav.querySelectorAll('.nav-btn').forEach(b => b.classList.toggle('active', b.getAttribute('data-target') === 'chat-list-screen'));
      }
    }

    // 如果初始存在 moments screen active，则 render
    if (currentActive && currentActive.id === 'moments-screen') renderMoments();

    // --- 将关键函数暴露到全局作用域，以便其他模块调用 ---
    window.getPendingMomentsForRole = getPendingMomentsForRole;
    window.saveMomentComment = saveMomentComment;
    window.saveMomentLike = saveMomentLike;
    window.markMomentsCommentedBy = markMomentsCommentedBy;
    window.renderMoments = renderMoments; // 暴露渲染函数，以便外部模块可以刷新动态列表

  }); // DOMContentLoaded end
})();
</script>


<!-- Begin: Render moments safe patch (injected for step4) -->
<script>
(function(){
  console.log('[injected patch] renderMomentsSafe initializing...');
  try {
    const momentsScreen = document.getElementById('moments-screen');
    if (!momentsScreen) {
      console.warn('[injected patch] #moments-screen not found.');
    }
    // Ensure a container exists
    let momentsContainer = document.getElementById('moments-container');
    if (!momentsContainer && momentsScreen) {
      const content = momentsScreen.querySelector('.content') || momentsScreen;
      momentsContainer = document.createElement('div');
      momentsContainer.id = 'moments-container';
      content.appendChild(momentsContainer);
      console.log('[injected patch] created #moments-container');
    }
    // Safe Dexie wrapper
    let _db = null;
    if (typeof Dexie !== 'undefined') {
        // Use the existing global instance if available
        if (window.AppDB_Moments) {
            _db = window.AppDB_Moments;
        } else {
            try {
                _db = new Dexie('AppDB_Moments');
                _db.version(1).stores({ moments: 'id,timestamp,commentedBy' });
                window.AppDB_Moments = _db; // Ensure it's globally available
            } catch (e) {
                console.warn('[injected patch] Dexie init failed:', e);
                _db = null;
            }
        }
    } else {
        console.warn('[injected patch] Dexie not available.');
    }

    window.renderMomentsSafe = async function renderMomentsSafe() {
      try {
        const container = document.getElementById('moments-container') || (document.getElementById('moments-screen') && document.getElementById('moments-screen').querySelector('#moments-container'));
        if (!container) {
          console.warn('[injected patch] No container found for moments.');
          return;
        }
        let list = [];
        if (_db && _db.moments) {
          try {
            list = await _db.moments.orderBy('timestamp').reverse().toArray();
          } catch (e) {
            console.error('[injected patch] Failed reading moments from IndexedDB:', e);
            list = [];
          }
        } else {
          // try fallback global db objects if present
          try {
            const maybeDb = window.AppDB_Moments || null;
            if (maybeDb && maybeDb.moments) {
              list = await maybeDb.moments.orderBy('timestamp').reverse().toArray();
            }
          } catch (e) {
            list = [];
          }
        }

        container.innerHTML = '';
        const momentsEmpty = document.getElementById('moments-empty');
        if (!list || !list.length) {
          if (momentsEmpty) momentsEmpty.style.display = 'block';
          else {
            const p = document.createElement('p');
            p.className = 'placeholder-text';
            p.textContent = '还没有动态，点击右上角发布吧~';
            container.appendChild(p);
          }
          return;
        } else {
          if (momentsEmpty) momentsEmpty.style.display = 'none';
        }

        list.forEach(m => {
          try {
            const div = document.createElement('div'); div.className = 'moment-item';
            div.dataset.id = m.id || (m.id = (Math.random()+''+Date.now()));
            const head = document.createElement('div'); head.className = 'moment-head';
            const avatar = document.createElement('img'); avatar.className = 'moment-avatar';
            avatar.src = m.authorAvatar || 'data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%3E%3Crect%20width%3D%22100%25%22%20height%3D%22100%25%22%20fill%3D%22%23e9f5ff%22/%3E%3Ccircle%20cx%3D%2232%22%20cy%3D%2224%22%20r%3D%2212%22%20fill%3D%22%237fb3ff%22/%3E%3Crect%20x%3D%228%22%20y%3D%2240%22%20width%3D%2248%22%20height%3D%2212%22%20rx%3D%226%22%20fill%3D%22%23cfe9ff%22/%3E%3C/svg%3E';
            const meta = document.createElement('div'); meta.className = 'moment-meta';
            const name = document.createElement('div'); name.textContent = window.getAuthorNameById(m.authorId) || m.author || '我'; name.style.fontWeight='700';
            const time = document.createElement('div'); time.style.fontSize='12px'; time.style.color='#999';
            try { time.textContent = new Date(m.timestamp).toLocaleString(); } catch(e) { time.textContent = ''; }
            meta.appendChild(name); meta.appendChild(time);
            head.appendChild(avatar); head.appendChild(meta);
            div.appendChild(head);

            const txt = document.createElement('div'); txt.className='moment-text'; txt.textContent = m.text || '';
            div.appendChild(txt);

            if (m.imageData && m.imageData !== 'null' && m.imageData !== 'undefined' && m.imageData.length>10) {
  const im = document.createElement('img'); im.className = 'moment-image';
  im.src = m.imageData;
  im.alt = m.imageDesc ? m.imageDesc : (m.text || '动态图片');
  div.appendChild(im);
  if (m.imageDesc) {
    const desc = document.createElement('div'); desc.style.fontSize='13px'; desc.style.color='#666';
    desc.textContent = '图片：' + m.imageDesc;
    div.appendChild(desc);
  }
} else if (m.imageDesc) {
  const descCard = document.createElement('div'); descCard.className = 'moment-image-desc-card';
  if (m.id) descCard.dataset.momentId = m.id || '';
  const descContent = document.createElement('p'); descContent.className = 'desc-content';
  descContent.textContent = m.imageDesc;
  descCard.appendChild(descContent);
  descCard.setAttribute('role', 'img');
  descCard.setAttribute('aria-label', m.imageDesc);
  descCard.addEventListener('click', function () { /* show detail */ });
  div.appendChild(descCard);
}

        // --- 新增：点赞和评论的UI与逻辑 ---
        const actions = document.createElement('div');
        actions.className = 'moment-actions';
        
        const likeBtn = document.createElement('button');
        likeBtn.className = 'moment-action-btn';
        const likes = m.likes || [];
        const myProfile = loadProfileFromStorage();
        const myId = myProfile.id || 'user';
        if (likes.includes(myId)) {
            likeBtn.classList.add('liked');
        }
        likeBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg><span>${likes.length > 0 ? likes.length : '点赞'}</span>`;
        
        likeBtn.addEventListener('click', async (event) => {
            const btn = event.currentTarget;
            const momentItem = btn.closest('.moment-item');
            const currentLikes = m.likes || [];
            const myIdx = currentLikes.indexOf(myId);

            if (myIdx > -1) {
                currentLikes.splice(myIdx, 1);
                btn.classList.remove('liked');
            } else {
                currentLikes.push(myId);
                btn.classList.add('liked');
            }
            m.likes = currentLikes;
            await db.moments.put(m);

            // 直接更新UI，避免重新渲染整个列表
            const span = btn.querySelector('span');
            if (span) {
                span.textContent = currentLikes.length > 0 ? currentLikes.length : '点赞';
            }

            const likesWrap = momentItem.querySelector('.moment-likes');
            if (likesWrap) {
                if (currentLikes.length > 0) {
                    const likeNames = currentLikes.map(likeId => window.getAuthorNameById(likeId)).join(', ');
                    likesWrap.innerHTML = `<span class="like-icon">♥</span> ${likeNames}`;
                    likesWrap.classList.add('visible');
                } else {
                    likesWrap.classList.remove('visible');
                }
            }
        });

        const commentBtn = document.createElement('button');
        commentBtn.className = 'moment-action-btn';
        commentBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg><span>评论</span>`;
        commentBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            const btn = event.currentTarget;
            const momentItem = btn.closest('.moment-item');
            if (momentItem) {
                const inputArea = momentItem.querySelector('.moment-comment-input-area');
                if (inputArea) {
                    inputArea.classList.toggle('visible');
                    if (inputArea.classList.contains('visible')) {
                        inputArea.querySelector('input').focus();
                    }
                }
            }
        });

        actions.appendChild(likeBtn);
        actions.appendChild(commentBtn);
        div.appendChild(actions);

        // 点赞列表
        if (likes.length > 0) {
            const likesWrap = document.createElement('div');
            likesWrap.className = 'moment-likes visible';
            const likeNames = likes.map(likeId => window.getAuthorNameById(likeId)).join(', ');
            likesWrap.innerHTML = `<span class="like-icon">♥</span> ${likeNames}`;
            div.appendChild(likesWrap);
        }

        // comments
        const commentsWrap = document.createElement('div'); commentsWrap.className = 'moment-comments';
        if (m.comments && m.comments.length) {
          m.comments.forEach(c => {
            const cm = document.createElement('div'); cm.className='moment-comment';
            const authorName = window.getAuthorNameById(c.roleId || c.role);
            cm.textContent = `${authorName}：${c.text}`;
            commentsWrap.appendChild(cm);
          });
        } else {
          const none = document.createElement('div'); none.style.color='#bbb'; none.textContent = '暂时没有评论';
          commentsWrap.appendChild(none);
        }
        div.appendChild(commentsWrap);

        // --- 新增：用户评论输入框 ---
        const commentInputArea = document.createElement('div');
        commentInputArea.className = 'moment-comment-input-area';
        commentInputArea.innerHTML = `
          <input type="text" class="moment-comment-input" placeholder="添加评论...">
          <button class="post-comment-btn" data-moment-id="${m.id}">发布</button>
        `;
        div.appendChild(commentInputArea);
            container.appendChild(div);
          } catch (innerErr) {
            console.error('[injected patch] render single moment failed', innerErr, m);
          }
        });

      } catch (err) {
        console.error('[injected patch] renderMomentsSafe failed', err);
        const container = document.getElementById('moments-container') || (document.getElementById('moments-screen') && document.getElementById('moments-screen').querySelector('.content'));
        if (container) {
          container.innerHTML = '<div style="color:#b00;padding:12px;border-radius:10px;background:#fff8f8;">加载动态时出错（详情见 Console）</div>';
        }
      }
    };

    // Attach to app:screenChanged and mutation observer
    document.addEventListener('app:screenChanged', (ev) => {
      try {
        if (ev && ev.detail && ev.detail.targetId === 'moments-screen') {
          window.renderMomentsSafe();
        }
      } catch (e) { console.error('[injected patch] app:screenChanged handler failed', e); }
    });

    const phone = document.querySelector('.phone-screen') || document.body;
    const mo = new MutationObserver((mutations) => {
  try {
    // 只在 phone 节点本身的 class 发生变化时才触发（避免子元素的 class 变动导致重渲染）
    const phoneClassChanged = mutations.some(m =>
      m.type === 'attributes' && m.attributeName === 'class' && m.target === phone
    );
    if (!phoneClassChanged) return;

    const active = document.querySelector('.screen.active');
    if (active && active.id === 'moments-screen') {
      window.renderMomentsSafe();
    }
  } catch (e) { console.error('[injected patch] MutationObserver callback failed', e); }
});
// 仅观察 phone 自身的 attributes（不要 subtree=true）
mo.observe(phone, { attributes: true, subtree: false, attributeFilter: ['class'] });


    // try initial render
    setTimeout(() => {
      try { window.renderMomentsSafe(); } catch(e) { console.warn('[injected patch] initial render failed', e); }
    }, 300);

  } catch (e) {
    console.error('[injected patch] initialization failed', e);
  }
})();
</script>
<!-- End: Render moments safe patch -->


<script>
/* === 确保 #moments-screen 永远在 .phone-screen 内，并清除会把它推出视窗的内联样式 (自动插入补丁) === */

(function ensureMomentsStaysInPhone() {
  function fixPlacementAndStyles() {
    const phone = document.querySelector('.phone-screen');
    const moments = document.getElementById('moments-screen');
    if (!phone) return;

    // If moments exists, ensure it's inside phone but *do not force inline styles on it*
    if (moments && !phone.contains(moments)) {
      phone.appendChild(moments);
      console.log('[patch] moved #moments-screen into .phone-screen');
    }

    // Only normalize styles for screens *other than* moments-screen or elements managed by injection
    document.querySelectorAll('.screen').forEach(s => {
      if (s.id === 'moments-screen' || s.dataset.managedBy === 'injection') {
        // make sure its stacking context is reasonable but don't clobber its layout
        s.style.zIndex = s.style.zIndex || '0';
        return;
      }
      // Apply conservative safe defaults to other screens
      s.style.position = s.style.position || 'absolute';
      s.style.top = s.style.top || '0';
      s.style.left = s.style.left || '0';
      s.style.right = s.style.right || '0';
      s.style.bottom = s.style.bottom || '0';
      // Avoid removing transforms which some screens might rely on; only clear very specific problematic inline styles
      if ((s.style.transform || '').includes('translate') || (s.style.transform || '').includes('translateY')) {
        // leave transforms intact to avoid breaking animations
      } else {
        s.style.transform = s.style.transform || '';
      }
      s.style.margin = s.style.margin || '';
      // ensure screens stack below nav/modals
      s.style.zIndex = s.style.zIndex || '0';
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', fixPlacementAndStyles);
  } else {
    fixPlacementAndStyles();
  }
  // only run on custom app events; do not poll aggressively to avoid fighting the injected UI
  document.addEventListener('app:screenChanged', fixPlacementAndStyles);
  // run a very infrequent check as a last resort
  setInterval(fixPlacementAndStyles, 5000);
})();
</script>

<!-- === /patch === -->

<!-- Avatar overlap CSS override (scaled to 70%) inserted by assistant -->
<style>
.icity-moments-inner {
  --icity-hero-h: 154px;      /* 70% of original 220px */
  --icity-avatar-size: 98px;  /* 70% of original 140px */
  position: relative;
  box-sizing: border-box;
}

.icity-hero {
  height: var(--icity-hero-h) !important;
  position: relative;
  overflow: hidden;
  border-radius: 14px 14px 0 0;
  box-sizing: border-box;
}

.icity-avatar-wrap {
  position: absolute !important;
  left: 50% !important;
  transform: translateX(-50%) !important;
  width: var(--icity-avatar-size) !important;
  height: var(--icity-avatar-size) !important;
  border-radius: 50% !important;
  top: calc(var(--icity-hero-h) - (var(--icity-avatar-size) * 0.7)) !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  z-index: 50 !important;
  background: #fff !important;
  box-shadow: 0 8px 22px rgba(0,0,0,0.12) !important;
  border: 6px solid rgba(255,255,255,0.95) !important;
  box-sizing: border-box !important;
  overflow: visible !important;
}

.icity-avatar-wrap img,
.icity-avatar-wrap .avatar-img {
  width: 80% !important;
  height: 80% !important;
  border-radius: 50% !important;
  object-fit: cover !important;
  display: block !important;
}

.icity-info-card {
  position: relative !important;
  padding-top: calc(var(--icity-avatar-size) * 0.2 + 4px) !important; /* Reduced top padding */
  padding-right: 18px !important;
  padding-left: 18px !important;
  padding-bottom: 10px !important; /* Reduced bottom padding */
  margin-top: 10px !important;
  background: #fff !important;
  border-radius: 14px !important;
  box-shadow: 0 6px 18px rgba(0,0,0,0.04) !important;
  box-sizing: border-box !important;
  text-align: center !important;
}

/* Reduce vertical spacing and font sizes for a more compact info card */
.icity-name {
    font-size: 18px !important;
    line-height: 1.1 !important;
}
.icity-id-loc {
    margin-top: 6px !important;
    font-size: 12px !important;
    line-height: 1.1 !important;
}
.icity-signature {
    margin-top: 8px !important;
    font-size: 13px !important;
    line-height: 1.2 !important;
}

@media (max-width: 420px) {
  .icity-moments-inner {
    --icity-hero-h: 112px;  /* 70% of previous 160px */
    --icity-avatar-size: 77px; /* 70% of previous 110px */
  }
}
</style>
<!-- End assistant-inserted CSS -->

<!-- === Avatar & Background Edit Feature === -->
<div class="action-sheet-overlay" id="edit-top-section-actionsheet">
  <div class="action-sheet">
    <button class="action-sheet-button" id="edit-bg-btn">更换背景图</button>
    <button class="action-sheet-button" id="edit-avatar-btn">更换头像</button>
    <button class="action-sheet-button danger" id="cancel-edit-top-btn">取消</button>
  </div>
</div>
<input type="file" accept="image/*" id="top-section-file-input" style="display:none;" />

<script>
(function(){
    const topSection = document.querySelector('#moments-screen .icity-moments-inner .icity-hero') || document.querySelector('#moments-screen .icity-hero') || document.querySelector('#moments-screen .top-section') || document.querySelector('#moments-screen header');
    const editSheet = document.getElementById('edit-top-section-actionsheet');
    const bgBtn = document.getElementById('edit-bg-btn');
    const avatarBtn = document.getElementById('edit-avatar-btn');
    const cancelBtn = document.getElementById('cancel-edit-top-btn');
    const fileInput = document.getElementById('top-section-file-input');

    let currentEditTarget = null;

    // Restore saved bg & avatar
    const savedBg = localStorage.getItem('myTopBg');
    const savedAvatar = localStorage.getItem('myTopAvatar');
    if(savedBg && topSection) {
        topSection.style.backgroundImage = `url('${savedBg}')`;
        topSection.style.backgroundSize = 'cover';
        topSection.style.backgroundPosition = 'center';
    }
    if(savedAvatar) {
        document.querySelectorAll('.my-avatar, #moments-screen .top-avatar').forEach(img=>{
            if(img.tagName === 'IMG') img.src = savedAvatar;
            else img.style.backgroundImage = `url('${savedAvatar}')`;
        });
    }

    // Previously opened the whole topSection on click — removed to avoid accidental edits during publish.
    // Now only explicit edit controls (avatar/background buttons and per-field clicks) will trigger edits.

    cancelBtn.addEventListener('click', ()=>{
        editSheet.classList.remove('visible');
    });

    function chooseSource(targetType) {
        const url = prompt('输入图片URL，或留空选择本地文件：');
        if(url) {
            applyImage(targetType, url);
        } else {
            currentEditTarget = targetType;
            fileInput.click();
        }
    }

    function applyImage(targetType, dataUrl) {
        if(targetType === 'bg') {
            if(topSection) {
                topSection.style.backgroundImage = `url('${dataUrl}')`;
                topSection.style.backgroundSize = 'cover';
                topSection.style.backgroundPosition = 'center';
            }
            localStorage.setItem('myTopBg', dataUrl);
        } else if(targetType === 'avatar') {
            localStorage.setItem('myTopAvatar', dataUrl);
            document.querySelectorAll('.my-avatar, #moments-screen .top-avatar').forEach(img=>{
                if(img.tagName === 'IMG') img.src = dataUrl;
                else img.style.backgroundImage = `url('${dataUrl}')`;
            });
            // 同步动态列表头像（moment-avatar 为动态列表头像类）
            document.querySelectorAll('.post .avatar-img, .moment-avatar').forEach(img => {
                if(img.tagName === 'IMG') img.src = dataUrl;
                else img.style.backgroundImage = `url('${dataUrl}')`;
            });
            // 尝试更新数据库中属于当前用户(authorId匹配)或无 authorId 但 author 名称匹配的 moments 的 authorAvatar 字段（若存在 db）
            try{
                if(window.AppDB_Moments && typeof AppDB_Moments !== 'undefined' && AppDB_Moments.moments){
                    (async ()=>{
                        try{
                            const all = await AppDB_Moments.moments.toArray();
                            const profile = (typeof loadProfileFromStorage === 'function') ? loadProfileFromStorage() : {
                                name: localStorage.getItem('myTopName') || '我',
                                id: localStorage.getItem('myTopId') || 'user',
                                avatar: localStorage.getItem('myTopAvatar') || null
                            };
                            for(const m of all){
                                // Update moments that explicitly reference this author's id
                                if((m.authorId && m.authorId === profile.id) || (!m.authorId && m.author === profile.name)){
                                    m.authorAvatar = dataUrl;
                                    // If the moment had no authorId, bind it to current profile.id so future syncs work
                                    if(!m.authorId) m.authorId = profile.id;
                                    try{ await AppDB_Moments.moments.put(m); }catch(e){ /* ignore put errors for individual items */ }
                                }
                            }
                            // After DB updates, re-render moments so DOM reflects DB changes
                            if(typeof renderMoments === 'function') try{ renderMoments(); }catch(e){}
                            else if(typeof window.renderMomentsSafe === 'function') try{ window.renderMomentsSafe(); }catch(e){}
                        }catch(e){}
                    })();
                }
            }catch(e){}
            // Ensure profile render + sync runs to update in-memory DOM and trigger any re-renders
            try{ if(typeof renderProfileAndSync === 'function') renderProfileAndSync(); }catch(e){}
        }
    }
fileInput.addEventListener('change', async (e)=>{
        const file = e.target.files[0];
        if(file) {
            try {
                const compressedUrl = await compressImage(file, { quality: 0.85, maxWidth: 1080, maxHeight: 1920 });
                applyImage(currentEditTarget, compressedUrl);
            } catch (error) {
                if(typeof showToast === 'function') showToast('图片处理失败，请重试');
                console.error('Background image compression failed:', error);
            }
        }
    });

    bgBtn.addEventListener('click', ()=> chooseSource('bg'));
    avatarBtn.addEventListener('click', ()=> chooseSource('avatar'));
})();
</script>
<!-- === /Avatar & Background Edit Feature === -->


<!-- Avatar sync patch: non-invasive, appended to avoid modifying original logic.
     Purpose: ensure top avatar updates immediately and moments list does not revert
     by synchronizing DOM and (if possible) the DB after avatar changes. -->
<script>
(function(){
  'use strict';

  // Utility: load profile from existing function if available, otherwise from localStorage
  function loadProfileFallback(){
    try {
      if(typeof loadProfileFromStorage === 'function'){
        var p = loadProfileFromStorage();
        if(p && (p.avatar || p.id || p.name)) return p;
      }
    } catch(e){}
    // fallback to localStorage keys used by the app
    try {
      return {
        id: localStorage.getItem('myTopId') || localStorage.getItem('icity-id') || localStorage.getItem('userId') || null,
        name: localStorage.getItem('myTopName') || localStorage.getItem('icity-name') || localStorage.getItem('userName') || null,
        avatar: localStorage.getItem('myTopAvatar') || localStorage.getItem('icity-avatar-src') || localStorage.getItem('userAvatar') || null,
        signature: localStorage.getItem('myTopSignature') || null,
        location: localStorage.getItem('myTopLocation') || null
      };
    } catch(e){
      return {};
    }
  }

  // Robustly update top-profile DOM elements and common avatar selectors
  function updateTopProfileAndAvatars(){
    try {
      var p = loadProfileFallback() || {};
      var avatar = p.avatar || null;
      // find common top avatar elements
      var avatarSelectors = [
        '#icity-avatar', // explicit id
        '.icity-avatar-wrap img',
        '.top-avatar',
        '.my-avatar',
        '.header-avatar img',
        '.profile-avatar img'
      ];
      avatarSelectors.forEach(function(sel){
        document.querySelectorAll(sel).forEach(function(el){
          try {
            if(!el) return;
            if(el.tagName === 'IMG'){
              if(avatar) el.src = avatar;
            } else {
              if(avatar) el.style.backgroundImage = "url('"+avatar+"')";
            }
          } catch(e){}
        });
      });

      // update textual profile elements defensively
      var nameEls = [document.getElementById('icity-name'), document.querySelector('.icity-name'), document.querySelector('.profile-name')];
      nameEls.forEach(function(el){
        if(el && p.name) try{ el.textContent = p.name; }catch(e){}
      });
      var sigEls = [document.getElementById('icity-signature'), document.querySelector('.icity-signature')];
      sigEls.forEach(function(el){
        if(el && p.signature) try{ el.textContent = p.signature; }catch(e){}
      });

      // update moments list avatars for moments authored by current profile (best-effort)
      try {
        var id = p.id || null;
        var name = p.name || null;
        var avatars = document.querySelectorAll('.moment-avatar, .post .avatar-img, .post .author-avatar, .item .avatar, .comment .avatar, img[data-role="avatar"]');
        avatars.forEach(function(img){
          try {
            if(!img) return;
            // try dataset or attributes
            var authorId = img.getAttribute('data-author-id') || img.dataset && img.dataset.authorId || null;
            var authorName = img.getAttribute('data-author') || img.getAttribute('data-author-name') || img.dataset && img.dataset.author || null;

            // also try to find author id/name from closest ancestor
            if(!authorId || !authorName){
              var ancestor = img.closest('[data-author-id], [data-author], .moment, .post');
              if(ancestor){
                if(!authorId) authorId = ancestor.getAttribute('data-author-id') || ancestor.getAttribute('data-author') || null;
                if(!authorName) authorName = ancestor.getAttribute('data-author-name') || ancestor.getAttribute('data-author') || null;
                // check for .author-name text
                if(!authorName){
                  var an = ancestor.querySelector('.author-name, .name, .post-author');
                  if(an) authorName = (an.textContent || '').trim();
                }
              }
            }

            // Decision: if authorId matches, or authorName matches (best-effort), update the img.src
            var shouldUpdate = false;
            if(id && authorId && String(authorId) === String(id)) shouldUpdate = true;
            if(!shouldUpdate && name && authorName && String((authorName||'').trim()) === String((name||'').trim())) shouldUpdate = true;

            if(shouldUpdate && avatar){
              if(img.tagName === 'IMG'){
                img.src = avatar;
              } else {
                img.style.backgroundImage = "url('"+avatar+"')";
              }
            }
          } catch(e){}
        });
      } catch(e){}
    } catch(e){}
  }

  // Try to update a Dexie/DB moments table authorAvatar entries for current user (best-effort, non-blocking)
  function tryUpdateDBMomentsAvatar(newAvatar){
    try {
      var p = loadProfileFallback();
      if(!p || !p.id || !newAvatar) return;
      // if window.AppDB_Moments and Dexie-like table exists, try to update entries where authorId matches
      if(window.AppDB_Moments && window.AppDB_Moments.moments){
        try {
          // If it's Dexie or has where API
          if(typeof window.AppDB_Moments.moments.where === 'function' && typeof window.AppDB_Moments.moments.toArray === 'function'){
            // best-effort: update authorAvatar for matching authorId
            // .where('authorId').equals(p.id).modify({ authorAvatar: newAvatar }) might exist
            if(typeof window.AppDB_Moments.moments.where === 'function'){
              try {
                var q = window.AppDB_Moments.moments.where('authorId').equals(p.id);
                if(q && typeof q.modify === 'function'){
                  q.modify(function(obj){ obj.authorAvatar = newAvatar; });
                } else {
                  // fallback: scan and put
                  window.AppDB_Moments.moments.toArray().then(function(arr){
                    arr.forEach(function(item){
                      try {
                        if(item.authorId && String(item.authorId) === String(p.id)){
                          item.authorAvatar = newAvatar;
                          if(window.AppDB_Moments.moments.put) window.AppDB_Moments.moments.put(item);
                        }
                      } catch(e){}
                    });
                  }).catch(function(){});
                }
              } catch(e){}
            }
          } else if(typeof window.AppDB_Moments.moments.update === 'function'){
            // unknown API: attempt to update each by scanning
            try {
              window.AppDB_Moments.moments.toArray().then(function(arr){
                arr.forEach(function(item){
                  if(item.authorId && String(item.authorId) === String(p.id)){
                    item.authorAvatar = newAvatar;
                    try { window.AppDB_Moments.moments.update(item.id, item); } catch(e){}
                  }
                });
              }).catch(function(){});
            } catch(e){}
          }
        } catch(e){}
      }
    } catch(e){}
  }

  // Wrap existing applyImage (if present) so after changing avatar we sync
  if(typeof window.applyImage === 'function'){
    try {
      var origApplyImage = window.applyImage;
      window.applyImage = function(){
        try {
          var res = origApplyImage.apply(this, arguments);
          // schedule sync shortly after (some apps update DOM async)
          setTimeout(function(){
            try {
              updateTopProfileAndAvatars();
              var p = loadProfileFallback();
              if(p && p.avatar) tryUpdateDBMomentsAvatar(p.avatar);
            } catch(e){}
          }, 100);
          return res;
        } catch(e){
          try { return origApplyImage.apply(this, arguments); } catch(e){ return undefined; }
        }
      };
    } catch(e){}
  } else {
    // If applyImage not found, expose a safe function for callers to use
    window.__syncAvatarsAfterChange = function(){
      try {
        updateTopProfileAndAvatars();
        var p = loadProfileFallback();
        if(p && p.avatar) tryUpdateDBMomentsAvatar(p.avatar);
      } catch(e){}
    };
  }

  // If renderMomentsSafe exists, wrap it to call our sync after running original
  if(typeof window.renderMomentsSafe === 'function'){
    try {
      var _origRenderMomentsSafe = window.renderMomentsSafe;
      window.renderMomentsSafe = function(){
        try {
          var res = _origRenderMomentsSafe.apply(this, arguments);
          // after render, ensure our avatars are applied
          setTimeout(function(){ updateTopProfileAndAvatars(); }, 20);
          return res;
        } catch(e){
          try { return _origRenderMomentsSafe.apply(this, arguments); } catch(e){ return undefined; }
        }
      };
    } catch(e){}
  }

  // Also wrap any generic renderMoments function if present
  if(typeof window.renderMoments === 'function'){
    try {
      var _origRenderMoments = window.renderMoments;
      window.renderMoments = function(){
        try {
          var res = _origRenderMoments.apply(this, arguments);
          setTimeout(function(){ updateTopProfileAndAvatars(); }, 20);
          return res;
        } catch(e){
          try { return _origRenderMoments.apply(this, arguments); } catch(e){ return undefined; }
        }
      };
    } catch(e){}
  }

  // Run once at load to align UI with stored avatar (without waiting for user action)
  try { setTimeout(updateTopProfileAndAvatars, 50); } catch(e){}

  // Expose for debugging (non-enumerable)
  try { Object.defineProperty(window, '__updateProfileAndAvatars', { value: updateTopProfileAndAvatars, writable: false }); } catch(e){}

  // Do not interfere with bottom navigation: avoid touching elements with ids/classes typically used by navbars.
  // The script only touches avatar/name related selectors and moment avatars; it is intentionally conservative.

})();
</script>

<!-- Stronger enforcement: bind moment avatars to top avatar persistently -->
<script>
(function(){
  'use strict';
  // Helper to read top avatar from DOM or storage
  function getTopAvatar(){
    try {
      // Try common selectors for top avatar
      var selectors = ['#icity-avatar', '.icity-avatar-wrap img', '.top-avatar', '.header-avatar img', '.profile-avatar img', '.my-avatar'];
      for(var i=0;i<selectors.length;i++){
        var el = document.querySelector(selectors[i]);
        if(el){
          if(el.tagName === 'IMG' && el.src) return el.src;
          var bg = window.getComputedStyle(el).backgroundImage;
          if(bg && bg !== 'none'){
            // extract url("...") content
            var m = bg.match(/url\(["']?(.*?)["']?\)/);
            if(m && m[1]) return m[1];
          }
        }
      }
      // fallback to storage
      var p = null;
      try { if(typeof loadProfileFromStorage === 'function') p = loadProfileFromStorage(); } catch(e){}
      if(!p) p = {
        avatar: localStorage.getItem('myTopAvatar') || localStorage.getItem('userAvatar') || localStorage.getItem('icity-avatar-src')
      };
      if(p && p.avatar) return p.avatar;
    } catch(e){}
    return null;
  }

  // Helper to determine if an avatar img belongs to current user (best-effort)
  function isAvatarForCurrentUser(imgEl){
    try {
      if(!imgEl) return false;
      var p = (typeof loadProfileFromStorage === 'function') ? loadProfileFromStorage() : null;
      if(!p) p = { id: localStorage.getItem('myTopId'), name: localStorage.getItem('myTopName') };
      var authorId = imgEl.getAttribute('data-author-id') || (imgEl.dataset && imgEl.dataset.authorId) || null;
      var authorName = imgEl.getAttribute('data-author') || imgEl.getAttribute('data-author-name') || (imgEl.dataset && imgEl.dataset.author) || null;
      if(!authorId && !authorName){
        var anc = imgEl.closest('[data-author-id], [data-author], .moment, .post, .item');
        if(anc){
          authorId = authorId || anc.getAttribute('data-author-id') || anc.getAttribute('data-author');
          authorName = authorName || anc.getAttribute('data-author-name') || anc.getAttribute('data-author');
          if(!authorName){
            var authorNameNode = anc.querySelector('.author-name, .name, .post-author, .author');
            if(authorNameNode) authorName = (authorNameNode.textContent || '').trim();
          }
        }
      }
      if(p && p.id && authorId && String(p.id) === String(authorId)) return true;
      if(p && p.name && authorName && String((p.name||'').trim()) === String((authorName||'').trim())) return true;
      // Also check if img has attribute data-me or class 'me' etc
      if(imgEl.hasAttribute('data-me') || imgEl.classList.contains('me') || imgEl.classList.contains('self')) return true;
    } catch(e){}
    return false;
  }

  // Enforce top avatar on matching nodes
  function enforceTopAvatarOnNode(imgEl, topAvatar){
    try {
      if(!imgEl || !topAvatar) return;
      // Avoid touching nav icons: check ancestor tags that might be navbars
      var navAncestor = imgEl.closest('nav, .navbar, .bottom-nav, .footer');
      if(navAncestor) return; // don't modify nav images
      // Only enforce if this img seems like a moment/post avatar
      var selMatch = /(^|\s)(moment-avatar|avatar-img|author-avatar|post-avatar|item-avatar|my-avatar|top-avatar|author-avatar-img)(\s|$)/i;
      var classStr = imgEl.className || '';
      // If it looks like an avatar or is IMG inside .moment/.post, proceed
      var likelyAvatar = classStr && selMatch.test(classStr) || imgEl.closest('.moment, .post, .item, .comment') || imgEl.getAttribute('data-role') === 'avatar';
      if(!likelyAvatar) return;
      if(!isAvatarForCurrentUser(imgEl)) return;
      // If current src differs, set it
      if(imgEl.tagName === 'IMG'){
        if(imgEl.src !== topAvatar){
          try { imgEl.src = topAvatar; } catch(e){}
        }
      } else {
        try { imgEl.style.backgroundImage = "url('"+topAvatar+"')"; } catch(e){}
      }
      // mark as forced to avoid loops
      try { imgEl.setAttribute('data-avatar-forced','1'); } catch(e){}
    } catch(e){}
  }

  // Enforce across the document
  function enforceTopAvatarAll(topAvatar){
    if(!topAvatar) return;
    var selectors = ['.moment-avatar', '.post .avatar-img', '.post .author-avatar', '.item .avatar', '.comment .avatar', 'img[data-role="avatar"]', '.avatar-img'];
    selectors.forEach(function(sel){
      document.querySelectorAll(sel).forEach(function(img){
        enforceTopAvatarOnNode(img, topAvatar);
      });
    });
  }

  // Mutation observer to catch src changes and new nodes
  var observer = new MutationObserver(function(muts){
    try {
      var top = getTopAvatar();
      muts.forEach(function(m){
        try {
          if(m.type === 'attributes' && (m.attributeName === 'src' || m.attributeName === 'style' || m.attributeName === 'data-author-id' || m.attributeName === 'data-author')){
            var target = m.target;
            if(target && (target.tagName === 'IMG' || target.nodeType === 1)){
              enforceTopAvatarOnNode(target, top);
            }
          } else if(m.type === 'childList' && m.addedNodes && m.addedNodes.length){
            m.addedNodes.forEach(function(node){
              try {
                if(node.nodeType !== 1) return;
                // find descendant avatar images
                var imgs = node.querySelectorAll && node.querySelectorAll('.moment-avatar, .avatar-img, img[data-role="avatar"], .author-avatar');
                if(imgs && imgs.length){
                  imgs.forEach(function(img){ enforceTopAvatarOnNode(img, top); });
                }
                // also if the node itself is an IMG
                if(node.tagName === 'IMG') enforceTopAvatarOnNode(node, top);
              } catch(e){}
            });
          }
        } catch(e){}
      });
    } catch(e){}
  });

  try {
    observer.observe(document.body, { attributes: true, childList: true, subtree: true, attributeFilter: ['src','style','data-author-id','data-author','data-author-name'] });
  } catch(e){}

  // Also run periodic enforcement for initial seconds to handle race conditions
  var enforcementRuns = 0;
  var enforcementTimer = setInterval(function(){
    try {
      enforcementRuns++;
      var top = getTopAvatar();
      if(top) enforceTopAvatarAll(top);
      // Try to update DB as well to persist
      try {
        if(top && typeof window.__updateProfileAndAvatars === 'function'){
          window.__updateProfileAndAvatars();
        }
      } catch(e){}
      if(enforcementRuns > 40) { // run ~40 times at 200ms => 8 seconds then stop
        clearInterval(enforcementTimer);
      }
    } catch(e){}
  }, 200);

  // Expose a function to explicitly bind list avatars to top avatar and optionally persist to DB
  window.bindMomentsAvatarsToTop = function(persistToDB){
    try {
      var top = getTopAvatar();
      if(!top) return;
      enforceTopAvatarAll(top);
      if(persistToDB){
        // try to update DB entries authorAvatar for current user
        try {
          var p = (typeof loadProfileFromStorage === 'function') ? loadProfileFromStorage() : { id: localStorage.getItem('myTopId') };
          if(p && p.id && window.AppDB_Moments && window.AppDB_Moments.moments){
            if(typeof window.AppDB_Moments.moments.where === 'function' && typeof window.AppDB_Moments.moments.modify === 'function'){
              try { window.AppDB_Moments.moments.where('authorId').equals(p.id).modify(function(o){ o.authorAvatar = top; }); } catch(e){}
            } else if(typeof window.AppDB_Moments.moments.toArray === 'function'){
              window.AppDB_Moments.moments.toArray().then(function(arr){
                arr.forEach(function(item){
                  if(item && item.authorId && String(item.authorId) === String(p.id)){
                    item.authorAvatar = top;
                    try { if(window.AppDB_Moments.moments.put) window.AppDB_Moments.moments.put(item); } catch(e){}
                  }
                });
              }).catch(function(){});
            }
          }
        } catch(e){}
      }
    } catch(e){}
  };

  // Attempt immediate bind once loaded
  try { setTimeout(function(){ window.bindMomentsAvatarsToTop(true); }, 100); } catch(e){}

  // defensive cleanup if script re-inserted: no-op

})();
</script>

<!-- Remove/hide avatars in moments list while preserving top avatar -->
<script>
(function(){
  'use strict';

  function isTopAvatarElement(el){
    if(!el) return false;
    try {
      var topSelectors = ['#icity-avatar', '.icity-avatar-wrap img', '.top-avatar', '.header-avatar img', '.profile-avatar img'];
      for(var i=0;i<topSelectors.length;i++){
        var sel = topSelectors[i];
        if(el.matches && el.matches(sel)) return true;
        // Also check if el is inside an element that matches a top selector (e.g., wrapper)
        var wrapper = document.querySelector(sel);
        if(wrapper && (wrapper === el || wrapper.contains(el))) return true;
      }
      // common 'my-avatar' class on top - check if element has that class and is in header
      if(el.classList && el.classList.contains('my-avatar')){
        // check if inside header
        if(el.closest('header, .header, .profile-top, .topbar')) return true;
      }
    } catch(e){}
    return false;
  }

  function isInNavOrFooter(el){
    try {
      if(!el) return false;
      if(el.closest('nav, .navbar, .bottom-nav, .footer, footer, .tabbar')) return true;
    } catch(e){}
    return false;
  }

  function looksLikeListAvatar(el){
    try {
      if(!el) return false;
      // require it to be an IMG element or have data-role attribute
      if(el.tagName !== 'IMG' && !el.hasAttribute('data-role')) return false;
      // class-based heuristics
      var cls = (el.className || '').toLowerCase();
      if(cls.indexOf('moment-avatar') !== -1 || cls.indexOf('avatar-img') !== -1 || cls.indexOf('author-avatar') !== -1 || cls.indexOf('post-avatar') !== -1 || cls.indexOf('item-avatar') !== -1) return true;
      if(el.getAttribute('data-role') === 'avatar') return true;
      // check if inside a moment/post/list container
      if(el.closest('.moment, .post, .item, .comment, .feed, .timeline, .moments, #moments-screen')) return true;
    } catch(e){}
    return false;
  }

  function hideListAvatar(el){
    try {
      if(!el || el.dataset && el.dataset.avatarRemoved) return;
      // Safety: do not remove images inside nav/footer or top avatar
      if(isTopAvatarElement(el)) return;
      if(isInNavOrFooter(el)) return;
      if(!looksLikeListAvatar(el)) return;
      // hide visually but keep DOM to avoid breaking layouts
      el.style.setProperty('display','none','important');
      el.setAttribute('data-avatar-removed','1');
    } catch(e){}
  }

  function processAllPotentialAvatars(){
    try {
      // inspect all img elements once and hide those that look like list avatars
      Array.prototype.slice.call(document.querySelectorAll('img')).forEach(function(img){
        hideListAvatar(img);
      });
      // also elements with data-role='avatar' that are not IMG
      Array.prototype.slice.call(document.querySelectorAll('[data-role="avatar"]')).forEach(function(el){
        hideListAvatar(el);
      });
    } catch(e){}
  }

  // Observe DOM changes to hide newly created avatars
  var obs = new MutationObserver(function(muts){
    try {
      muts.forEach(function(m){
        if(m.type === 'childList' && m.addedNodes && m.addedNodes.length){
          m.addedNodes.forEach(function(node){
            try {
              if(node.nodeType !== 1) return;
              if(node.tagName === 'IMG') hideListAvatar(node);
              // find descendant imgs
              var imgs = node.querySelectorAll && node.querySelectorAll('img, [data-role="avatar"]');
              if(imgs && imgs.length){
                imgs.forEach(function(i){ hideListAvatar(i); });
              }
            } catch(e){}
          });
        } else if(m.type === 'attributes' && (m.attributeName === 'src' || m.attributeName === 'class' || m.attributeName === 'data-author-id')){
          var tgt = m.target;
          if(tgt && tgt.tagName === 'IMG') hideListAvatar(tgt);
        }
      });
    } catch(e){}
  });

  try {
    obs.observe(document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ['src','class','data-author-id','data-author'] });
  } catch(e){}

  // Also intercept clicks on publish buttons to run processAllPotentialAvatars afterwards
  function attachPublishListener(){
    try {
      // heuristic selectors for publish buttons
      var selectors = ['button.publish','button[type="submit"]','.btn-publish','.publish-btn','#publish','.post-btn','.send','button[data-action="publish"]'];
      var found = false;
      selectors.forEach(function(sel){
        Array.prototype.slice.call(document.querySelectorAll(sel)).forEach(function(btn){
          try {
            if(btn._avatarHideAttached) return;
            btn.addEventListener('click', function(){
              setTimeout(processAllPotentialAvatars, 50);
            }, false);
            btn._avatarHideAttached = true;
            found = true;
          } catch(e){}
        });
      });
      // also attach a global delegation for any element with innerText '发布'
      if(!found){
        document.body.addEventListener('click', function(ev){
          try {
            var tgt = ev.target;
            if(!tgt) return;
            var text = (tgt.textContent || '').trim();
            if(text === '发布' || text === '发表' || text === '发送'){
              setTimeout(processAllPotentialAvatars, 50);
            }
          } catch(e){}
        }, true);
      }
    } catch(e){}
  }

  // Run initial pass
  try { setTimeout(processAllPotentialAvatars, 60); } catch(e){}
  try { setTimeout(attachPublishListener, 120); } catch(e){}

  // Expose control
  window.__removeListAvatars = function(){
    processAllPotentialAvatars();
  };

})();
</script>

<!-- Avatar fill patch: make avatar image fully fill its circular container (remove inner white gap) -->
<style>
/* Conservative selectors for avatar containers and images */
.icity-avatar-wrap, .avatar-wrap, .profile-avatar, .header-avatar, .my-avatar, .top-avatar, .avatar-circle, .avatar-holder {
  background: transparent !important;
  padding: 0 !important;
  border: 0 !important;
  overflow: hidden !important;
  border-radius: 50% !important;
  display: inline-block !important;
}

/* Ensure the img fills the container */
.icity-avatar-wrap img, .avatar-wrap img, .profile-avatar img, .header-avatar img, .my-avatar img, .top-avatar img, img.avatar-img, img[data-role="avatar"] {
  width: 100% !important;
  height: 100% !important;
  object-fit: cover !important;
  display: block !important;
  border-radius: 50% !important;
  background: transparent !important;
  padding: 0 !important;
  margin: 0 auto !important;
}

/* If the container uses an inner padding element, hide it */
.icity-avatar-wrap .inner-avatar, .avatar-wrap .inner, .avatar-inner {
  display: none !important;
}
</style>

<script>
(function(){
  'use strict';
  // Target selectors to clean up inline styles or extra wrapper padding
  var containerSelectors = [
    '#icity-avatar', '.icity-avatar-wrap', '.avatar-wrap', '.profile-avatar', '.header-avatar', '.my-avatar', '.top-avatar', '.avatar-circle', '.avatar-holder'
  ];
  var imgSelectors = [
    '.icity-avatar-wrap img', '.avatar-wrap img', '.profile-avatar img', '.header-avatar img', '.my-avatar img', '.top-avatar img', 'img.avatar-img', 'img[data-role="avatar"]'
  ];

  function applyAvatarFillOnce(){
    try {
      containerSelectors.forEach(function(sel){
        document.querySelectorAll(sel).forEach(function(el){
          try {
            // Do not touch elements that are inside nav/footer to avoid breaking bottom nav
            if(el.closest && (el.closest('nav, .navbar, .bottom-nav, footer, .tabbar, .tab-bar'))) return;
            el.style.background = 'transparent';
            el.style.padding = '0';
            el.style.border = '0';
            el.style.overflow = 'hidden';
            el.style.borderRadius = '50%';
            // ensure width/height exist: if wrapper uses fixed px size, keep it
            // nothing else forced to avoid layout shifts
          } catch(e){}
        });
      });
      imgSelectors.forEach(function(sel){
        document.querySelectorAll(sel).forEach(function(img){
          try {
            if(img.closest && (img.closest('nav, .navbar, .bottom-nav, footer, .tabbar, .tab-bar'))) return;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'cover';
            img.style.display = 'block';
            img.style.borderRadius = '50%';
            img.style.background = 'transparent';
            img.style.padding = '0';
            img.style.margin = '0 auto';
          } catch(e){}
        });
      });
    } catch(e){}
  }

  // Run on load and after small delay
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){ setTimeout(applyAvatarFillOnce,50); });
  } else {
    setTimeout(applyAvatarFillOnce,50);
  }

  // Observe for dynamic changes to re-apply if new avatars are added
  try {
    var mo = new MutationObserver(function(muts){
      var applied = false;
      muts.forEach(function(m){
        try {
          if(m.type === 'childList' && m.addedNodes && m.addedNodes.length){
            applied = true;
          } else if(m.type === 'attributes' && (m.attributeName === 'class' || m.attributeName === 'style' || m.attributeName === 'src')){
            applied = true;
          }
        } catch(e){}
      });
      if(applied) {
        // throttle a bit
        clearTimeout(window.__avatarFillTimer);
        window.__avatarFillTimer = setTimeout(applyAvatarFillOnce, 40);
      }
    });
    mo.observe(document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ['class','style','src'] });
  } catch(e){}

  // Expose for manual invocation
  try { window.__applyAvatarFill = applyAvatarFillOnce; } catch(e){}

})();
</script>

<!-- Moments 多选删除底部操作栏 -->
<div id="moments-multi-select-bar" class="multi-select-bar" aria-hidden="true">
  <div class="msb-left">
    <span id="moments-selected-count">已选择 0 项</span>
  </div>
  <div class="msb-right">
    <button id="moments-confirm-delete" class="danger">确认删除</button>
    <button id="moments-cancel-delete">取消</button>
  </div>
</div>

<script>
(function(){
  // State
  let isInMomentsDeleteMode = false;
  const selectedMomentIds = new Set();

  // Helpers to find DB
  const maybeDb = window.db || window.AppDB_Moments || (window.AppDB && window.AppDB.moments? window.AppDB : null);

  const momentsScreen = document.getElementById('moments-screen');
  const momentsContainer = document.getElementById('moments-list') || document.getElementById('moments-container') || document.getElementById('moments-list');
  const deleteBtn = document.getElementById('moments-delete-btn');
  const actionGroup = document.querySelector('#moments-screen .action-btn-group');
  const msBar = document.getElementById('moments-multi-select-bar');
  const msCount = document.getElementById('moments-selected-count');
  const msConfirm = document.getElementById('moments-confirm-delete');
  const msCancel = document.getElementById('moments-cancel-delete');
  const backBtn = document.querySelector('#moments-screen .back-btn');

  function updateCount(){
    msCount.textContent = '已选择 ' + selectedMomentIds.size + ' 项';
  }
  function enterDeleteMode(){
    if(isInMomentsDeleteMode) return;
    isInMomentsDeleteMode = true;
    if(momentsScreen) momentsScreen.classList.add('is-delete-mode');
    if(actionGroup) actionGroup.style.display = 'none';
    if(msBar) msBar.classList.add('show');
    selectedMomentIds.clear();
    document.querySelectorAll('.moment-item.is-selected').forEach(el=>el.classList.remove('is-selected'));
    updateCount();
  }
  function exitDeleteMode(){
    if(!isInMomentsDeleteMode) return;
    isInMomentsDeleteMode = false;
    if(momentsScreen) momentsScreen.classList.remove('is-delete-mode');
    if(actionGroup) actionGroup.style.display = '';
    if(msBar) msBar.classList.remove('show');
    selectedMomentIds.clear();
    document.querySelectorAll('.moment-item.is-selected').forEach(el=>el.classList.remove('is-selected'));
    updateCount();
  }

  // Click delete button to enter mode
  if(deleteBtn) deleteBtn.addEventListener('click', function(e){
    e.preventDefault();
    enterDeleteMode();
  });

  // Cancel
  if(msCancel) msCancel.addEventListener('click', function(e){
    e.preventDefault();
    exitDeleteMode();
  });

  // Container delegation for selecting items
  if(momentsContainer){
    momentsContainer.addEventListener('click', function(e){
      if(!isInMomentsDeleteMode) return;
      // find closest .moment-item
      let el = e.target;
      while(el && !el.classList.contains('moment-item')) el = el.parentElement;
      if(!el) return;
      e.preventDefault(); e.stopPropagation();
      const id = el.dataset && el.dataset.id;
      if(!id) return;
      if(selectedMomentIds.has(id)){
        selectedMomentIds.delete(id);
        el.classList.remove('is-selected');
      } else {
        selectedMomentIds.add(id);
        el.classList.add('is-selected');
      }
      updateCount();
    }, true);
  }

  // Confirm delete
  if(msConfirm){
    msConfirm.addEventListener('click', async function(e){
      e.preventDefault();
      if(selectedMomentIds.size === 0){
        alert('未选择项目');
        return;
      }
      if(!confirm('确定删除选中的 ' + selectedMomentIds.size + ' 条动态？此操作不可撤销')) return;
      const ids = Array.from(selectedMomentIds);
      try {
        if(maybeDb && maybeDb.moments && typeof maybeDb.moments.bulkDelete === 'function'){
          await maybeDb.moments.bulkDelete(ids);
        } else if(maybeDb && maybeDb.moments){
          // fallback: delete one by one
          for(const id of ids){
            try{ await maybeDb.moments.delete(id); }catch(e){}
          }
        } else if(window.AppDB_Moments && window.AppDB_Moments.moments && typeof window.AppDB_Moments.moments.bulkDelete === 'function'){
          await window.AppDB_Moments.moments.bulkDelete(ids);
        } else {
          console.warn('No Dexie moments DB found for deletion');
        }
        // refresh render if available
        if(typeof renderMoments === 'function') try{ await renderMoments(); }catch(e){}
        if(typeof window.renderMomentsSafe === 'function') try{ await window.renderMomentsSafe(); }catch(e){}
        exitDeleteMode();
        alert('删除成功');
      } catch (err){
        console.error('批量删除失败', err);
        alert('删除失败，请查看控制台。');
      }
    });
  }

  // Back button behavior
  if(backBtn){
    backBtn.addEventListener('click', function(e){
      if(isInMomentsDeleteMode){
        e.preventDefault();
        exitDeleteMode();
      }
    });
  }

})();
</script>

<!-- 覆盖：确保 moment 图片描述卡的底色与文字颜色生效（放在文件末尾以覆盖所有样式） -->
<style>
.moment-image-desc-card {
  background: #eef0f3 !important; /* 浅灰底色 - 覆盖原有渐变 */
  border: 6px solid #ffffff !important;
  box-shadow: 0 6px 20px rgba(10,10,20,0.06) !important;
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;

  padding: 12px 14px !important;
  margin-top: 6px !important;
  min-height: 86px !important;
}
.moment-image-desc-card .desc-content { font-size: 13px !important; }

.moment-image-desc-card .desc-content,
.moment-image-desc-card p.desc-content {
  color: #66676b !important;
  background: transparent !important;
}
/* 如果存在内层容器，确保去掉其背景并使用浅灰色 */
.moment-image-desc-card > .inner,
.moment-image-desc-card > .card-inner,
.moment-image-desc-card > .content {
  background: transparent !important;
}
</style>



<!-- 覆盖：移除卡片内所有文字阴影，确保描述文字不带阴影 -->
<style>
.moment-image-desc-card, 
.moment-image-desc-card *,
.moment-image-desc-card .desc-content,
.moment-image-desc-card .description,
.moment-image-desc-card .image-desc,
.moment-image-desc-card .desc {
  text-shadow: none !important;
  -webkit-text-shadow: none !important;
  filter: none !important;
}
</style>


<!-- Modal layout fixes: align action buttons and tighten image checkbox spacing -->
<style>
/* Try to scope to likely modal/dialog containers without touching other buttons */
/* If your modal has a specific id or class, replace .publish-modal below with it. */
.publish-modal, .publish-dialog, .moment-publish-modal, .dialog-publish, .publishBox {
  /* ensure modal content uses flex column so footer aligns correctly */
  display: block;
}

/* Make the actions row use flex so buttons are equal size and aligned */
.publish-modal .actions,
.publish-dialog .actions,
.moment-publish-modal .actions,
.dialog-publish .actions,
.publishBox .actions,
.publish-actions {
  display: flex !important;
  gap: 12px;
  align-items: center;
  justify-content: space-between;
  padding: 0 !important;
}

/* Ensure buttons inside actions share equal width and similar height */
.publish-modal .actions button,
.publish-dialog .actions button,
.moment-publish-modal .actions button,
.dialog-publish .actions button,
.publishBox .actions button,
.publish-actions button {
  flex: 1 1 0;
  max-width: none;
  min-width: 0;
  height: 52px;
  border-radius: 12px;
  font-weight: 600;
  padding: 0 16px;
  box-sizing: border-box;
}

/* Make the cancel button visually secondary if needed */
.publish-modal .actions .cancel,
.publish-dialog .actions .cancel,
.publishBox .actions .cancel,
.publish-actions .cancel {
  background: #bfe6ff; /* light blue like your screenshot */
  color: #fff;
}

/* Publish button primary color */
.publish-modal .actions .primary,
.publish-dialog .actions .primary,
.publishBox .actions .primary,
.publish-actions .primary {
  background: #ff95bf; /* pink from screenshot */
  color: #fff;
}

/* Tighten spacing for the "add image" checkbox area */
.add-image-row, .add-image, .image-checkbox, .add-photo, .add-picture {
  margin-top: 6px !important;
  margin-bottom: 6px !important;
  display: flex !important;
  gap: 8px;
  align-items: center;
}

/* If checkbox itself has large margin, reduce it */
.add-image-row input[type="checkbox"],
.image-checkbox input[type="checkbox"],
.add-photo input[type="checkbox"] {
  margin: 0 !important;
  transform: scale(1.05);
}

/* Small screens: keep buttons stacked but full-width with proper gap */
@media (max-width: 420px) {
  .publish-modal .actions,
  .publish-dialog .actions,
  .moment-publish-modal .actions,
  .dialog-publish .actions,
  .publishBox .actions,
  .publish-actions {
    flex-direction: column;
  }
  .publish-modal .actions button,
  .publish-dialog .actions button,
  .moment-publish-modal .actions button,
  .dialog-publish .actions button,
  .publishBox .actions button,
  .publish-actions button {
    width: 100%;
  }
}
</style>


<!-- Precise fixes for the 发布动态 form: equalize buttons and tighten checkbox spacing -->
<style>
/* Scope strictly to the post form to avoid affecting other UIs */
#post-form { font-family: inherit; }

/* Find the action container which uses inline flex; ensure children buttons take equal space */
#post-form > div[style*="display:flex"] {
  display: flex !important;
  gap: 10px !important;
  margin-top: 12px !important;
  align-items: stretch !important;
}

/* Make buttons equal width, same height, and matching radius */
#post-form > div[style*="display:flex"] .btn {
  flex: 1 1 0 !important;
  min-width: 0 !important;
  height: 52px !important;
  padding: 0 16px !important;
  border-radius: 12px !important;
  box-sizing: border-box !important;
  font-weight: 600 !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
}

/* If there are specific modifier classes, ensure colors remain similar to your theme */
#post-form > div[style*="display:flex"] .btn-sec { background: #bfe6ff !important; color: #fff !important; border: none !important; }
#post-form > div[style*="display:flex"] .btn-primary { background: #ff95bf !important; color: #fff !important; border: none !important; }

/* Tighten the "添加图片" checkbox row */
#post-form .form-group label {
  display: inline-flex !important;
  align-items: center !important;
  gap: 8px !important;
  margin-top: 6px !important;
  cursor: pointer;
}

#post-form #add-image {
  margin: 0 !important;
  transform: scale(1.05) !important;
  vertical-align: middle !important;
}

/* Ensure image input group sits closer */
#image-input-group { margin-top: 8px !important; margin-bottom: 6px !important; }

/* Small screens: stack buttons but keep spacing */
@media (max-width: 420px) {
  #post-form > div[style*="display:flex"] { flex-direction: column !important; }
  #post-form > div[style*="display:flex"] .btn { width: 100% !important; }
}
</style>


<!-- Fix: keep '添加图片' label on one line and allow it to lay out horizontally -->
<style>
/* Prevent the label text from wrapping and ensure layout is inline */
#post-form .form-group label {
  white-space: nowrap !important;
  flex-wrap: nowrap !important;
  width: auto !important;
}

/* If any spans inside the label are forced to block, make them inline */
#post-form .form-group label span,
#post-form .form-group label b,
#post-form .form-group label i {
  display: inline !important;
}

/* Allow the label to take available horizontal space so text doesn't collapse */
#post-form .form-group {
  display: flex !important;
  align-items: center !important;
  gap: 8px !important;
}
</style>

</body>
</html>